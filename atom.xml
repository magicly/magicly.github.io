<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JustForFun</title>
  <subtitle>Programmer, Geek, Magic, Poker, ML</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://magicly.me/"/>
  <updated>2017-05-17T09:19:58.000Z</updated>
  <id>http://magicly.me/</id>
  
  <author>
    <name>magicly</name>
    <email>magicly007@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>jupyter转github pages</title>
    <link href="http://magicly.me/2017/04/20/jupyter-to-github-pages/"/>
    <id>http://magicly.me/2017/04/20/jupyter-to-github-pages/</id>
    <published>2017-04-20T03:20:43.000Z</published>
    <updated>2017-05-17T09:19:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Pelican"><a href="#Pelican" class="headerlink" title="Pelican"></a>Pelican</h1><p><a href="https://junjiecai.github.io/posts/2016/Jun/10/blog_with_jupyter/" target="_blank" rel="external">https://junjiecai.github.io/posts/2016/Jun/10/blog_with_jupyter/</a><br><a href="http://www.jianshu.com/p/d78e9f741a79" target="_blank" rel="external">http://www.jianshu.com/p/d78e9f741a79</a><br><a href="https://zhuanlan.zhihu.com/p/22848234" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/22848234</a><br><a href="https://www.dataquest.io/blog/how-to-setup-a-data-science-blog/" target="_blank" rel="external">https://www.dataquest.io/blog/how-to-setup-a-data-science-blog/</a></p>
<h1 id="jupyter-nbconvert"><a href="#jupyter-nbconvert" class="headerlink" title="jupyter nbconvert"></a>jupyter nbconvert</h1><p><a href="https://github.com/jupyter/nbconvert" target="_blank" rel="external">https://github.com/jupyter/nbconvert</a></p>
<h1 id="brew加速"><a href="#brew加速" class="headerlink" title="brew加速"></a>brew加速</h1><p><a href="https://w3cboy.com/post/2017/03/homebrew-speed-up/" target="_blank" rel="external">https://w3cboy.com/post/2017/03/homebrew-speed-up/</a><br><a href="https://lug.ustc.edu.cn/wiki/mirrors/help/homebrew-bottles" target="_blank" rel="external">https://lug.ustc.edu.cn/wiki/mirrors/help/homebrew-bottles</a><br><a href="https://www.zhihu.com/question/31360766" target="_blank" rel="external">https://www.zhihu.com/question/31360766</a><br><a href="http://blog.suconghou.cn/post/homebrew-speedup/" target="_blank" rel="external">http://blog.suconghou.cn/post/homebrew-speedup/</a><br><a href="https://www.tomwei7.com/2016/01/10/brew-%E5%88%87%E6%8D%A2Git%E6%BA%90%E5%92%8C%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F/" target="_blank" rel="external">https://www.tomwei7.com/2016/01/10/brew-%E5%88%87%E6%8D%A2Git%E6%BA%90%E5%92%8C%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F/</a></p>
<h1 id="jupyter"><a href="#jupyter" class="headerlink" title="jupyter"></a>jupyter</h1><p><a href="https://github.com/jupyter/jupyter/wiki/A-gallery-of-interesting-Jupyter-Notebooks" target="_blank" rel="external">https://github.com/jupyter/jupyter/wiki/A-gallery-of-interesting-Jupyter-Notebooks</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Pelican&quot;&gt;&lt;a href=&quot;#Pelican&quot; class=&quot;headerlink&quot; title=&quot;Pelican&quot;&gt;&lt;/a&gt;Pelican&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://junjiecai.github.io/posts/2016/Ju
    
    </summary>
    
      <category term="jupyter" scheme="http://magicly.me/categories/jupyter/"/>
    
    
      <category term="jupyter" scheme="http://magicly.me/tags/jupyter/"/>
    
  </entry>
  
  <entry>
    <title>aws上配置docker</title>
    <link href="http://magicly.me/2017/04/19/aws-docker/"/>
    <id>http://magicly.me/2017/04/19/aws-docker/</id>
    <published>2017-04-19T09:45:42.000Z</published>
    <updated>2017-05-17T09:19:31.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何查看cuda版本"><a href="#如何查看cuda版本" class="headerlink" title="如何查看cuda版本"></a>如何查看cuda版本</h1><p><a href="http://www.cnblogs.com/shrimp-can/p/5253672.html" target="_blank" rel="external">http://www.cnblogs.com/shrimp-can/p/5253672.html</a></p>
<p>默认目录为：local，进入local：cd /usr/local</p>
<p>输入命令：ls，查看该目录下的文件，可以看到安装的cuda在此处</p>
<p>进入cuda文件：cd cuda-7.5（我的是7.5），此处为安装的东西</p>
<h1 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h1><p><a href="https://docs.docker.com/engine/installation/linux/ubuntu/" target="_blank" rel="external">https://docs.docker.com/engine/installation/linux/ubuntu/</a></p>
<h1 id="安装nvidia-docker"><a href="#安装nvidia-docker" class="headerlink" title="安装nvidia-docker"></a>安装nvidia-docker</h1><p><a href="https://github.com/NVIDIA/nvidia-docker" target="_blank" rel="external">https://github.com/NVIDIA/nvidia-docker</a></p>
<h1 id="docker端口映射"><a href="#docker端口映射" class="headerlink" title="docker端口映射"></a>docker端口映射</h1><p><a href="https://opskumu.gitbooks.io/docker/content/chapter5.html" target="_blank" rel="external">https://opskumu.gitbooks.io/docker/content/chapter5.html</a></p>
<h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><h2 id="dpkg-lock"><a href="#dpkg-lock" class="headerlink" title="dpkg lock"></a>dpkg lock</h2><blockquote>
<p>dpkg: error: dpkg status database is locked by another process</p>
</blockquote>
<p><a href="https://askubuntu.com/questions/219545/dpkg-error-dpkg-status-database-is-locked-by-another-process" target="_blank" rel="external">https://askubuntu.com/questions/219545/dpkg-error-dpkg-status-database-is-locked-by-another-process</a><br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo rm /var/<span class="class"><span class="keyword">lib</span>/<span class="title">dpkg</span>/<span class="title">lock</span></span></div><div class="line">sudo dpkg --configure -a</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;如何查看cuda版本&quot;&gt;&lt;a href=&quot;#如何查看cuda版本&quot; class=&quot;headerlink&quot; title=&quot;如何查看cuda版本&quot;&gt;&lt;/a&gt;如何查看cuda版本&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/shrimp
    
    </summary>
    
      <category term="ML" scheme="http://magicly.me/categories/ML/"/>
    
    
      <category term="ml" scheme="http://magicly.me/tags/ml/"/>
    
      <category term="aws" scheme="http://magicly.me/tags/aws/"/>
    
      <category term="docker" scheme="http://magicly.me/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>阿里云HPC深度学习配置从入门到真的放弃</title>
    <link href="http://magicly.me/2017/04/19/aliyun-hpc-config/"/>
    <id>http://magicly.me/2017/04/19/aliyun-hpc-config/</id>
    <published>2017-04-19T02:03:02.000Z</published>
    <updated>2017-04-19T06:33:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>深度学习没有GPU的支持可以说完全不能解决实际问题， 稍大一点的数据集可能就要几个小时，GPU能起到10倍以及更高的速度提升。之前我们做了<a href="http://magicly.me/2017/04/15/aws-dl-config/">AWS的深度学习配置</a>，今天再看看国内阿里云的HPC配置。</p>
<a id="more"></a>
<h1 id="购买-amp-登录"><a href="#购买-amp-登录" class="headerlink" title="购买 &amp; 登录"></a>购买 &amp; 登录</h1><p>在<a href="https://hpc-buy.aliyun.com/#/postpay" target="_blank" rel="external">阿里云hpc页面</a>购买，目前按量付费只支持华东1（杭州），G4配置：</p>
<blockquote>
<p>CPU : Intel Xeon E5 v4 CPU 32物理核<br>GPU : Nvidia Tesla M40 x2<br>单机峰值计算能力突破每秒16万亿次单精度浮点运算。</p>
</blockquote>
<p>价格是37.50￥/时，价格差不多是AWS p2.xlarge的6倍， 所以我们最后要测试一下AWS p2.xlarge和阿里云HPC的性能对比，看看谁的性价比高。</p>
<p>对了，阿里云HPC目前不支持自定义镜像，只有一种选择CentOS7！！！！所以后面我们必须用docker，不然如果按需付费来使用的话， 每次都得重装所有软件。可以把docker看成轻量级的AMI镜像。</p>
<p>由于HPC是只能内网访问的物理机， 需要先登录跳转机， 然后走内网访问HPC，这样安全一些。华东1购买HPC的时候会分配一个跳转机，需要在<a href="https://hpc.console.aliyun.com/#/postpay/list/" target="_blank" rel="external">控制台</a>设置跳转机的初始密码，重启跳转机密码方能生效。HPC物理机的密码会通过阿里云站内消息的方式发给你，好像都是111111，建议在第一次登录的时候用passwd命令修改。</p>
<h1 id="配置外网"><a href="#配置外网" class="headerlink" title="配置外网"></a>配置外网</h1><p>现在HPC物理机能直接访问外网了？！！<br>wget能直接访问， 但是yum install的时候就是网络超时，真是蛋疼！</p>
<p>参看<a href="https://yq.aliyun.com/articles/66993?spm=5176.doc48632.2.5.V1yqJr" target="_blank" rel="external">这篇文档</a>配置HPC外网。文档里面有好几个地方不对，我重新写一下吧。</p>
<h2 id="跳转机ECS配置"><a href="#跳转机ECS配置" class="headerlink" title="跳转机ECS配置"></a>跳转机ECS配置</h2><ol>
<li><p>下载VPN包，解压并进入VPN-ECS</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">wget http:<span class="comment">//public-img-test.oss-cn-hangzhou.aliyuncs.com/VPN.tar.gz</span></div><div class="line">tar zxvf VPN<span class="selector-class">.tar</span><span class="selector-class">.gz</span> &amp;&amp; cd VPN/VPN-ECS</div></pre></td></tr></table></figure>
</li>
<li><p>目录下并没有文档说的run.sh， 而是两个</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ru<span class="symbol">n4</span>ce<span class="symbol">ntos6</span>.sh</div><div class="line">ru<span class="symbol">n4</span>ce<span class="symbol">ntos7</span>.sh</div></pre></td></tr></table></figure>
</li>
</ol>
<p>用lsb_release命令查看系统版本（还记得我说其实目前只能选centos7么）：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-attr">[root@iZ23gbdj71dZ VPN-ECS]</span># <span class="selector-tag">lsb_release</span> <span class="selector-tag">-a</span></div><div class="line"><span class="selector-tag">LSB</span> <span class="selector-tag">Version</span>:	<span class="selector-pseudo">:core-4.1-amd64</span><span class="selector-pseudo">:core-4.1-noarch</span></div><div class="line"><span class="selector-tag">Distributor</span> <span class="selector-tag">ID</span>:	<span class="selector-tag">CentOS</span></div><div class="line"><span class="selector-tag">Description</span>:	<span class="selector-tag">CentOS</span> <span class="selector-tag">Linux</span> <span class="selector-tag">release</span> 7<span class="selector-class">.0</span><span class="selector-class">.1406</span> (<span class="selector-tag">Core</span>)</div><div class="line"><span class="selector-tag">Release</span>:	7<span class="selector-class">.0</span><span class="selector-class">.1406</span></div><div class="line"><span class="selector-tag">Codename</span>:	<span class="selector-tag">Core</span></div></pre></td></tr></table></figure></p>
<p>那就执行run4centos7.sh吧</p>
<ol>
<li>ifconfig检查是否有vpn_ppp0这个网卡<figure class="highlight tap"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">ifconfig</div><div class="line"></div><div class="line">vpn_vpn0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</div><div class="line">        inet 192.168.30.11  netmask 255.255.255.0  broadcast 192.168.30.255</div><div class="line">        ether 00:ac:66:6f:b0:52  txqueuelen<span class="number"> 500 </span> (Ethernet)</div><div class="line">        RX packets<span class="number"> 1 </span> bytes<span class="number"> 42 </span>(42.0 B)</div><div class="line">        RX errors<span class="number"> 0 </span> dropped<span class="number"> 0 </span> overruns<span class="number"> 0 </span> frame 0</div><div class="line">        TX packets<span class="number"> 4 </span> bytes<span class="number"> 168 </span>(168.0 B)</div><div class="line">        TX errors<span class="number"> 0 </span> dropped<span class="number"> 0 </span>overruns<span class="number"> 0 </span> carrier<span class="number"> 0 </span> collisions 0</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="HPC配置"><a href="#HPC配置" class="headerlink" title="HPC配置"></a>HPC配置</h2><ol>
<li><p>下载VPN包，解压并进入VPN-HPC<br>由于HPC目前不能访问外网OSS（真是蛋疼， 其实HPC现在访问外网比如<a href="http://www.platform.ai/files/dogscats.zip是可以的，但居然真的不能访问http://public-img-test.oss-cn-hangzhou.aliyuncs.com/VPN.tar.gz！！！），所以用scp将之前在跳转机上下载的VPN包copy到HPC。" target="_blank" rel="external">http://www.platform.ai/files/dogscats.zip是可以的，但居然真的不能访问http://public-img-test.oss-cn-hangzhou.aliyuncs.com/VPN.tar.gz！！！），所以用scp将之前在跳转机上下载的VPN包copy到HPC。</a></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">scp root@[跳转机内网IP地址]:/root/VPN<span class="selector-class">.tar</span><span class="selector-class">.gz</span> .</div><div class="line">tar zxvf VPN<span class="selector-class">.tar</span><span class="selector-class">.gz</span> &amp;&amp; cd VPN/VPN-HPC</div></pre></td></tr></table></figure>
</li>
<li><p>执行run.sh</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./<span class="keyword">run</span>.<span class="bash">sh [跳转机内网IP地址]</span></div></pre></td></tr></table></figure>
</li>
<li><p>测试是否能访问外网</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ping www<span class="selector-class">.taobao</span><span class="selector-class">.com</span></div><div class="line">curl www<span class="selector-class">.taobao</span><span class="selector-class">.com</span></div><div class="line">wget www<span class="selector-class">.baidu</span><span class="selector-class">.com</span></div></pre></td></tr></table></figure>
</li>
</ol>
<p>可以了。 话说我一开始就可以啊！！！！<br>测试一下wget VPN包呢？<br><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-attr">[root@AliHPC-M40-410 VPN-HPC]</span># <span class="selector-tag">wget</span> <span class="selector-tag">http</span>:<span class="comment">//public-img-test.oss-cn-hangzhou.aliyuncs.com/VPN.tar.gz</span></div><div class="line"><span class="selector-tag">--2017-04-19</span> <span class="selector-tag">10</span><span class="selector-pseudo">:50</span><span class="selector-pseudo">:59--</span>  <span class="selector-tag">http</span>:<span class="comment">//public-img-test.oss-cn-hangzhou.aliyuncs.com/VPN.tar.gz</span></div><div class="line">正在连接 <span class="selector-tag">10</span><span class="selector-class">.168</span><span class="selector-class">.56</span><span class="selector-class">.7</span><span class="selector-pseudo">:3128...</span> 失败：没有到主机的路由。</div></pre></td></tr></table></figure></p>
<p>居然还是访问不到!!!</p>
<ol>
<li>文档里面说如果这时候还不行， 看看http_proxy &amp; https_proxy两个变量，如果设置了，删除<figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[root@AliHPC-M40<span class="number">-410</span> VPN-HPC]<span class="meta"># echo $http_proxy</span></div><div class="line"><span class="symbol">http:</span><span class="comment">//10.168.56.7:3128/</span></div><div class="line">[root@AliHPC-M40<span class="number">-410</span> VPN-HPC]<span class="meta"># echo $https_proxy</span></div><div class="line"><span class="symbol">http:</span><span class="comment">//10.168.56.7:3128/</span></div></pre></td></tr></table></figure>
</li>
</ol>
<p>确实设置了， 试试看删除之后呢。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">unset</span> http_proxy</div><div class="line"><span class="keyword">unset</span> https_proxy</div><div class="line">wget http:<span class="comment">//public-img-test.oss-cn-hangzhou.aliyuncs.com/VPN.tar.gz</span></div></pre></td></tr></table></figure></p>
<p>好吧，真的可以了！！！</p>
<h1 id="配置docker"><a href="#配置docker" class="headerlink" title="配置docker"></a>配置docker</h1><p>参考<a href="https://yq.aliyun.com/articles/64979?spm=5176.doc48632.2.6.V1yqJr" target="_blank" rel="external">这篇https://yq.aliyun.com/articles/64979?spm=5176.doc48632.2.6.V1yqJr</a>，其实大部分都不是必须的，只需要下面两步即可。</p>
<ol>
<li><p>更新repo，镜像里已经装了docker的，更新一下版本</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">sudo yum update</span></div></pre></td></tr></table></figure>
</li>
<li><p>验证docker是否装好</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo docker <span class="keyword">run</span><span class="bash"> hello-world</span></div></pre></td></tr></table></figure>
</li>
</ol>
<p>噢啦。。。</p>
<h2 id="安装nvidia-docker"><a href="#安装nvidia-docker" class="headerlink" title="安装nvidia-docker"></a>安装nvidia-docker</h2><p>nvidia－docker 是 Nvidia 公司为 docker 所做的封装，开源代码可以在<a href="https://github.com/NVIDIA/nvidia-docker" target="_blank" rel="external">Github</a>找到。nvidia－docker 可以对GPU做抽象，只要容器中的GPU驱动版本不高于宿主机的GPU驱动版本，即可在容器中使用GPU资源。<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># Install nvidia-docker <span class="keyword">and</span> nvidia-docker-plugin</div><div class="line">wget -P /tmp https://github.com/NVIDIA/nvidia-docker/releases/download/v1<span class="meta">.0</span><span class="meta">.1</span>/nvidia-docker-<span class="number">1.0</span><span class="meta">.1</span>-<span class="number">1.</span>x86_64.rpm</div><div class="line">sudo rpm -i /tmp/nvidia-docker*.rpm &amp;&amp; rm /tmp/nvidia-docker*.rpm</div><div class="line">sudo systemctl start nvidia-docker</div><div class="line"></div><div class="line"># <span class="keyword">Test</span> nvidia-<span class="keyword">smi</span></div><div class="line">nvidia-docker run --rm nvidia/cuda nvidia-<span class="keyword">smi</span></div></pre></td></tr></table></figure></p>
<h1 id="测试tensorflow"><a href="#测试tensorflow" class="headerlink" title="测试tensorflow"></a>测试tensorflow</h1><p>阿里云HPC服务器在交付时已经安装好TensorFlow （版本 0.8rc），用户无需做任何额外工作即可直接运行。<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta-keyword">/disk1/</span>deeplearning<span class="meta-keyword">/anaconda2/</span>bin/python -m <span class="string">"tensorflow.models.image.mnist.convolutional"</span></div></pre></td></tr></table></figure></p>
<p>上两张图，看一下跑起来的时候资源消耗：<br><img src="http://oml1i2pi6.bkt.clouddn.com/nvidia-smi-when-tensorflow-is-run.png" alt="nvidia-smi when tensorflow is run"><br><img src="http://oml1i2pi6.bkt.clouddn.com/htop-when-tensorflow-is-run.png" alt="htop when tensorflow is run"></p>
<h1 id="tensorflow-docker"><a href="#tensorflow-docker" class="headerlink" title="tensorflow docker"></a>tensorflow docker</h1><p>我打算用docker跑tensorflow，测试一下性能。结果用<a href="https://help.aliyun.com/document_detail/51489.html" target="_blank" rel="external">阿里提供的镜像</a>时候又发现cuda版本问题。<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[root@AliHPC-M40-<span class="number">410</span> deeplearning]# nvidia-docker run registry.<span class="keyword">cn</span>-beijing.aliyuncs.<span class="keyword">com</span>/tensorflow-samples/alexnet_benchmark:<span class="number">1.0</span>.<span class="number">0</span>-devel-gpu</div><div class="line"></div><div class="line">Statu<span class="variable">s:</span> Downloaded newer image <span class="keyword">for</span> registry.<span class="keyword">cn</span>-beijing.aliyuncs.<span class="keyword">com</span>/tensorflow-samples/alexnet_benchmark:<span class="number">1.0</span>.<span class="number">0</span>-devel-gpu</div><div class="line">nvidia-docker | <span class="number">2017</span>/<span class="number">04</span>/<span class="number">19</span> <span class="number">13</span>:<span class="number">02</span>:<span class="number">34</span> Error: unsupported CUDA <span class="keyword">version</span>: driver <span class="number">7.5</span> &lt; image <span class="number">8.0</span></div></pre></td></tr></table></figure></p>
<p>直接用yum upgrade cuda不行的， 需要添加cuda8的源才能正常安装cuda8， 参看<a href="https://developer.nvidia.com/cuda-downloads" target="_blank" rel="external">nvidia文档</a><br><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">wget http:<span class="regexp">//</span>developer.download.nvidia.com<span class="regexp">/compute/</span>cuda<span class="regexp">/repos/</span>rhel7<span class="regexp">/x86_64/</span>cuda-repo-rhel7-<span class="number">8.0</span>.<span class="number">61</span>-<span class="number">1</span>.x86_64.rpm</div><div class="line">rpm -ivh cuda-repo-rhel7-<span class="number">8.0</span>.<span class="number">61</span>-<span class="number">1</span>.x86_64.rpm</div><div class="line">yum install cuda</div></pre></td></tr></table></figure></p>
<p>居然有1.3G这么大，花了一个多小时，55555， 有点想放弃了，关键是安装了之后不能制作镜像，如果按需付费下次还得再来一次，每次安装cuda8就得花40块钱？！！！看样子阿里云HPC就是给有钱人准备的,9000￥/月。我已经给阿里云提了工单，请求他们把镜像升级到cuda8.0， 不知道啥时候回响应呢。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">安装  <span class="selector-tag">2</span> 软件包 (+<span class="number">31</span> 依赖软件包)</div><div class="line">升级  <span class="selector-tag">1</span> 软件包 (+ <span class="number">4</span> 依赖软件包)</div><div class="line"></div><div class="line">总下载量：<span class="selector-tag">1</span><span class="selector-class">.3</span> <span class="selector-tag">G</span></div><div class="line"><span class="selector-tag">Is</span> <span class="selector-tag">this</span> <span class="selector-tag">ok</span> <span class="selector-attr">[y/d/N]</span>: <span class="selector-tag">y</span></div></pre></td></tr></table></figure></p>
<p>装好之后居然<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@AliHPC-M40<span class="number">-410</span> deeplearning]<span class="comment"># nvidia-smi                                          │[root@AliHPC-M40-410 deeplearning]# nvidia-docker stop 2448268d9525</span></div><div class="line">Failed <span class="keyword">to</span> initialize NVML: Driver/library <span class="built_in">version</span> mismatch</div></pre></td></tr></table></figure></p>
<p>额。。。。。。。</p>
<p>在等待cuda安装的时候，我在阿里云的docker hub上找了个<a href="https://dev.aliyun.com/list.html?namePrefix=tensorflow" target="_blank" rel="external">tensorflow镜像</a>。这个docker image包含jupyter notebook，默认监听的端口是8888，需要把docker的端口映射到宿主机（HPC）上。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nvidia-docker run -<span class="selector-tag">p</span> <span class="number">80</span>:<span class="number">8888</span> registry<span class="selector-class">.cn-hangzhou</span><span class="selector-class">.aliyuncs</span><span class="selector-class">.com</span>/denverdino/tensorflow</div></pre></td></tr></table></figure></p>
<p>这时候在HPC上wget localhost就可以访问到jupyter notebook的index.html了，但是我们之前说过HPC只能在内网，所以还需要配置<a href="https://help.aliyun.com/document_detail/25836.html" target="_blank" rel="external">反向代理</a>。</p>
<ol>
<li>ECS跳转机部署代理服务器tengine<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">wget http:<span class="comment">//tengine.taobao.org/download/tengine-2.1.1.tar.gz</span></div><div class="line"></div><div class="line">tar zxvf tengine-<span class="number">2.1</span>.<span class="number">1</span><span class="selector-class">.tar</span><span class="selector-class">.gz</span></div><div class="line">cd tengine-<span class="number">2.1</span>.<span class="number">1</span>/</div><div class="line"></div><div class="line">./configure</div><div class="line">make</div><div class="line">sudo make install</div></pre></td></tr></table></figure>
</li>
</ol>
<p>默认安装在/usr/local/nginx/</p>
<ol>
<li>编辑ECS Tengine配置文件<br>root权限打开/usr/local/nginx/conf/nginx.conf，增加一个server模块，监听本机的某个端口（比如8888），将所有请求转发到HPC的物理机，配置如下：<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="section">server</span> &#123;</div><div class="line">    <span class="attribute">listen</span>       <span class="number">8888</span>;</div><div class="line"><span class="comment">#    listen       somename:8080;</span></div><div class="line"><span class="comment">#    server_name  somename  alias  another.alias;</span></div><div class="line"></div><div class="line">    <span class="attribute">location</span> / &#123;</div><div class="line">        <span class="attribute">proxy_pass</span> http://10.172.68.130; <span class="comment">#10.172.68.130是HPC物理机的内网地址</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>这样之后在ECS下wget localhost:8888可以访问到jupyter notebook的index.html了。但是用ECS公网IP在本地浏览器上访问的时候发现连不上， 应该是防火墙的原因吧，把ECS的8888的端口打开（如果ECS连不上HPC的端口，估计也是防火墙的问题，因为我这里用的是80端口，所以没有报错）。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iptables -I INPUT -<span class="selector-tag">p</span> TCP --dport <span class="number">8888</span> -j ACCEPT</div></pre></td></tr></table></figure></p>
<p>AWS里的话是用安全组配置inbound rules，对于不熟悉iptables的用户要友好一些。现在可以在本地浏览器上访问jupyter notebook了。<br><img src="http://oml1i2pi6.bkt.clouddn.com/hpc-jupyter-notebook.png" alt="hpc jupyter notebook"></p>
<h1 id="some-tricks"><a href="#some-tricks" class="headerlink" title="some tricks"></a>some tricks</h1><ol>
<li><p>安装tmux</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum <span class="keyword">install</span> tmux</div></pre></td></tr></table></figure>
</li>
<li><p>安装htop</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-------------- For RHEL/CentOS 7 --------------</span></div><div class="line">wget http://dl.fedoraproject.org/pub/epel/7/x86_64/e/epel-<span class="keyword">release</span><span class="number">-7</span><span class="number">-9.</span>noarch.rpm</div><div class="line">rpm -ihv epel-<span class="keyword">release</span><span class="number">-7</span><span class="number">-9.</span>noarch.rpm </div><div class="line"></div><div class="line">yum <span class="keyword">install</span> htop</div></pre></td></tr></table></figure>
</li>
<li><p>加速下载数据集<br>话说在HPC上直接下载数据集有点慢（尤其是国外的），可以考虑开一台最低配置的普通ecs，不限制网速，在上面下载好datasets，然后再“内网”（阿里云不同区的服务器是不能内网互联的，比如hk的ecs就不能内网访问杭州的ecs，所以需要用公网ip，但是哪怕用公网ip，速度也是上百倍的差别， 3.4MB/s vs 24.2KB/s）同步到hpc上，如果是国外的datasets，可以开一台低配的相关ecs，0.165￥/时，价格差了200多倍啊。</p>
</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>经过几个小时的折腾， 我还没有配好可以正确使用gpu的HPC实例。后来看到这篇<a href="https://yq.aliyun.com/articles/68206" target="_blank" rel="external">在阿里云HPC和容器服务上，像梵高一样作画</a>，应该比较简单的， 只是目前必须用北京的HPC才可以这么方便的使用。而北京目前必须按月付费，9000￥/月，暂时我还用不起啊。所以还是先放弃HPC，用AWS吧。。。</p>
<h1 id="refers"><a href="#refers" class="headerlink" title="refers"></a>refers</h1><ul>
<li><a href="https://yq.aliyun.com/articles/66993?spm=5176.doc48632.2.5.V1yqJr" target="_blank" rel="external">https://yq.aliyun.com/articles/66993?spm=5176.doc48632.2.5.V1yqJr</a></li>
<li><a href="https://yq.aliyun.com/articles/64979?spm=5176.doc48632.2.6.V1yqJr" target="_blank" rel="external">https://yq.aliyun.com/articles/64979?spm=5176.doc48632.2.6.V1yqJr</a></li>
<li><a href="https://help.aliyun.com/document_detail/48632.html?spm=5176.doc52231.6.573.uqYEBN" target="_blank" rel="external">https://help.aliyun.com/document_detail/48632.html?spm=5176.doc52231.6.573.uqYEBN</a></li>
<li><a href="https://github.com/NVIDIA/nvidia-docker" target="_blank" rel="external">https://github.com/NVIDIA/nvidia-docker</a></li>
<li><a href="https://opskumu.gitbooks.io/docker/content/chapter5.html" target="_blank" rel="external">https://opskumu.gitbooks.io/docker/content/chapter5.html</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;深度学习没有GPU的支持可以说完全不能解决实际问题， 稍大一点的数据集可能就要几个小时，GPU能起到10倍以及更高的速度提升。之前我们做了&lt;a href=&quot;http://magicly.me/2017/04/15/aws-dl-config/&quot;&gt;AWS的深度学习配置&lt;/a&gt;，今天再看看国内阿里云的HPC配置。&lt;/p&gt;
    
    </summary>
    
      <category term="ML" scheme="http://magicly.me/categories/ML/"/>
    
    
      <category term="rnn" scheme="http://magicly.me/tags/rnn/"/>
    
      <category term="neural network" scheme="http://magicly.me/tags/neural-network/"/>
    
      <category term="dl" scheme="http://magicly.me/tags/dl/"/>
    
      <category term="ml" scheme="http://magicly.me/tags/ml/"/>
    
  </entry>
  
  <entry>
    <title>AWS深度学习配置</title>
    <link href="http://magicly.me/2017/04/15/aws-dl-config/"/>
    <id>http://magicly.me/2017/04/15/aws-dl-config/</id>
    <published>2017-04-15T00:24:24.000Z</published>
    <updated>2017-04-23T09:18:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>深度学习的流行跟计算能力的大大提高密不可分，尤其是GPU的大量使用，Nvidia去年股价涨了500%呢。用CPU要运行一个月的项目， 可能用GPU几个小时就运行完了，效率和速度不可同日耳语。工欲善其事必先利其器，所以正确地配置好GPU是进入深度学习的开端，而用AWS的GPU服务是最快捷方便的，本文就教你如何快速的配置好AWS的p2实例，提高深度学习效率。</p>
<a id="more"></a>
<h1 id="安装AWS-Instance"><a href="#安装AWS-Instance" class="headerlink" title="安装AWS Instance"></a>安装AWS Instance</h1><h2 id="Instance选择"><a href="#Instance选择" class="headerlink" title="Instance选择"></a>Instance选择</h2><p>AWS提供很多实例，有计算型的（CPU比较好）， 有内存型的（内存比较高），有高磁盘IO型的，也有适合用于深度学习的GPU型。具体不同型号的特点配置以及价格参见<a href="https://aws.amazon.com/ec2/pricing/on-demand/" target="_blank" rel="external">AWS Pricing</a>。</p>
<p>这里我们选择p2.xlarge，4核CPU，61G内存，一个Nvidia GPU（有2496个并行处理核，12G内存），具体信息可以看<a href="https://aws.amazon.com/blogs/aws/new-p2-instance-type-for-amazon-ec2-up-to-16-gpus/" target="_blank" rel="external">这里</a>。</p>
<p>当然p2.xlarge的价格(0.9$/h)当然比t2.xlarge的价格(0.188$/h)要高， 所以我的建议是，在本机或者t2上写好代码，找一个小一点的数据集跑一下， 调试得差不多了， 然后启动p2.xlarge，在全量数据集上run。这里说一下，如果数据集是国外的（大部分都是），aws下载能达到20MB/s，相比国内下载速度，真是爽得不要不要的。</p>
<h2 id="AMI选择"><a href="#AMI选择" class="headerlink" title="AMI选择"></a>AMI选择</h2><p>AWS Instance安装的时候支持选择镜像。还记得以前重装windows系统么， 装完之后需要安装各种驱动，输入法、qq、浏览器、word。。。blabla一堆软件，有可能几个小时就过去了。所以后来出了Ghost盘，安装好各种软件后，做个Ghost盘，然后以后重装的时候就只需要装Ghost盘，十分钟就可以装好，然后所有该要的软件都有了，大大节约了时间。AWS的镜像叫AMI。</p>
<p>社区已经有很多人制作了深度学习的AMI，我们也可以选择自己制作。用云服务要改变传统开发思维，要有”随要随开，用完即走“的思想。所以用aws的基本流程如下：</p>
<ol>
<li>选择一个基础的AMI</li>
<li>安装好Instance</li>
<li>安装各种需要的软件，比如python，numpy，matplot，tensorflow，keras，cuda等</li>
<li>在AWS管理控制台右键选中instance，点image，create image。然后就等着，几分钟就好了。</li>
<li>做相应的开发，写代码，下载数据集等blabla。。。</li>
<li>工作一段时间之后要休息了，制作新的AMI</li>
<li>释放instance</li>
<li>第二天来，新开instance，用5制作的AMI，继续上次的工作。</li>
</ol>
<p>这里推荐几个社区制作的深度学习相关的AMI，<a href="https://aws.amazon.com/marketplace/pp/B01M0AXXQB" target="_blank" rel="external">Deep Learning AMI Amazon Linux Version</a>, Deep Learning AMI Ubuntu Linux - 1.3_Apr2017 - ami-638c1e03, <a href="https://github.com/ritchieng/tensorflow-aws-ami" target="_blank" rel="external">TFAMI</a>。我因为最近在看<a href="http://course.fast.ai/" target="_blank" rel="external">Fast.ai</a>课程， 所以选择了课程对应的AMI。话说<a href="https://github.com/fastai/courses/tree/master/setup" target="_blank" rel="external">这个课程有完整的脚本</a>来创建、开启、连接、关闭AWS实例，很是方便， 大家可以看看。这是一个实战性很强的课程， 推荐一下。</p>
<h1 id="jupyter-notebook"><a href="#jupyter-notebook" class="headerlink" title="jupyter notebook"></a>jupyter notebook</h1><p>jupyter notebook的作用和好处以及基本的安装我就不多说了， 自行google吧。主要说一下要在AMS上配置jupyter notebook需要注意的事项。</p>
<ol>
<li>需要在AMS Instance的安全组里打开8888端口。</li>
<li>由于会在公网上访问，为了安全， 需要给jupyter notebook设置一个密码，方法如下：<figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">ubuntu@ip-<span class="number">10</span>-<span class="number">0</span>-<span class="number">0</span>-<span class="number">14</span>:~/nbs$ ipython</div><div class="line"><span class="keyword">In</span> [<span class="number">1</span>]: from IPython.lib <span class="keyword">import</span> passwd</div><div class="line"></div><div class="line"><span class="keyword">In</span> [<span class="number">2</span>]: passwd()</div><div class="line">Enter password:</div><div class="line"><span class="built_in">Verify</span> password:</div><div class="line"><span class="keyword">Out</span>[<span class="number">2</span>]: <span class="string">'sha1:XXXXXXXXXXXXXXX'</span></div><div class="line"></div><div class="line"><span class="keyword">In</span> [<span class="number">3</span>]: <span class="keyword">exit</span></div></pre></td></tr></table></figure>
</li>
</ol>
<p>将上诉生成的密码copy到~/.jupyter/jupyter_notebook_config.py（如果没有此文件， 先运行jupyter notebook –generate-config）里:<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">vim ~<span class="regexp">/.jupyter/</span>jupyter_notebook_config.py</div><div class="line">c.NotebookApp.password = <span class="string">u'sha1:XXXXXXXXXXXXXX'</span></div><div class="line">c.NotebookApp.ip = <span class="string">'*'</span> <span class="comment">#如果没有这行，会只监听localhost:8888，外网无法访问</span></div></pre></td></tr></table></figure></p>
<p>然后就可以在浏览器里输入<a href="http://[ip]:8888访问jupyter" target="_blank" rel="external">http://[ip]:8888访问jupyter</a> notebook，开心地开始写代码吧。</p>
<p>数据存放位置<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ubuntu<span class="variable">@ip</span>-<span class="number">10</span>-<span class="number">0</span>-<span class="number">0</span>-<span class="number">14</span><span class="symbol">:~/courses/deeplearning1/nbs</span><span class="variable">$ </span>find ~ -name vgg16.h5</div><div class="line">/home/ubuntu/.keras/models/vgg16.h5</div></pre></td></tr></table></figure></p>
<h1 id="竞价实例"><a href="#竞价实例" class="headerlink" title="竞价实例"></a>竞价实例</h1><p>竞价实例是一种特殊的实例，能够以超低的价格提供配置一样的实例，和普通实例的差别在于不可停止，因此当你想跑比较大的网络的时候（训练时间大于1小时），用竞价实例会非常划算。0.9美元每小时的 p2.xlarge 在竞价实例一个月的历史记录里很少超过0.3美元。即使超过了，也不会出高于0.9美元的价格。</p>
<h1 id="选择哪个区的AWS"><a href="#选择哪个区的AWS" class="headerlink" title="选择哪个区的AWS"></a>选择哪个区的AWS</h1><p>这个建议看看自己的网络环境下，连哪个区的速度快。用<a href="http://www.cloudping.info/" target="_blank" rel="external">CloudPing.info</a>测试一下就可以，貌似国内访问美西要快点，我的网络好的情况下ping值能在200ms，差的时候500ms+。</p>
<h1 id="推荐几个软件"><a href="#推荐几个软件" class="headerlink" title="推荐几个软件"></a>推荐几个软件</h1><h2 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h2><p>可以在一个ssh连接里面同时开启多个窗口，比如一个启动jupyter notebook，一个打开htop，一个执行正常的命令。并且用Ctrl + B d离开tmux后， 下次再进来（哪怕是重新ssh登录），直接用tmux attach可以回到上次的回话，相当方便。</p>
<h2 id="htop"><a href="#htop" class="headerlink" title="htop"></a>htop</h2><p>监控内存、CPU占用等。</p>
<h2 id="screen"><a href="#screen" class="headerlink" title="screen"></a>screen</h2><p>避免离开ssh后jupyter notebook挂掉。</p>
<h1 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h1><ul>
<li>用fast.ai课程提供的脚本创建Instance的话，再次安装的时候报错<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">An</span> <span class="selector-tag">error</span> <span class="selector-tag">occurred</span> (InvalidKeyPair.NotFound) <span class="keyword">when</span> calling the RunInstances <span class="attribute">operation</span>: The key pair <span class="string">'aws-key-fast-ai'</span> does <span class="keyword">not</span> exist</div></pre></td></tr></table></figure>
</li>
</ul>
<p>尝试着把~/.ssh/aws-key-fast-ai.pem删除后好了。</p>
<p>要想做深度学习，GPU简直是必须的。举个例子， 我在t2.xlarge上用VGG16跑<a href="https://www.kaggle.com/c/dogs-vs-cats-redux-kernels-edition" target="_blank" rel="external">kaggle dogs vs cats比赛</a>，要花一个多小时，而用p2.xlarge，只需要600多s，速度提升了10倍啊！上次听AWS技术分享会，他们提到，云服务重新定义了一个公式1 * 1000 === 1000 * 1，是说你用1台服务器跑1000个小时所花的费用，跟1000台服务器跑1小时的费用是一样的，但这样几乎把效率提升了1000倍啊！这在没有云的时代，谁敢想象随随便便调用1000台服务器呢。</p>
<p>另外国内的阿里云也有针对深度学习的配置，叫<a href="https://www.aliyun.com/product/hpc?spm=5176.8142029.388261.36.6n7Ioo" target="_blank" rel="external">HPC</a>，后面也会再写篇关于阿里云HPC的配置。</p>
<h1 id="refers"><a href="#refers" class="headerlink" title="refers"></a>refers</h1><ul>
<li><a href="http://www.jiqizhixin.com/article/2608" target="_blank" rel="external">http://www.jiqizhixin.com/article/2608</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/25066187" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/25066187</a></li>
<li><a href="http://www.cnblogs.com/meelo/p/5994505.html" target="_blank" rel="external">http://www.cnblogs.com/meelo/p/5994505.html</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;深度学习的流行跟计算能力的大大提高密不可分，尤其是GPU的大量使用，Nvidia去年股价涨了500%呢。用CPU要运行一个月的项目， 可能用GPU几个小时就运行完了，效率和速度不可同日耳语。工欲善其事必先利其器，所以正确地配置好GPU是进入深度学习的开端，而用AWS的GPU服务是最快捷方便的，本文就教你如何快速的配置好AWS的p2实例，提高深度学习效率。&lt;/p&gt;
    
    </summary>
    
      <category term="ML" scheme="http://magicly.me/categories/ML/"/>
    
    
      <category term="rnn" scheme="http://magicly.me/tags/rnn/"/>
    
      <category term="neural network" scheme="http://magicly.me/tags/neural-network/"/>
    
      <category term="dl" scheme="http://magicly.me/tags/dl/"/>
    
      <category term="ml" scheme="http://magicly.me/tags/ml/"/>
    
  </entry>
  
  <entry>
    <title>用LSTM生成武侠人名</title>
    <link href="http://magicly.me/2017/04/07/rnn-lstm-generate-name/"/>
    <id>http://magicly.me/2017/04/07/rnn-lstm-generate-name/</id>
    <published>2017-04-07T07:42:58.000Z</published>
    <updated>2017-04-07T10:20:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前翻译了<a href="http://magicly.me/2017/03/09/iamtrask-anyone-can-code-lstm/">一篇介绍RNN的文章</a>，一直没看到<a href="https://twitter.com/iamtrask" target="_blank" rel="external">作者</a>写新的介绍LSTM的blog，于是我又找了其他资料学习。本文先介绍一下LSTM，然后用LSTM在金庸、古龙的人名上做了训练，可以生成新的武侠名字，如果有兴趣的，还可以多搜集点人名，用于给小孩儿取名呢，哈哈，justforfun，大家玩得开心…</p>
<a id="more"></a>
<h1 id="RNN回顾"><a href="#RNN回顾" class="headerlink" title="RNN回顾"></a>RNN回顾</h1><p>RNN的出现是为了解决状态记忆的问题，解决方法很简单，每一个时间点t的隐藏状态h(t)不再简单地依赖于数据，还依赖于前一个时间节点t-1的隐藏状态h(t-1)。可以看出这是一种递归定义（所以循环神经网络又叫递归神经网络Recursive Neural Network），h(t-1)又依赖于h(t-2)，h(t-2)依赖于h(t-3)…所以h(t)依赖于之前每一个时间点的输入，也就是说h(t)记住了之前所有的输入。<br><img src="http://colah.github.io/posts/2015-08-Understanding-LSTMs/img/RNN-rolled.png" alt="rnn"><br>上图如果按时间展开，就可以看出RNN其实也就是普通神经网络在时间上的堆叠。<br><img src="http://colah.github.io/posts/2015-08-Understanding-LSTMs/img/RNN-unrolled.png" alt="rnn-unrolled"></p>
<h1 id="RNN问题：Long-Term-Dependencies"><a href="#RNN问题：Long-Term-Dependencies" class="headerlink" title="RNN问题：Long-Term Dependencies"></a>RNN问题：Long-Term Dependencies</h1><p>一切似乎很完美，但是如果h(t)依赖于h(t - 1000)，依赖路径特别长，会导致计算梯度的时候出现梯度消失的问题，训练时间很长根本没法实际使用。下面是一个依赖路径很长的例子：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">我老家【成都】的。。。【此处省去<span class="number">500</span>字】。。。我们那里经常吃【火锅】。。。</div></pre></td></tr></table></figure></p>
<h1 id="LSTM"><a href="#LSTM" class="headerlink" title="LSTM"></a>LSTM</h1><p>Long Short Term Memory神经网络，也就是LSTM，由<a href="http://deeplearning.cs.cmu.edu/pdfs/Hochreiter97_lstm.pdf" target="_blank" rel="external"> Hochreiter &amp; Schmidhuber于1997年发表</a>。它的出现就是为了解决Long-Term Dependencies的问题，很来出现了很多改进版本，目前应用在相当多的领域（包括机器翻译、对话机器人、语音识别、Image Caption等）。</p>
<p>标准的RNN里，重复的模块里只是一个很简单的结构，如下图：<br><img src="http://colah.github.io/posts/2015-08-Understanding-LSTMs/img/LSTM3-SimpleRNN.png" alt="rnn structure"></p>
<p>LSTM也是类似的链表结构，不过它的内部构造要复杂得多：<br><img src="http://colah.github.io/posts/2015-08-Understanding-LSTMs/img/LSTM3-chain.png" alt="lstm structure"><br>上图中的图标含义如下：<br><img src="http://colah.github.io/posts/2015-08-Understanding-LSTMs/img/LSTM2-notation.png" alt="lstm components"></p>
<p>LSTM的核心思想是cell state（类似于hidden state，有LSTM变种把cell state和hidden state合并了， 比如GRU）和三种门：输入门、忘记门、输出门。</p>
<p>cell state每次作为输入传递到下一个时间点，经过一些线性变化后继续传往再下一个时间点（我还没看过<a href="http://deeplearning.cs.cmu.edu/pdfs/Hochreiter97_lstm.pdf" target="_blank" rel="external">原始论文</a>，不知道为啥有了hidden state后还要cell state，好在确实有改良版将两者合并了，所以暂时不去深究了）。<br><img src="http://colah.github.io/posts/2015-08-Understanding-LSTMs/img/LSTM3-C-line.png" alt="cell state"></p>
<p>门的概念来自于电路设计（我没学过，就不敢卖弄了）。LSTM里，门控制通过门之后信息能留下多少。如下图，sigmoid层输出[0, 1]的值，决定多少数据可以穿过门， 0表示谁都过不了，1表示全部通过。<br><img src="http://colah.github.io/posts/2015-08-Understanding-LSTMs/img/LSTM3-gate.png" alt="gate"></p>
<p>下面我们来看看每个“门”到底在干什么。</p>
<p>首先我们要决定之前的cell state需要保留多少。 它根据h(t-1)和x(t)计算出一个[0, 1]的数，决定cell state保留多少，0表示全部丢弃，1表示全部保留。为什么要丢弃呢，不是保留得越多越好么？假设LSTM在生成文章，里面有小明和小红，小明在看电视，小红在厨房做饭。如果当前的主语是小明， ok，那LSTM应该输出看电视相关的，比如找遥控器啊， 换台啊，如果主语已经切换到小红了， 那么接下来最好暂时把电视机忘掉，而输出洗菜、酱油、电饭煲等。<br><img src="http://colah.github.io/posts/2015-08-Understanding-LSTMs/img/LSTM3-focus-f.png" alt="forget gate"></p>
<p>第二步就是决定输入多大程度上影响cell state。这个地方由两部分构成， 一个用sigmoid函数计算出有多少数据留下，一个用tanh函数计算出一个候选C(t)。 这个地方就好比是主语从小明切换到小红了， 电视机就应该切换到厨房。<br><img src="http://colah.github.io/posts/2015-08-Understanding-LSTMs/img/LSTM3-focus-i.png" alt="input gate"></p>
<p>然后我们把留下来的（t-1时刻的）cell state和新增加的合并起来，就得到了t时刻的cell state。<br><img src="http://colah.github.io/posts/2015-08-Understanding-LSTMs/img/LSTM3-focus-C.png" alt="combine to cell state"></p>
<p>最后我们把cell state经过tanh压缩到[-1, 1]，然后输送给输出门（[0, 1]决定输出多少东西）。<br><img src="http://colah.github.io/posts/2015-08-Understanding-LSTMs/img/LSTM3-focus-o.png" alt="output"></p>
<p>现在也出了很多LSTM的变种， 有兴趣的可以看<a href="http://colah.github.io/posts/2015-08-Understanding-LSTMs/" target="_blank" rel="external">这里</a>。另外，LSTM只是为了解决RNN的long-term dependencies，也有人从另外的角度来解决的，比如<a href="http://arxiv.org/pdf/1402.3511v1.pdf" target="_blank" rel="external">Clockwork RNNs by Koutnik, et al. (2014).</a></p>
<h1 id="show-me-the-code"><a href="#show-me-the-code" class="headerlink" title="show me the code!"></a>show me the code!</h1><p>我用的<a href="http://karpathy.github.io/2015/05/21/rnn-effectiveness/" target="_blank" rel="external">Andrej Karpathy大神</a>的代码， 做了些小改动。这个代码的好处是不依赖于任何深度学习框架，只需要有numpy就可以马上run起来！<br><script src="//gist.github.com/magicly/df9e5806fbd44ed5ec73dce9444afb30.js"></script></p>
<p>然后从网上找了<a href="http://www.oocities.org/sg/ye_feng_dengmi/h/hucai6-02.htm" target="_blank" rel="external">金庸小说的人名</a>，做了些预处理，每行一个名字，保存到input.txt里，运行代码就可以了。古龙的没有找到比较全的名字， 只有这份<a href="https://tieba.baidu.com/p/1559430344" target="_blank" rel="external">武功排行榜</a>，只有100多人。</p>
<p>下面是根据两份名单训练的结果，已经将完全一致的名字（比如段誉）去除了，所以下面的都是LSTM“新创作发明”的名字哈。来， 大家猜猜哪一个结果是金庸的， 哪一个是古龙的呢？<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="string">'姜曾铁'</span>, <span class="string">'袁南兰'</span>, <span class="string">'石万奉'</span>, <span class="string">'郭万嗔'</span>, <span class="string">'蔡家'</span>, <span class="string">'程伯芷'</span>, <span class="string">'汪铁志'</span>, <span class="string">'陈衣'</span>, <span class="string">'薛铁'</span>, </div><div class="line"><span class="string">'哈赤蔡师'</span>, <span class="string">'殷飞虹'</span>, <span class="string">'钟小砚'</span>, <span class="string">'凤一刀'</span>, <span class="string">'宝兰'</span>, <span class="string">'齐飞虹'</span>, <span class="string">'无若之'</span>, <span class="string">'王老英'</span>, <span class="string">'钟'</span>, </div><div class="line"><span class="string">'钟百胜'</span>, <span class="string">'师'</span>, <span class="string">'李沅震'</span>, <span class="string">'曹兰'</span>, <span class="string">'赵一刀'</span>, <span class="string">'钟灵四'</span>, <span class="string">'宗家妹'</span>, <span class="string">'崔树胜'</span>, <span class="string">'桑飞西'</span>, </div><div class="line"><span class="string">'上官公希轰'</span>, <span class="string">'刘之余人童怀道'</span>, <span class="string">'周云鹤'</span>, <span class="string">'天'</span>, <span class="string">'凤'</span>, <span class="string">'西灵素'</span>, <span class="string">'大智虎师'</span>, <span class="string">'阮徒忠'</span>, </div><div class="line"><span class="string">'王兆能'</span>, <span class="string">'袁铮衣商宝鹤'</span>, <span class="string">'常伯凤'</span>, <span class="string">'苗人大'</span>, <span class="string">'倪不凤'</span>, <span class="string">'蔡铁'</span>, <span class="string">'无伯志'</span>, <span class="string">'凤一弼'</span>, </div><div class="line"><span class="string">'曹鹊'</span>, <span class="string">'黄宾'</span>, <span class="string">'曾铁文'</span>, <span class="string">'姬胡峰'</span>, <span class="string">'李何豹'</span>, <span class="string">'上官铁'</span>, <span class="string">'童灵同'</span>, <span class="string">'古若之'</span>, <span class="string">'慕官景岳'</span>, </div><div class="line"><span class="string">'崔百真'</span>, <span class="string">'陈官'</span>, <span class="string">'陈钟'</span>, <span class="string">'倪调峰'</span>, <span class="string">'妹沅刀'</span>, <span class="string">'徐双英'</span>, <span class="string">'任通督'</span>, <span class="string">'上官铁褚容'</span>, <span class="string">'大剑太'</span>, </div><div class="line"><span class="string">'胡阳'</span>, <span class="string">'生'</span>, <span class="string">'南仁郑'</span>, <span class="string">'南调'</span>, <span class="string">'石双震'</span>, <span class="string">'海铁山'</span>, <span class="string">'殷鹤真'</span>, <span class="string">'司鱼督'</span>, <span class="string">'德小'</span>, </div><div class="line"><span class="string">'若四'</span>, <span class="string">'武通涛'</span>, <span class="string">'田青农'</span>, <span class="string">'常尘英'</span>, <span class="string">'常不志'</span>, <span class="string">'倪不涛'</span>, <span class="string">'欧阳'</span>, <span class="string">'大提督'</span>, <span class="string">'胡玉堂'</span>, </div><div class="line"><span class="string">'陈宝鹤'</span>, <span class="string">'南仁通四蒋赫侯'</span>&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="string">'邀三'</span>, <span class="string">'熊猫开'</span>, <span class="string">'鹰星'</span>, <span class="string">'陆开'</span>, <span class="string">'花'</span>, <span class="string">'薛玉罗平'</span>, <span class="string">'南宫主'</span>, <span class="string">'南宫九'</span>, <span class="string">'孙夫人'</span>,</div><div class="line"><span class="string">'荆董灭'</span>, <span class="string">'铁不愁'</span>, <span class="string">'裴独'</span>, <span class="string">'玮剑'</span>, <span class="string">'人'</span>, <span class="string">'陆小龙王紫无牙'</span>, <span class="string">'连千里'</span>, <span class="string">'仲先生'</span>, </div><div class="line"><span class="string">'俞白'</span>, <span class="string">'方大'</span>, <span class="string">'叶雷一魂'</span>, <span class="string">'独孤上红'</span>, <span class="string">'叶怜花'</span>, <span class="string">'雷大归'</span>, <span class="string">'恕飞'</span>, <span class="string">'白双发'</span>, </div><div class="line"><span class="string">'邀一郎'</span>, <span class="string">'东楼'</span>, <span class="string">'铁中十一点红'</span>, <span class="string">'凤星真'</span>, <span class="string">'无魏柳老凤三'</span>, <span class="string">'萧猫儿'</span>, <span class="string">'东郭先凤'</span>, </div><div class="line"><span class="string">'日孙'</span>, <span class="string">'地先生'</span>, <span class="string">'孟摘星'</span>, <span class="string">'江小小凤'</span>, <span class="string">'花双楼'</span>, <span class="string">'李佩'</span>, <span class="string">'仇珏'</span>, <span class="string">'白坏刹'</span>, <span class="string">'燕悲情'</span>, </div><div class="line"><span class="string">'姬悲雁'</span>, <span class="string">'东郭大'</span>, <span class="string">'谢晓陆凤'</span>, <span class="string">'碧玉伯'</span>, <span class="string">'司实三'</span>, <span class="string">'陆浪'</span>, <span class="string">'赵布雁'</span>, <span class="string">'荆孤蓝'</span>, </div><div class="line"><span class="string">'怜燕南天'</span>, <span class="string">'萧怜静'</span>, <span class="string">'龙布雁'</span>, <span class="string">'东郭鱼'</span>, <span class="string">'司东郭金天'</span>, <span class="string">'薛啸天'</span>, <span class="string">'熊宝玉'</span>, <span class="string">'无莫静'</span>,</div><div class="line"><span class="string">'柳罗李'</span>, <span class="string">'东官小鱼'</span>, <span class="string">'渐飞'</span>, <span class="string">'陆地鱼'</span>, <span class="string">'阿吹王'</span>, <span class="string">'高傲'</span>, <span class="string">'萧十三'</span>, <span class="string">'龙童'</span>, <span class="string">'玉罗赵'</span>, </div><div class="line"><span class="string">'谢郎唐傲'</span>, <span class="string">'铁夜帝'</span>, <span class="string">'江小凤'</span>, <span class="string">'孙玉玉夜'</span>, <span class="string">'仇仲忍'</span>, <span class="string">'萧地孙'</span>, <span class="string">'铁莫棠'</span>, <span class="string">'柴星夫'</span>, </div><div class="line"><span class="string">'展夫人'</span>, <span class="string">'碧玉'</span>, <span class="string">'老无鱼'</span>, <span class="string">'铁铁花'</span>, <span class="string">'独'</span>, <span class="string">'薛月宫九'</span>, <span class="string">'老郭和尚'</span>, <span class="string">'东郭大路陆上龙关飞'</span>, </div><div class="line"><span class="string">'司藏'</span>, <span class="string">'李千'</span>, <span class="string">'孙白人'</span>, <span class="string">'南双平'</span>, <span class="string">'王玮'</span>, <span class="string">'姬原情'</span>, <span class="string">'东郭大路孙玉'</span>, <span class="string">'白玉罗生'</span>, <span class="string">'高儿'</span>, </div><div class="line"><span class="string">'东珏天'</span>, <span class="string">'萧王尚'</span>, <span class="string">'九'</span>, <span class="string">'凤三静'</span>, <span class="string">'和空摘星'</span>, <span class="string">'关吹雪'</span>, <span class="string">'上官官小凤'</span>, <span class="string">'仇上官金飞'</span>, </div><div class="line"><span class="string">'陆上龙啸天'</span>, <span class="string">'司空星魂'</span>, <span class="string">'邀衣人'</span>, <span class="string">'主'</span>, <span class="string">'李寻欢天'</span>, <span class="string">'东情'</span>, <span class="string">'玉夫随'</span>, <span class="string">'赵小凤'</span>, <span class="string">'东郭灭'</span>, <span class="string">'邀祟厚'</span>, <span class="string">'司空星'</span>&#125;</div></pre></td></tr></table></figure>
<p>感兴趣的还可以用古代诗人、词人等的名字来做训练，大家机器好或者有时间的可以多训练下，训练得越多越准确。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>RNN由于具有记忆功能，在NLP、Speech、Computer Vision等诸多领域都展示了强大的力量。实际上，RNN是<a href="http://binds.cs.umass.edu/papers/1995_Siegelmann_Science.pdf" target="_blank" rel="external">图灵等价的</a>。<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">If training vanilla neural nets <span class="keyword">is</span> optimization <span class="keyword">over</span> functions, training recurrent nets <span class="keyword">is</span> optimization <span class="keyword">over</span> programs.</div></pre></td></tr></table></figure></p>
<p>LSTM是一种目前相当常用和实用的RNN算法，主要解决了RNN的long-term dependencies问题。另外RNN也一直在产生新的研究，比如Attention机制。有空再介绍咯。。。</p>
<h1 id="Refers"><a href="#Refers" class="headerlink" title="Refers"></a>Refers</h1><ul>
<li><a href="http://colah.github.io/posts/2015-08-Understanding-LSTMs/" target="_blank" rel="external">http://colah.github.io/posts/2015-08-Understanding-LSTMs/</a></li>
<li><a href="http://karpathy.github.io/2015/05/21/rnn-effectiveness/" target="_blank" rel="external">http://karpathy.github.io/2015/05/21/rnn-effectiveness/</a></li>
<li><a href="https://www.zhihu.com/question/29411132" target="_blank" rel="external">https://www.zhihu.com/question/29411132</a></li>
<li><a href="https://gist.github.com/karpathy/d4dee566867f8291f086" target="_blank" rel="external">https://gist.github.com/karpathy/d4dee566867f8291f086</a></li>
<li><a href="https://deeplearning4j.org/lstm.html" target="_blank" rel="external">https://deeplearning4j.org/lstm.html</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前翻译了&lt;a href=&quot;http://magicly.me/2017/03/09/iamtrask-anyone-can-code-lstm/&quot;&gt;一篇介绍RNN的文章&lt;/a&gt;，一直没看到&lt;a href=&quot;https://twitter.com/iamtrask&quot;&gt;作者&lt;/a&gt;写新的介绍LSTM的blog，于是我又找了其他资料学习。本文先介绍一下LSTM，然后用LSTM在金庸、古龙的人名上做了训练，可以生成新的武侠名字，如果有兴趣的，还可以多搜集点人名，用于给小孩儿取名呢，哈哈，justforfun，大家玩得开心…&lt;/p&gt;
    
    </summary>
    
      <category term="ML" scheme="http://magicly.me/categories/ML/"/>
    
    
      <category term="rnn" scheme="http://magicly.me/tags/rnn/"/>
    
      <category term="neural network" scheme="http://magicly.me/tags/neural-network/"/>
    
      <category term="dl" scheme="http://magicly.me/tags/dl/"/>
    
      <category term="ml" scheme="http://magicly.me/tags/ml/"/>
    
  </entry>
  
  <entry>
    <title>udacity课程ud730深度学习学习笔记</title>
    <link href="http://magicly.me/2017/03/31/udacity-ud730-notes/"/>
    <id>http://magicly.me/2017/03/31/udacity-ud730-notes/</id>
    <published>2017-03-31T01:48:11.000Z</published>
    <updated>2017-03-31T02:08:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看Udacity的<a href="https://classroom.udacity.com/courses/ud730/" target="_blank" rel="external">ud730课程</a>，号称是tensorflow官方宣传片哈哈，因为用到的代码直接在<a href="https://github.com/tensorflow/tensorflow/tree/master/tensorflow/examples/udacity" target="_blank" rel="external">tensorflow的代码里面</a>。</p>
<p>课程主要包括四大部分：</p>
<ul>
<li>机器学习的基本概念</li>
<li>深度神经网络</li>
<li>卷积神经网络</li>
<li>循环神经网络</li>
</ul>
<a id="more"></a>
<h1 id="机器学习基本概念"><a href="#机器学习基本概念" class="headerlink" title="机器学习基本概念"></a>机器学习基本概念</h1><ul>
<li>softmax</li>
<li>cross-entropy</li>
<li>overfitting &amp; regularization</li>
<li>train / validate / test dataset的用途</li>
<li>SGD，随机梯度下降算法</li>
<li>Momentum &amp; learning rate decay，动量法和学习率调节下降</li>
<li>Hyper-parameter，超参数空间</li>
</ul>
<h1 id="深度神经网络"><a href="#深度神经网络" class="headerlink" title="深度神经网络"></a>深度神经网络</h1><ul>
<li>线性模型的局限</li>
<li>ReLu</li>
<li>Chain Rule， 链式法则</li>
<li>Back propagation，反向传播</li>
<li>Regularization，正则化</li>
<li>Dropout</li>
</ul>
<h1 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h1><ul>
<li>Statistical Invariants，统计不变性</li>
<li>Convolutional NN，Convnets，卷积网络<ul>
<li>feature map</li>
<li>stride</li>
<li>max pooling</li>
</ul>
</li>
<li></li>
</ul>
<h1 id="循环神经网络"><a href="#循环神经网络" class="headerlink" title="循环神经网络"></a>循环神经网络</h1><ul>
<li>Embeddings</li>
<li>word2vec</li>
<li>tSNE</li>
<li>RNN</li>
<li>梯度消失/爆炸</li>
<li>LSTM</li>
<li>Beam搜索</li>
</ul>
<p>课程总共有6个tasks，目前完成了3个， 代码在<a href="https://github.com/magicly/udacity-ud730" target="_blank" rel="external">github上</a>，后续会继续更新本文和代码， 欢迎有兴趣的关注。</p>
<p>To be continued…</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在看Udacity的&lt;a href=&quot;https://classroom.udacity.com/courses/ud730/&quot;&gt;ud730课程&lt;/a&gt;，号称是tensorflow官方宣传片哈哈，因为用到的代码直接在&lt;a href=&quot;https://github.com/tensorflow/tensorflow/tree/master/tensorflow/examples/udacity&quot;&gt;tensorflow的代码里面&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;课程主要包括四大部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;机器学习的基本概念&lt;/li&gt;
&lt;li&gt;深度神经网络&lt;/li&gt;
&lt;li&gt;卷积神经网络&lt;/li&gt;
&lt;li&gt;循环神经网络&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="ML" scheme="http://magicly.me/categories/ML/"/>
    
    
      <category term="rnn" scheme="http://magicly.me/tags/rnn/"/>
    
      <category term="ml" scheme="http://magicly.me/tags/ml/"/>
    
      <category term="AI" scheme="http://magicly.me/tags/AI/"/>
    
      <category term="udacity" scheme="http://magicly.me/tags/udacity/"/>
    
      <category term="tensorflow" scheme="http://magicly.me/tags/tensorflow/"/>
    
      <category term="cnn" scheme="http://magicly.me/tags/cnn/"/>
    
      <category term="lstm" scheme="http://magicly.me/tags/lstm/"/>
    
      <category term="word2vec" scheme="http://magicly.me/tags/word2vec/"/>
    
  </entry>
  
  <entry>
    <title>所有人都能学会用Python写出RNN-LSTM代码</title>
    <link href="http://magicly.me/2017/03/09/iamtrask-anyone-can-code-lstm/"/>
    <id>http://magicly.me/2017/03/09/iamtrask-anyone-can-code-lstm/</id>
    <published>2017-03-09T14:12:59.000Z</published>
    <updated>2017-03-10T05:28:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文翻译自<a href="https://twitter.com/iamtrask" target="_blank" rel="external">@iamtrask</a>的<a href="http://iamtrask.github.io/2015/11/15/anyone-can-code-lstm/" target="_blank" rel="external">Anyone Can Learn To Code an LSTM-RNN in Python (Part 1: RNN)</a>。本文作者已通过<a href="https://twitter.com/magicly007/with_replies" target="_blank" rel="external">twitter联系作者，获得授权</a>。</p>
<h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><p>我通过玩具代码一边学习一边调试能达到最好的学习效果。本文通过一个简单的python实现，教会你循环神经网络。</p>
<p>原文作者<a href="https://twitter.com/iamtrask" target="_blank" rel="external">@iamtrask</a>说他会在twitter上继续发布第二部分LSTM，敬请关注。</p>
<a id="more"></a>
<h1 id="废话少说，-给我看看代码"><a href="#废话少说，-给我看看代码" class="headerlink" title="废话少说， 给我看看代码"></a>废话少说， 给我看看代码</h1><figure class="highlight nix"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">import</span> copy, numpy as np</div><div class="line">np.random.seed(<span class="number">0</span>) <span class="comment">#固定随机数生成器的种子，便于得到固定的输出，【译者注：完全是为了方便调试用的]</span></div><div class="line"></div><div class="line"><span class="comment"># compute sigmoid nonlinearity</span></div><div class="line">def sigmoid(x): <span class="comment">#激活函数</span></div><div class="line">    <span class="attr">output</span> = <span class="number">1</span>/(<span class="number">1</span>+np.exp(-x))</div><div class="line">    return output</div><div class="line"></div><div class="line"><span class="comment"># convert output of sigmoid function to its derivative</span></div><div class="line">def sigmoid_output_to_derivative(output):<span class="comment">#激活函数的导数</span></div><div class="line">    return output*(<span class="number">1</span>-output)</div><div class="line"></div><div class="line"><span class="comment"># training dataset generation</span></div><div class="line"><span class="attr">int2binary</span> = &#123;&#125; <span class="comment">#整数到其二进制表示的映射</span></div><div class="line"><span class="attr">binary_dim</span> = <span class="number">8</span> <span class="comment">#暂时制作256以内的加法， 可以调大</span></div><div class="line"></div><div class="line"><span class="comment">## 以下5行代码计算0-256的二进制表示</span></div><div class="line"><span class="attr">largest_number</span> = pow(<span class="number">2</span>,binary_dim)</div><div class="line"><span class="attr">binary</span> = np.unpackbits(</div><div class="line">    np.array([range(largest_number)],<span class="attr">dtype=np.uint8).T,axis=1)</span></div><div class="line">for i <span class="keyword">in</span> range(largest_number):</div><div class="line">    int2binary[i] = binary[i]</div><div class="line"></div><div class="line"><span class="comment"># input variables</span></div><div class="line"><span class="attr">alpha</span> = <span class="number">0.1</span> <span class="comment">#学习速率</span></div><div class="line"><span class="attr">input_dim</span> = <span class="number">2</span> <span class="comment">#因为我们是做两个数相加，每次会喂给神经网络两个bit，所以输入的维度是2</span></div><div class="line"><span class="attr">hidden_dim</span> = <span class="number">16</span> <span class="comment">#隐藏层的神经元节点数，远比理论值要大（译者注：理论上而言，应该一个节点就可以记住有无进位了，但我试了发现4的时候都没法收敛），你可以自己调整这个数，看看调大了是容易更快地收敛还是更慢</span></div><div class="line"><span class="attr">output_dim</span> = <span class="number">1</span> <span class="comment">#我们的输出是一个数，所以维度为1</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># initialize neural network weights</span></div><div class="line"><span class="attr">synapse_0</span> = <span class="number">2</span>*np.random.random((input_dim,hidden_dim)) - <span class="number">1</span> <span class="comment">#输入层到隐藏层的转化矩阵，维度为2*16， 2是输入维度，16是隐藏层维度</span></div><div class="line"><span class="attr">synapse_1</span> = <span class="number">2</span>*np.random.random((hidden_dim,output_dim)) - <span class="number">1</span></div><div class="line"><span class="attr">synapse_h</span> = <span class="number">2</span>*np.random.random((hidden_dim,hidden_dim)) - <span class="number">1</span></div><div class="line"><span class="comment"># 译者注：np.random.random产生的是[0,1)的随机数，2 * [0, 1) - 1 =&gt; [-1, 1)，</span></div><div class="line"><span class="comment"># 是为了有正有负更快地收敛，这涉及到如何初始化参数的问题，通常来说都是靠“经验”或者说“启发式规则”，说得直白一点就是“蒙的”！机器学习里面，超参数的选择，大部分都是这种情况，哈哈。。。</span></div><div class="line"><span class="comment"># 我自己试了一下用【0, 2)之间的随机数，貌似不能收敛，用[0,1)就可以，呵呵。。。</span></div><div class="line"></div><div class="line"><span class="comment"># 以下三个分别对应三个矩阵的变化</span></div><div class="line"><span class="attr">synapse_0_update</span> = np.zeros_like(synapse_0)</div><div class="line"><span class="attr">synapse_1_update</span> = np.zeros_like(synapse_1)</div><div class="line"><span class="attr">synapse_h_update</span> = np.zeros_like(synapse_h)</div><div class="line"></div><div class="line"><span class="comment"># training logic</span></div><div class="line"><span class="comment"># 学习10000个例子</span></div><div class="line">for j <span class="keyword">in</span> range(<span class="number">100000</span>):</div><div class="line">    </div><div class="line">    <span class="comment"># 下面6行代码，随机产生两个0-128的数字，并查出他们的二进制表示。为了避免相加之和超过256，这里选择两个0-128的数字</span></div><div class="line">    <span class="comment"># generate a simple addition problem (a + b = c)</span></div><div class="line">    <span class="attr">a_int</span> = np.random.randint(largest_number/<span class="number">2</span>) <span class="comment"># int version</span></div><div class="line">    <span class="attr">a</span> = int2binary[a_int] <span class="comment"># binary encoding</span></div><div class="line"></div><div class="line">    <span class="attr">b_int</span> = np.random.randint(largest_number/<span class="number">2</span>) <span class="comment"># int version</span></div><div class="line">    <span class="attr">b</span> = int2binary[b_int] <span class="comment"># binary encoding</span></div><div class="line"></div><div class="line">    <span class="comment"># true answer</span></div><div class="line">    <span class="attr">c_int</span> = a_int + b_int</div><div class="line">    <span class="attr">c</span> = int2binary[c_int]</div><div class="line">    </div><div class="line">    <span class="comment"># where we'll store our best guess (binary encoded)</span></div><div class="line">    <span class="comment"># 存储神经网络的预测值</span></div><div class="line">    <span class="attr">d</span> = np.zeros_like(c)</div><div class="line"></div><div class="line">    <span class="attr">overallError</span> = <span class="number">0</span> <span class="comment">#每次把总误差清零</span></div><div class="line">    </div><div class="line">    <span class="attr">layer_2_deltas</span> = list() <span class="comment">#存储每个时间点输出层的误差</span></div><div class="line">    <span class="attr">layer_1_values</span> = list() <span class="comment">#存储每个时间点隐藏层的值</span></div><div class="line">    layer_1_values.append(np.zeros(hidden_dim)) <span class="comment">#一开始没有隐藏层，所以里面都是0</span></div><div class="line">    </div><div class="line">    <span class="comment"># moving along the positions in the binary encoding</span></div><div class="line">    for position <span class="keyword">in</span> range(binary_dim):<span class="comment">#循环遍历每一个二进制位</span></div><div class="line">        </div><div class="line">        <span class="comment"># generate input and output</span></div><div class="line">        <span class="attr">X</span> = np.array([[a[binary_dim - position - <span class="number">1</span>],b[binary_dim - position - <span class="number">1</span>]]])<span class="comment">#从右到左，每次去两个输入数字的一个bit位</span></div><div class="line">        <span class="attr">y</span> = np.array([[c[binary_dim - position - <span class="number">1</span>]]]).T<span class="comment">#正确答案</span></div><div class="line"></div><div class="line">        <span class="comment"># hidden layer (input ~+ prev_hidden)</span></div><div class="line">        <span class="attr">layer_1</span> = sigmoid(np.dot(X,synapse_0) + np.dot(layer_1_values[-<span class="number">1</span>],synapse_h))<span class="comment">#（输入层 + 之前的隐藏层） -&gt; 新的隐藏层，这是体现循环神经网络的最核心的地方！！！</span></div><div class="line"></div><div class="line">        <span class="comment"># output layer (new binary representation)</span></div><div class="line">        <span class="attr">layer_2</span> = sigmoid(np.dot(layer_1,synapse_1)) <span class="comment">#隐藏层 * 隐藏层到输出层的转化矩阵synapse_1 -&gt; 输出层</span></div><div class="line"></div><div class="line">        <span class="comment"># did we miss?... if so, by how much?</span></div><div class="line">        <span class="attr">layer_2_error</span> = y - layer_2 <span class="comment">#预测误差是多少</span></div><div class="line">        layer_2_deltas.append((layer_2_error)*sigmoid_output_to_derivative(layer_2)) <span class="comment">#我们把每一个时间点的误差导数都记录下来</span></div><div class="line">        overallError += np.abs(layer_2_error[<span class="number">0</span>])<span class="comment">#总误差</span></div><div class="line">    </div><div class="line">        <span class="comment"># decode estimate so we can print it out</span></div><div class="line">        d[binary_dim - position - <span class="number">1</span>] = np.round(layer_2[<span class="number">0</span>][<span class="number">0</span>]) <span class="comment">#记录下每一个预测bit位</span></div><div class="line">        </div><div class="line">        <span class="comment"># store hidden layer so we can use it in the next timestep</span></div><div class="line">        layer_1_values.append(copy.deepcopy(layer_1))<span class="comment">#记录下隐藏层的值，在下一个时间点用</span></div><div class="line">    </div><div class="line">    <span class="attr">future_layer_1_delta</span> = np.zeros(hidden_dim)</div><div class="line">    </div><div class="line">    <span class="comment">#前面代码我们完成了所有时间点的正向传播以及计算最后一层的误差，现在我们要做的是反向传播，从最后一个时间点到第一个时间点</span></div><div class="line">    for position <span class="keyword">in</span> range(binary_dim):</div><div class="line">        </div><div class="line">        <span class="attr">X</span> = np.array([[a[position],b[position]]]) <span class="comment">#最后一次的两个输入</span></div><div class="line">        <span class="attr">layer_1</span> = layer_1_values[-position-<span class="number">1</span>] <span class="comment">#当前时间点的隐藏层</span></div><div class="line">        <span class="attr">prev_layer_1</span> = layer_1_values[-position-<span class="number">2</span>] <span class="comment">#前一个时间点的隐藏层</span></div><div class="line">        </div><div class="line">        <span class="comment"># error at output layer</span></div><div class="line">        <span class="attr">layer_2_delta</span> = layer_2_deltas[-position-<span class="number">1</span>] <span class="comment">#当前时间点输出层导数</span></div><div class="line">        <span class="comment"># error at hidden layer</span></div><div class="line">        <span class="comment"># 通过后一个时间点（因为是反向传播）的隐藏层误差和当前时间点的输出层误差，计算当前时间点的隐藏层误差</span></div><div class="line">        <span class="attr">layer_1_delta</span> = (future_layer_1_delta.dot(synapse_h.T) + layer_2_delta.dot(synapse_1.T)) * sigmoid_output_to_derivative(layer_1)</div><div class="line"></div><div class="line">        <span class="comment"># let's update all our weights so we can try again</span></div><div class="line">        <span class="comment"># 我们已经完成了当前时间点的反向传播误差计算， 可以构建更新矩阵了。但是我们并不会现在就更新权重矩阵，因为我们还要用他们计算前一个时间点的更新矩阵呢。</span></div><div class="line">        <span class="comment"># 所以要等到我们完成了所有反向传播误差计算， 才会真正的去更新权重矩阵，我们暂时把更新矩阵存起来。</span></div><div class="line">        <span class="comment"># 可以看这里了解更多关于反向传播的知识http://iamtrask.github.io/2015/07/12/basic-python-network/</span></div><div class="line">        synapse_1_update += np.atleast_2d(layer_1).T.dot(layer_2_delta)</div><div class="line">        synapse_h_update += np.atleast_2d(prev_layer_1).T.dot(layer_1_delta)</div><div class="line">        synapse_0_update += X.T.dot(layer_1_delta)</div><div class="line">        </div><div class="line">        <span class="attr">future_layer_1_delta</span> = layer_1_delta</div><div class="line">    </div><div class="line"></div><div class="line">    <span class="comment"># 我们已经完成了所有的反向传播，可以更新几个转换矩阵了。并把更新矩阵变量清零</span></div><div class="line">    synapse_0 += synapse_0_update * alpha</div><div class="line">    synapse_1 += synapse_1_update * alpha</div><div class="line">    synapse_h += synapse_h_update * alpha</div><div class="line"></div><div class="line">    synapse_0_update *= <span class="number">0</span></div><div class="line">    synapse_1_update *= <span class="number">0</span></div><div class="line">    synapse_h_update *= <span class="number">0</span></div><div class="line">    </div><div class="line">    <span class="comment"># print out progress</span></div><div class="line">    <span class="keyword">if</span>(j % <span class="number">1000</span> == <span class="number">0</span>):</div><div class="line">        print(<span class="string">"Error:"</span> + str(overallError))</div><div class="line">        print(<span class="string">"Pred:"</span> + str(d))</div><div class="line">        print(<span class="string">"True:"</span> + str(c))</div><div class="line">        <span class="attr">out</span> = <span class="number">0</span></div><div class="line">        for index,x <span class="keyword">in</span> enumerate(reversed(d)):</div><div class="line">            out += x*pow(<span class="number">2</span>,index)</div><div class="line">        print(str(a_int) + <span class="string">" + "</span> + str(b_int) + <span class="string">" = "</span> + str(out))</div><div class="line">        print(<span class="string">"------------"</span>)</div></pre></td></tr></table></figure>
<h1 id="运行时输出"><a href="#运行时输出" class="headerlink" title="运行时输出"></a>运行时输出</h1><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">Error:[ 3.45638663]</div><div class="line">Pred:[0 0 0 0 0 0 0 1]</div><div class="line">True:[0 1 0 0 0 1 0 1]</div><div class="line"><span class="section">9 + 60 = 1</span></div><div class="line">------------</div><div class="line">Error:[ 3.63389116]</div><div class="line">Pred:[1 1 1 1 1 1 1 1]</div><div class="line">True:[0 0 1 1 1 1 1 1]</div><div class="line"><span class="section">28 + 35 = 255</span></div><div class="line">------------</div><div class="line">Error:[ 3.91366595]</div><div class="line">Pred:[0 1 0 0 1 0 0 0]</div><div class="line">True:[1 0 1 0 0 0 0 0]</div><div class="line"><span class="section">116 + 44 = 72</span></div><div class="line">------------</div><div class="line">Error:[ 3.72191702]</div><div class="line">Pred:[1 1 0 1 1 1 1 1]</div><div class="line">True:[0 1 0 0 1 1 0 1]</div><div class="line"><span class="section">4 + 73 = 223</span></div><div class="line">------------</div><div class="line">Error:[ 3.5852713]</div><div class="line">Pred:[0 0 0 0 1 0 0 0]</div><div class="line">True:[0 1 0 1 0 0 1 0]</div><div class="line"><span class="section">71 + 11 = 8</span></div><div class="line">------------</div><div class="line">Error:[ 2.53352328]</div><div class="line">Pred:[1 0 1 0 0 0 1 0]</div><div class="line">True:[1 1 0 0 0 0 1 0]</div><div class="line"><span class="section">81 + 113 = 162</span></div><div class="line">------------</div><div class="line">Error:[ 0.57691441]</div><div class="line">Pred:[0 1 0 1 0 0 0 1]</div><div class="line">True:[0 1 0 1 0 0 0 1]</div><div class="line"><span class="section">81 + 0 = 81</span></div><div class="line">------------</div><div class="line">Error:[ 1.42589952]</div><div class="line">Pred:[1 0 0 0 0 0 0 1]</div><div class="line">True:[1 0 0 0 0 0 0 1]</div><div class="line"><span class="section">4 + 125 = 129</span></div><div class="line">------------</div><div class="line">Error:[ 0.47477457]</div><div class="line">Pred:[0 0 1 1 1 0 0 0]</div><div class="line">True:[0 0 1 1 1 0 0 0]</div><div class="line"><span class="section">39 + 17 = 56</span></div><div class="line">------------</div><div class="line">Error:[ 0.21595037]</div><div class="line">Pred:[0 0 0 0 1 1 1 0]</div><div class="line">True:[0 0 0 0 1 1 1 0]</div><div class="line"><span class="section">11 + 3 = 14</span></div><div class="line">------------</div></pre></td></tr></table></figure>
<h1 id="第一部分：什么是神经元记忆"><a href="#第一部分：什么是神经元记忆" class="headerlink" title="第一部分：什么是神经元记忆"></a>第一部分：什么是神经元记忆</h1><p>顺着背出字母表，你很容易做到吧？</p>
<p>倒着背呢， 有点难哦。</p>
<p>试着想一首你记得的歌词。为什么顺着回忆比倒着回忆难？你能直接跳到第二小节的中间么？额， 好像有点难。 这是为什么呢？</p>
<p>这其实很符合逻辑。 你记忆字母表或者歌词并不是像计算机把信息存储在硬盘上那样的（译者注：计算机可以随机访问磁盘。）。你是顺序记忆的。知道了前一个字母，你很容易知道下一个。这是一种条件记忆，只有你最近知道了前一个记忆，你才容易想起来下一个记忆，就想你熟悉的链表一样。</p>
<p>但是，并不是说你不唱歌的时候，歌就不在你脑子里了。而是说你如果想直接跳到中间那部分，你会发现很难直接找到其在脑中的呈现（也许是一堆神经元）。你想直接搜索到一首歌的中间部分，这是很难的， 因为你以前没有这样做过，所以没有索引可以指向歌曲的中间部分。 就好比你邻居家有很多小路， 你从前门进去顺着路走很容易找到后院，但是让你直接到后院去就不太容易。想了解更过关于大脑的知识，请看<a href="http://www.human-memory.net/processes_recall.html" target="_blank" rel="external">这里</a>。</p>
<p>跟链表很像，记忆这样存储很高效。我们可以发现这样存储在解决很多问题时候有优势。</p>
<p>如果你的数据是一个序列，那么记忆就很重要（意味着你必须记住某些东西）。看下面的视频：</p>
<iframe width="700" height="525" src="https://www.youtube.com/embed/UL0ZOgN2SqY" frameborder="0" allowfullscreen></iframe>


<p>每一个数据点就是视频中的一帧。如果你想训练一个神经网络来预测下一帧小球的位置， 那么知道上一帧小球的位置就很重要。这样的序列数据就是我们需要构建循环神经网络的原因。那么， 神经网络怎么记住以前的信息呢？</p>
<p>神经网络有隐藏层。一般而言，隐藏层的状态由输入决定。所以，一般而言神经网络的信息流如下图：<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">input</span> -&gt;</span> <span class="function"><span class="title">hidden</span> -&gt;</span> output</div></pre></td></tr></table></figure></p>
<p>这很简单直接。特定的输入决定特定的隐藏层，特定的隐藏层又决定了输出。这是一种封闭系统。记忆改变了这种状况。记忆意味着，隐藏状态是由当前时间点的输入和上一个时间点的隐藏状态决定的。<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="params">(input + prev_hidden)</span> -&gt;</span> hidden<span class="function"> -&gt;</span> output</div></pre></td></tr></table></figure></p>
<p>为什么是隐藏层而不是输入层呢？我们也可以这样做呀：<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="params">(input + prev_input)</span> -&gt;</span> hidden<span class="function"> -&gt;</span> output</div></pre></td></tr></table></figure></p>
<p>现在，仔细想想，如果有四个时间点，如果我们采用隐藏层循环是如下图：<br><img src="http://oml1i2pi6.bkt.clouddn.com/hidden-recurrence.jpg" alt="hidden layer recurrence"><br>如果采用输入层循环会是：<br><img src="http://oml1i2pi6.bkt.clouddn.com/input-recurrence.jpg" alt="input layer recurrence"><br>看到区别没，隐藏层记忆了之前所有的输入信息，而输入层循环则只能利用到上一个输入。举个例子，假设一首歌词里面有”….I love you…”和”…I love carrots…”，如果采用输入层循环，则没法根据”I love”来预测下一个词是什么？因为当前输入是love，前一个输入是I，这两种情况一致，所以没法区分。 而隐藏层循环则可以记住更久之前的输入信息，因而能更好地预测下一个词。理论上而言，隐藏层循环可以记住所有之前的输入，当然记忆会随着时间流逝逐渐忘却。有兴趣的可以看<a href="http://karpathy.github.io/2015/05/21/rnn-effectiveness/" target="_blank" rel="external">这篇blog</a>。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">停下来好好想想， 直到你感觉想明白了再继续。</div></pre></td></tr></table></figure></p>
<h1 id="第二部分：RNN-神经网络记忆"><a href="#第二部分：RNN-神经网络记忆" class="headerlink" title="第二部分：RNN - 神经网络记忆"></a>第二部分：RNN - 神经网络记忆</h1><p>现在我们已经有了一些直观认识， 接下来让我们更进一步分析。正如在<a href="http://iamtrask.github.io/2015/07/12/basic-python-network/" target="_blank" rel="external">反向传播这篇blog</a>里介绍的，神经网络的输入层是由输入数据集决定的。每一行输入数据用来产生隐藏层（通过正向传播）。每个隐藏层又用于产生输出层（假设只有一层隐藏层）。如我们之前所说，记忆意味着隐藏层是由输入数据和前一次的隐藏层组合而成。怎么做的呢？很像神经网络里面其他传播的做法一样， 通过矩阵！这个矩阵定义了当前隐藏层跟前一个隐藏层的关系。</p>
<p><img src="http://iamtrask.github.io/img/basic_recurrence_singleton.png" alt="rnn"><br>这幅图中很重要的一点是有三个权重矩阵。有两个我们很熟悉了。SYNAPSE_0用于把输入数据传播到隐藏层。SYNAPSE_1把隐藏层传播到输出数据。新矩阵（SYNAPSE_h，用于循环）把当前的隐藏层（layer_1）传播到下一个时间点的隐藏层（还是layer_1）。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">停下来好好想想， 直到你感觉想明白了再继续。</div></pre></td></tr></table></figure></p>
<p><img src="http://iamtrask.github.io/img/recurrence_gif.gif" alt="forward"><br>上面的gif图展示了循环神经网络的神奇之处以及一些很重要的性质。它展示了四个时间点隐藏层的情况。第一个时间点，隐藏层仅由输入数据决定。第二个时间点，隐藏层是由输入数据和第一个时间点的隐藏层共同决定的。以此类推。你应该注意到了，第四个时间点的时候，网络已经“满了”。所以大概第五个时间点来的时候，就要选择哪些记忆保留，哪些记忆覆盖。现实如此。这就是记忆“容量”的概念。如你所想，更大的隐藏层，就能记住更长时间的东西。同样，这就需要神经网络学会<strong>忘记不相关的记忆</strong>然后<strong>记住重要的记忆</strong>。第三步有没看出什么重要信息？为什么<strong>绿色</strong>的要比其他颜色的多呢？</p>
<p>另外要注意的是隐藏层夹在输入层和输出层中间，所以输出已经不仅仅取决于输入了。输入仅仅改变记忆，而输出仅仅依赖于记忆。有趣的是，如果2，3，4时间节点没有输入数据的话，隐藏层同样会随着时间流逝而变化。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">停下来好好想想，确保你明白了刚讲的内容。</div></pre></td></tr></table></figure></p>
<h1 id="第三部分：基于时间的反向传播"><a href="#第三部分：基于时间的反向传播" class="headerlink" title="第三部分：基于时间的反向传播"></a>第三部分：基于时间的反向传播</h1><p>那么循环神经网络是怎么学习的呢？看看下面的图。黑色表示预测结果，明黄色表示错误，褐黄色表示导数。<br><img src="http://iamtrask.github.io/img/backprop_through_time.gif" alt="bp"><br>网络通过从1到4的全部前向传播（可以是任意长度的整个序列），然后再从4到1的反向传播导数来学习。你可以把它看成一个有点变形的普通神经网络，除了我们在不同的地方共享权值（synapses 0,1,and h）。除了这点， 它就是一个普通的神经网络。</p>
<h1 id="我们的玩具代码"><a href="#我们的玩具代码" class="headerlink" title="我们的玩具代码"></a>我们的玩具代码</h1><p>来，我们用循环神经网络做个模型来实现<strong>二进制加法</strong>。看到下面的图没，你猜猜顶上的彩色的1表示什么意思呢？<br><img src="http://iamtrask.github.io/img/binary_addition.GIF" alt="toy code"><br>方框里的彩色的1表示<strong>进位</strong>。我们就要用循环神经网络来记住这个进位。求和的时候需要记住<strong>进位</strong>（如果不懂，可以看<a href="https://www.youtube.com/watch?v=jB_sRh5yoZk" target="_blank" rel="external">这里</a>）。</p>
<p>二进制加法做法就是，从右往左，根据上面两行的bit来预测第三行的bit为1还是0。我们想要神经网络遍历整个二进制序列记住是否有进位，以便能计算出正确的结果。不要太纠结这个问题本身，神经网络也不在乎这个问题。它在乎的只是每个时刻它会收到两个输入（0或者1），然后它会传递给用于记忆是否有进位的隐藏层。神经网络会把所有这些信息（输入和隐藏层的记忆）考虑进去，来对每一位（每个时间点）做出正确的预测。</p>
<hr>
<p>下面原文里面是针对每行代码做的注释， 为了方便阅读， 我直接把注释写到了代码里面， 便于大家阅读。</p>
<p>译者注：RNN在自然语言处理里面大量使用，包括机器翻译，对话系统，机器做诗词等，本文只是简单介绍了一下原理。后续我会写一些应用方面的文章，敬请期待。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文翻译自&lt;a href=&quot;https://twitter.com/iamtrask&quot;&gt;@iamtrask&lt;/a&gt;的&lt;a href=&quot;http://iamtrask.github.io/2015/11/15/anyone-can-code-lstm/&quot;&gt;Anyone Can Learn To Code an LSTM-RNN in Python (Part 1: RNN)&lt;/a&gt;。本文作者已通过&lt;a href=&quot;https://twitter.com/magicly007/with_replies&quot;&gt;twitter联系作者，获得授权&lt;/a&gt;。&lt;/p&gt;
&lt;h1 id=&quot;概要&quot;&gt;&lt;a href=&quot;#概要&quot; class=&quot;headerlink&quot; title=&quot;概要&quot;&gt;&lt;/a&gt;概要&lt;/h1&gt;&lt;p&gt;我通过玩具代码一边学习一边调试能达到最好的学习效果。本文通过一个简单的python实现，教会你循环神经网络。&lt;/p&gt;
&lt;p&gt;原文作者&lt;a href=&quot;https://twitter.com/iamtrask&quot;&gt;@iamtrask&lt;/a&gt;说他会在twitter上继续发布第二部分LSTM，敬请关注。&lt;/p&gt;
    
    </summary>
    
      <category term="ML" scheme="http://magicly.me/categories/ML/"/>
    
    
      <category term="rnn" scheme="http://magicly.me/tags/rnn/"/>
    
      <category term="neural network" scheme="http://magicly.me/tags/neural-network/"/>
    
      <category term="dl" scheme="http://magicly.me/tags/dl/"/>
    
      <category term="ml" scheme="http://magicly.me/tags/ml/"/>
    
  </entry>
  
  <entry>
    <title>用word2vec分析中文维基语料库</title>
    <link href="http://magicly.me/2017/03/03/word2vec-first-try-md/"/>
    <id>http://magicly.me/2017/03/03/word2vec-first-try-md/</id>
    <published>2017-03-03T02:37:02.000Z</published>
    <updated>2017-03-03T14:01:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近需要做一些自然语言处理的工作， 发现google推出的wrod2vec比较有意思，据说可以推算出king + man - woman = queue，感觉很nb啊， 后续可以拿来做文本分类、情绪分析、关键词提取等。本文记录一下在中文wiki语料库上做的实验。</p>
<a id="more"></a>
<h1 id="word2vec下载安装"><a href="#word2vec下载安装" class="headerlink" title="word2vec下载安装"></a>word2vec下载安装</h1><p>自从google推出了<a href="https://code.google.com/archive/p/word2vec/" target="_blank" rel="external">word2vec</a>后，网上已经有众多实现，包括：</p>
<ul>
<li><a href="https://code.google.com/archive/p/word2vec/" target="_blank" rel="external">google发布的c++版本</a></li>
<li>python版<a href="https://radimrehurek.com/gensim/models/word2vec.html" target="_blank" rel="external">Gensim</a></li>
<li>java版<a href="https://deeplearning4j.org/word2vec" target="_blank" rel="external">DeepLearning4J</a></li>
<li><a href="https://github.com/danielfrg/word2vec" target="_blank" rel="external">Python interface to Google word2vec</a>。</li>
</ul>
<p>我选用Gensim版本，python3.5.2。</p>
<h1 id="数据集简介"><a href="#数据集简介" class="headerlink" title="数据集简介"></a>数据集简介</h1><p>我们用的是中文wiki语料库，下载链接<a href="https://dumps.wikimedia.org/zhwiki/latest/zhwiki-latest-pages-articles.xml.bz2，有1.3G，" target="_blank" rel="external">https://dumps.wikimedia.org/zhwiki/latest/zhwiki-latest-pages-articles.xml.bz2，有1.3G，</a> 解压之后是一个5.7G左右的xml文档。里面包含了标题、分类、正文部分等。</p>
<h1 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h1><p>上一步解压之后的xml文档我们没法直接用， 需要经过一系列的处理， 包括xml标签去除， 编码转换、简繁体转换、分词等。</p>
<h2 id="xml内容提取"><a href="#xml内容提取" class="headerlink" title="xml内容提取"></a>xml内容提取</h2><p>你可以自己写正则表达式提取内容， 当然这个太费事了。 好在已经有人做了这个事情， Gensim里自带了提取wiki内容的工具，代码如下：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">from gensim.corpora <span class="keyword">import</span> WikiCorpus</div><div class="line"></div><div class="line">space = b<span class="string">" "</span></div><div class="line">i = <span class="number">0</span></div><div class="line">output = open(<span class="string">'wiki-zh-article.txt'</span>, <span class="string">'wb'</span>)</div><div class="line">wiki = WikiCorpus(<span class="string">'zhwiki-latest-pages-articles.xml.bz2'</span>, lemmatize = False, dictionary = &#123;&#125;)</div><div class="line"><span class="keyword">for</span> text in wiki.get_texts():</div><div class="line">    output.write(space.join(text) + b<span class="string">"\n"</span>)</div><div class="line">    i = i + 1</div><div class="line">    <span class="keyword">if</span> (i % 10000 == 0):</div><div class="line">        print(<span class="string">"Saved "</span> + str(i) + <span class="string">" articles"</span>)</div><div class="line"></div><div class="line">output.close()</div><div class="line">print(<span class="string">"Finished Saved "</span> + str(i) + <span class="string">" articles"</span>)</div></pre></td></tr></table></figure></p>
<p>代码在我的macpro上大概了运行了20多分钟， 得到280819行的文本， 每行为一篇文章。有个坑大家要小心， 输入文件是压缩文件bz2，直接传解压缩之后的xml文件是会报错的。</p>
<p>另外， 我为了简洁，把不相关代码删除了，因此贴出来的代码，并不符合编程的最佳实践，请自行忽略这个问题。</p>
<h2 id="简繁体换过"><a href="#简繁体换过" class="headerlink" title="简繁体换过"></a>简繁体换过</h2><p>由于wiki语料库里简体、繁体都有，不统一的话对后面分词和跑模型准确率有影响， 所以先统一转化为简体。用到的工具是<a href="https://github.com/BYVoid/OpenCC" target="_blank" rel="external">opencc</a>。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">opencc -<span class="selector-tag">i</span> wiki-zh-<span class="selector-tag">article</span><span class="selector-class">.txt</span> -o wiki-zh-article-zhs<span class="selector-class">.txt</span> -c t2s.json</div></pre></td></tr></table></figure></p>
<p>话说作者BYVoid也是超级大神， 据说小时候玩电脑，出现乱码， 于是自己写了opencc，然后提交给Linus， 被整合到linux kernel里了，那时候应该是小学还是初中吧。后来本科毕业去阿里面试，得到青睐，晚上流传了当时的面试记录。<img src="http://s12.sinaimg.cn/orignal/001OxbOzzy6EHEbsLWP8b" alt="http://s12.sinaimg.cn/orignal/001OxbOzzy6EHEbsLWP8b"></p>
<h2 id="编码转化"><a href="#编码转化" class="headerlink" title="编码转化"></a>编码转化</h2><p>网上说文件中包含非utf-8字符，需要用iconv处理一下。我忘了我之前在全量数据上跑得时候有没有遇到， 反正写文章的时候，我拿了1/10的数据跑没遇到问题。如果遇到了可以用<a href="https://zh.wikipedia.org/wiki/Iconv" target="_blank" rel="external">iconv</a>一行命令解决：<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iconv -c -t utf<span class="number">-8</span> &lt; wiki-<span class="built_in">zh</span>-article-zhs.txt &gt; wiki-<span class="built_in">zh</span>-article-zhs-utf8.txt</div></pre></td></tr></table></figure></p>
<h2 id="分词"><a href="#分词" class="headerlink" title="分词"></a>分词</h2><p>接下来就是做分词，比较好用的工具有<a href="https://github.com/fxsjy/jieba" target="_blank" rel="external">结巴分词</a>、<a href="http://ictclas.nlpir.org/" target="_blank" rel="external">中科院的ICTCLAS</a>、<a href="http://thulac.thunlp.org/" target="_blank" rel="external">清华的THULAC</a>、<a href="https://github.com/FudanNLP/fnlp" target="_blank" rel="external">复旦的FudanNLP</a>等。我选用了结巴，代码如下：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">import codecs</div><div class="line">import jieba</div><div class="line"></div><div class="line">infile = <span class="string">'wiki-zh-article-zhs.txt'</span></div><div class="line">outfile = <span class="string">'wiki-zh-words.txt'</span></div><div class="line"></div><div class="line">descsFile = codecs.<span class="built_in">open</span>(infile, <span class="string">'rb'</span>, encoding=<span class="string">'utf-8'</span>)</div><div class="line">i = <span class="number">0</span></div><div class="line"><span class="keyword">with</span> <span class="built_in">open</span>(outfile, <span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</div><div class="line">    <span class="keyword">for</span> <span class="built_in">line</span> <span class="keyword">in</span> descsFile:</div><div class="line">        i += <span class="number">1</span></div><div class="line">        <span class="keyword">if</span> i % <span class="number">10000</span> == <span class="number">0</span>:</div><div class="line">            print(i)</div><div class="line">        <span class="built_in">line</span> = <span class="built_in">line</span>.strip()</div><div class="line">        <span class="keyword">words</span> = jieba.cut(<span class="built_in">line</span>)</div><div class="line">        <span class="keyword">for</span> <span class="built_in">word</span> <span class="keyword">in</span> <span class="keyword">words</span>:</div><div class="line">            f.<span class="built_in">write</span>(<span class="built_in">word</span> + <span class="string">' '</span>)</div><div class="line">        f.<span class="built_in">write</span>(<span class="string">'\n'</span>)</div></pre></td></tr></table></figure></p>
<p>又跑几十分钟， 喝杯茶去。。。</p>
<h1 id="Gensim跑模型训练"><a href="#Gensim跑模型训练" class="headerlink" title="Gensim跑模型训练"></a>Gensim跑模型训练</h1><p>终于可以跑模型了，这次时间会更长，看你的电脑配置了，强烈建议约个妹纸出去看看电影逛逛街再回来等。据同事说，gensim有一个坑，在windows下不能用多核？！！！于是我在我的8核macpro下跑一个多小时的，他在windows下要跑七八个小时，哈哈哈哈。。。<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">import</span> multiprocessing</div><div class="line"></div><div class="line">from gensim.models <span class="built_in">import</span> Word2Vec</div><div class="line">from gensim.models.word2vec <span class="built_in">import</span> LineSentence</div><div class="line"></div><div class="line"><span class="attr">inp</span> = 'wiki-zh-words.txt'</div><div class="line"><span class="attr">outp1</span> = 'wiki-zh-model'</div><div class="line"><span class="attr">outp2</span> = 'wiki-zh-vector'</div><div class="line"></div><div class="line"><span class="attr">model</span> = Word2Vec(LineSentence(inp), <span class="attr">size</span> = <span class="number">400</span>, <span class="attr">window</span> = <span class="number">5</span>, <span class="attr">min_count</span> = <span class="number">5</span>, <span class="attr">workers</span> = multiprocessing.cpu_count())</div><div class="line"></div><div class="line">model.save(outp1) <span class="comment">## 以二进制格式存储</span></div><div class="line">model.save_word2vec_format(outp2, <span class="attr">binary</span> = False) <span class="comment">## 以文本格式存储， 一行是一个词的vector</span></div></pre></td></tr></table></figure></p>
<p>这里用save_word2vec_format纯粹是为了看看输出的模型是什么样子的， 这样：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">台湾 0<span class="selector-class">.396402</span> 1<span class="selector-class">.611405</span> <span class="selector-tag">-0</span><span class="selector-class">.291840</span> <span class="selector-tag">-0</span><span class="selector-class">.951169</span> <span class="selector-tag">-0</span><span class="selector-class">.109141</span> 1<span class="selector-class">.918246</span> 0<span class="selector-class">.215038</span> 0<span class="selector-class">.674539</span> 2<span class="selector-class">.335748</span> <span class="selector-tag">-0</span><span class="selector-class">.757200</span> <span class="selector-tag">-0</span><span class="selector-class">.290877</span> 2<span class="selector-class">.198100</span> <span class="selector-tag">-0</span><span class="selector-class">.309420</span> 0<span class="selector-class">.438734</span> <span class="selector-tag">-1</span><span class="selector-class">.731025</span> <span class="selector-tag">-0</span><span class="selector-class">.233053</span> 0<span class="selector-class">.150694</span> 2<span class="selector-class">.214514</span> ......</div></pre></td></tr></table></figure></p>
<p>即每个词一行， 后面是400个数字， 即将每一个词变为一个400维的向量。<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">size is <span class="keyword">the</span> dimensionality <span class="keyword">of</span> <span class="keyword">the</span> feature vectors.</div></pre></td></tr></table></figure></p>
<h1 id="看看效果"><a href="#看看效果" class="headerlink" title="看看效果"></a>看看效果</h1><p>看看跟杜甫相关的词呢：<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> gensim.models <span class="keyword">import</span> Word2Vec</div><div class="line"></div><div class="line">model = Word2Vec.load(<span class="string">'./wiki-zh-model'</span>)</div><div class="line"># model = Word2Vec.load_word2vec_format(<span class="string">'./wiki-zh-vector'</span>, binary = <span class="literal">False</span>) # 如果之前用文本保存话， 用这个方法加载</div><div class="line">res = model.most_similar(<span class="string">'杜甫'</span>)</div><div class="line">print(res)</div></pre></td></tr></table></figure></p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[(<span class="symbol">'白居易</span>', <span class="number">0.8842014074325562</span>), (<span class="symbol">'苏轼</span>', <span class="number">0.8444569706916809</span>), (<span class="symbol">'陆游</span>', <span class="number">0.8307716846466064</span>), (<span class="symbol">'一诗</span>', <span class="number">0.8290032148361206</span>), (<span class="symbol">'韩愈</span>', <span class="number">0.8263246417045593</span>), (<span class="symbol">'王勃</span>', <span class="number">0.8244832754135132</span>), (<span class="symbol">'陶渊明</span>', <span class="number">0.8243700861930847</span>), (<span class="symbol">'赋诗</span>', <span class="number">0.8211008906364441</span>), (<span class="symbol">'吟咏</span>', <span class="number">0.82026606798172</span>), (<span class="symbol">'辛弃疾</span>', <span class="number">0.8185226917266846</span>)]</div></pre></td></tr></table></figure>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;</span>&gt; model.most_similar(<span class="string">'语言学'</span>)</div><div class="line">[(<span class="string">'语言学家'</span>, <span class="number">0</span>.<span class="number">7147563695907593</span>), (<span class="string">'民族学'</span>, <span class="number">0</span>.<span class="number">6887255907058716</span>), (<span class="string">'历史学'</span>, <span class="number">0</span>.<span class="number">6869072914123535</span>), (<span class="string">'比较语言学'</span>, <span class="number">0</span>.<span class="number">6818138360977173</span>), (<span class="string">'语音学'</span>, <span class="number">0</span>.<span class="number">6741021871566772</span>), (<span class="string">'音韵学'</span>, <span class="number">0</span>.<span class="number">6673719882965088</span>), (<span class="string">'语言所'</span>, <span class="number">0</span>.<span class="number">6434118747711182</span>), (<span class="string">'比较文学'</span>, <span class="number">0</span>.<span class="number">633540153503418</span>), (<span class="string">'人类学'</span>, <span class="number">0</span>.<span class="number">633027195930481</span>), (<span class="string">'方言学'</span>, <span class="number">0</span>.<span class="number">6314626336097717</span>)]</div><div class="line"><span class="meta">&gt;&gt;</span>&gt; model.most_similar(<span class="string">'林丹'</span>)</div><div class="line">[(<span class="string">'谌龙'</span>, <span class="number">0</span>.<span class="number">9071081280708313</span>), (<span class="string">'鲍春来'</span>, <span class="number">0</span>.<span class="number">9035789966583252</span>), (<span class="string">'傅海峰'</span>, <span class="number">0</span>.<span class="number">8911731243133545</span>), (<span class="string">'蔡赟'</span>, <span class="number">0</span>.<span class="number">8886306285858154</span>), (<span class="string">'汪鑫'</span>, <span class="number">0</span>.<span class="number">8803133964538574</span>), (<span class="string">'李宗伟'</span>, <span class="number">0</span>.<span class="number">8767721652984619</span>), (<span class="string">'谢杏芳'</span>, <span class="number">0</span>.<span class="number">8706355690956116</span>), (<span class="string">'周蜜'</span>, <span class="number">0</span>.<span class="number">865954577922821</span>), (<span class="string">'李雪芮'</span>, <span class="number">0</span>.<span class="number">8658450841903687</span>), (<span class="string">'赵芸蕾'</span>, <span class="number">0</span>.<span class="number">8650676012039185</span>)]</div><div class="line"><span class="meta">&gt;&gt;</span>&gt; model.most_similar(<span class="string">'习近平'</span>)</div><div class="line">[(<span class="string">'胡锦涛'</span>, <span class="number">0</span>.<span class="number">8577725291252136</span>), (<span class="string">'江泽民'</span>, <span class="number">0</span>.<span class="number">8138135075569153</span>), (<span class="string">'赵紫阳'</span>, <span class="number">0</span>.<span class="number">7295876741409302</span>), (<span class="string">'温家宝'</span>, <span class="number">0</span>.<span class="number">7284029722213745</span>), (<span class="string">'朱镕基'</span>, <span class="number">0</span>.<span class="number">7241271734237671</span>), (<span class="string">'邓小平'</span>, <span class="number">0</span>.<span class="number">7226930856704712</span>), (<span class="string">'李克强'</span>, <span class="number">0</span>.<span class="number">7181681990623474</span>), (<span class="string">'曾庆红'</span>, <span class="number">0</span>.<span class="number">6949223279953003</span>), (<span class="string">'周永康'</span>, <span class="number">0</span>.<span class="number">6847086548805237</span>), (<span class="string">'反腐'</span>, <span class="number">0</span>.<span class="number">681549072265625</span>)]</div><div class="line"><span class="meta">&gt;&gt;</span>&gt; model.most_similar(positive=[<span class="string">'中国'</span>, <span class="string">'东京'</span>], negative=[<span class="string">'日本'</span>])</div><div class="line">[(<span class="string">'北京'</span>, <span class="number">0</span>.<span class="number">35159438848495483</span>), (<span class="string">'中央电视台'</span>, <span class="number">0</span>.<span class="number">3406861424446106</span>), (<span class="string">'辽艺版'</span>, <span class="number">0</span>.<span class="number">3394508361816406</span>), (<span class="string">'宗藤'</span>, <span class="number">0</span>.<span class="number">32839435338974</span>), (<span class="string">'寻奇'</span>, <span class="number">0</span>.<span class="number">3166041970252991</span>), (<span class="string">'china'</span>, <span class="number">0</span>.<span class="number">3111165761947632</span>), (<span class="string">'是冈瓦'</span>, <span class="number">0</span>.<span class="number">3110591471195221</span>), (<span class="string">'北京电视台'</span>, <span class="number">0</span>.<span class="number">31081947684288025</span>), (<span class="string">'女热'</span>, <span class="number">0</span>.<span class="number">30060601234436035</span>), (<span class="string">'北京市'</span>, <span class="number">0</span>.<span class="number">29704713821411133</span>)]</div><div class="line"><span class="meta">&gt;&gt;</span>&gt; model.most_similar(<span class="string">'林志玲'</span>)</div><div class="line">[(<span class="string">'伊能静'</span>, <span class="number">0</span>.<span class="number">7900516986846924</span>), (<span class="string">'柯震东'</span>, <span class="number">0</span>.<span class="number">787365198135376</span>), (<span class="string">'言承旭'</span>, <span class="number">0</span>.<span class="number">7779808044433594</span>), (<span class="string">'徐熙媛'</span>, <span class="number">0</span>.<span class="number">7775079607963562</span>), (<span class="string">'林志颖'</span>, <span class="number">0</span>.<span class="number">7681171894073486</span>), (<span class="string">'谢依霖'</span>, <span class="number">0</span>.<span class="number">7657250761985779</span>), (<span class="string">'阮经天'</span>, <span class="number">0</span>.<span class="number">7654315233230591</span>), (<span class="string">'郭书瑶'</span>, <span class="number">0</span>.<span class="number">7628788948059082</span>), (<span class="string">'张钧宁'</span>, <span class="number">0</span>.<span class="number">7612718939781189</span>), (<span class="string">'何润东'</span>, <span class="number">0</span>.<span class="number">7598745822906494</span>)]</div></pre></td></tr></table></figure>
<p>还有没有觉得这个可以拿来干点有意思的事情呢？比如：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;</span>&gt; model.most_similar(<span class="string">'苍井空'</span>)</div><div class="line">[(<span class="string">'吉泽明步'</span>, <span class="number">0</span>.<span class="number">7175988554954529</span>), (<span class="string">'反町隆史'</span>, <span class="number">0</span>.<span class="number">6755084991455078</span>), (<span class="string">'金城武'</span>, <span class="number">0</span>.<span class="number">6724058389663696</span>), (<span class="string">'柴崎幸'</span>, <span class="number">0</span>.<span class="number">6579034924507141</span>), (<span class="string">'藤原纪香'</span>, <span class="number">0</span>.<span class="number">656890332698822</span>), (<span class="string">'松隆子'</span>, <span class="number">0</span>.<span class="number">6524500846862793</span>), (<span class="string">'仓田保昭'</span>, <span class="number">0</span>.<span class="number">6456934809684753</span>), (<span class="string">'柴咲幸'</span>, <span class="number">0</span>.<span class="number">6456423997879028</span>), (<span class="string">'叶山豪'</span>, <span class="number">0</span>.<span class="number">6449219584465027</span>), (<span class="string">'濑户朝香'</span>, <span class="number">0</span>.<span class="number">6442539095878601</span>)]</div></pre></td></tr></table></figure></p>
<p>请尽情发挥想象。。。。。。。。。。。。。。。。</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>列几个word2vec的用途。</p>
<ul>
<li>情感分析 <a href="http://datartisan.com/article/detail/48.html" target="_blank" rel="external">http://datartisan.com/article/detail/48.html</a></li>
<li>SEO <a href="https://seofangfa.com/seo-articles/word2vec.html" target="_blank" rel="external">https://seofangfa.com/seo-articles/word2vec.html</a></li>
</ul>
<p>另外，如果想深入了解word2vec的原理， 可以看最初的论文<a href="https://arxiv.org/pdf/1310.4546.pdf" target="_blank" rel="external">Distributed Representations of Words and Phrases<br>and their Compositionality</a>，以及<a href="http://techblog.youdao.com/?p=915" target="_blank" rel="external">有道的这篇分析</a>。</p>
<p>如果想自己动手实现word2vec的话， 可以考虑用当前最热的深度学习框架<a href="https://www.tensorflow.org/" target="_blank" rel="external">TensorFlow</a>来实现， 官网上有<a href="https://www.tensorflow.org/tutorials/word2vec" target="_blank" rel="external">详细地介绍</a>。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="http://www.52nlp.cn/%E4%B8%AD%E8%8B%B1%E6%96%87%E7%BB%B4%E5%9F%BA%E7%99%BE%E7%A7%91%E8%AF%AD%E6%96%99%E4%B8%8A%E7%9A%84word2vec%E5%AE%9E%E9%AA%8C" target="_blank" rel="external">http://www.52nlp.cn/%E4%B8%AD%E8%8B%B1%E6%96%87%E7%BB%B4%E5%9F%BA%E7%99%BE%E7%A7%91%E8%AF%AD%E6%96%99%E4%B8%8A%E7%9A%84word2vec%E5%AE%9E%E9%AA%8C</a></li>
<li><a href="https://radimrehurek.com/gensim/models/word2vec.html" target="_blank" rel="external">https://radimrehurek.com/gensim/models/word2vec.html</a></li>
<li><a href="https://code.google.com/archive/p/word2vec/" target="_blank" rel="external">https://code.google.com/archive/p/word2vec/</a></li>
<li><a href="http://licstar.net/archives/262" target="_blank" rel="external">http://licstar.net/archives/262</a></li>
<li><a href="https://github.com/fxsjy/jieba" target="_blank" rel="external">https://github.com/fxsjy/jieba</a></li>
<li><a href="http://thulac.thunlp.org/" target="_blank" rel="external">http://thulac.thunlp.org/</a></li>
<li><a href="http://arxiv.org/pdf/1310.4546.pdf" target="_blank" rel="external">http://arxiv.org/pdf/1310.4546.pdf</a></li>
<li><a href="https://www.tensorflow.org/tutorials/word2vec" target="_blank" rel="external">https://www.tensorflow.org/tutorials/word2vec</a></li>
<li><a href="http://techblog.youdao.com/?p=915" target="_blank" rel="external">http://techblog.youdao.com/?p=915</a></li>
<li><a href="http://blog.csdn.net/zhaoxinfan/article/details/11069485" target="_blank" rel="external">http://blog.csdn.net/zhaoxinfan/article/details/11069485</a></li>
<li><a href="http://cikuapi.com/index.php" target="_blank" rel="external">http://cikuapi.com/index.php</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近需要做一些自然语言处理的工作， 发现google推出的wrod2vec比较有意思，据说可以推算出king + man - woman = queue，感觉很nb啊， 后续可以拿来做文本分类、情绪分析、关键词提取等。本文记录一下在中文wiki语料库上做的实验。&lt;/p&gt;
    
    </summary>
    
      <category term="ML" scheme="http://magicly.me/categories/ML/"/>
    
    
      <category term="machine learning" scheme="http://magicly.me/tags/machine-learning/"/>
    
      <category term="word2vec" scheme="http://magicly.me/tags/word2vec/"/>
    
      <category term="nlp" scheme="http://magicly.me/tags/nlp/"/>
    
  </entry>
  
  <entry>
    <title>在markdown里如何写数学公式</title>
    <link href="http://magicly.me/2017/03/02/markdown-math/"/>
    <id>http://magicly.me/2017/03/02/markdown-math/</id>
    <published>2017-03-02T03:16:16.000Z</published>
    <updated>2017-03-02T15:58:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近准备写一下机器学习的一些学习笔记， 由于涉及到大量数学公式， 发现不把如何在markdown里写数学公式这个问题解决了会严重影响工作效率。大概而言， 主要有两种方式：</p>
<a id="more"></a>
<ol>
<li>用图片！<br>也就是编辑好公式，上传，然后在markdown里面引用图片链接的方式。这种方式方便直接，但是显得比较low一点。 有兴趣的可以参考这几篇文章。</li>
</ol>
<ul>
<li><a href="http://www.ruanyifeng.com/blog/2011/07/formula_online_generator.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2011/07/formula_online_generator.html</a><br>当然， 在某些情况下， 必须使用这种思路。 比如， 微信公众号里。 可以参考<a href="http://www.52nlp.cn/%E5%9C%A8%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E9%87%8C%E4%BD%BF%E7%94%A8latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F" target="_blank" rel="external">这里</a></li>
</ul>
<ol>
<li>用Mathjax插件来写LaTex公式。<br>哪怕你是用图片， 那也得写出LaTex公式啊。所以我们今天主要讲第二种方式。推荐<a href="https://webdemo.myscript.com/views/math.html" target="_blank" rel="external">这个工具</a>，可以直接在浏览器里手写公式，它会帮你转为LaTex！很好很强大。</li>
</ol>
<h1 id="MathJax插件"><a href="#MathJax插件" class="headerlink" title="MathJax插件"></a>MathJax插件</h1><p>著名的Stackoverflow网站上的漂亮公式，就是使用了MathJax插件的效果。添加MathJax插件也非常简单，只需要在markdown文件中，添加MathJax CDN，如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span></span></div><div class="line">   <span class="attr">src</span>=<span class="string">"http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"</span>&gt;<span class="undefined"></span></div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>就可以在md文件中插入Tex格式的公式了。</p>
<p>行间公式的形式为<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">$</span><span class="symbol">$</span> 此处插入公式 <span class="symbol">$</span><span class="symbol">$</span></div></pre></td></tr></table></figure></p>
<p>而行内公式的形式为<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">\\(</span> 此处插入公式 <span class="string">\\)</span></div></pre></td></tr></table></figure></p>
<h1 id="Hexo中显示数学公式"><a href="#Hexo中显示数学公式" class="headerlink" title="Hexo中显示数学公式"></a>Hexo中显示数学公式</h1><p>Hexo原生不支持数学公式， 因此需要我们做一些修改。安装<a href="https://github.com/akfish/hexo-math" target="_blank" rel="external">hexo-math</a>插件：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-<span class="built_in">math</span> <span class="comment">--save</span></div></pre></td></tr></table></figure>
<p>在_config.yml中增加<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">plugins:</span></div><div class="line">  hexo-math</div></pre></td></tr></table></figure></p>
<p>完事大吉， 你现在可以写LaTex公式了， 我们来写几个看看。</p>
<p>这是行内公式根号2这样写: \(\sqrt{2}\)<br><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">\\</span>(<span class="symbol">\\</span>sqrt&#123;2&#125;<span class="symbol">\\</span>)</div></pre></td></tr></table></figure></p>
<p>这是单独一行的公式:<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">$</span><span class="symbol">$</span> a ^ <span class="number">2</span> + b ^ <span class="number">2</span> = c ^ <span class="number">2</span> <span class="symbol">$</span><span class="symbol">$</span></div><div class="line"><span class="symbol">$</span><span class="symbol">$</span> \<span class="built-in">sqrt</span>&#123;<span class="number">2</span>&#125; <span class="symbol">$</span><span class="symbol">$</span></div><div class="line"><span class="symbol">$</span><span class="symbol">$</span> evidence\_&#123;i&#125;=\<span class="keyword">sum</span> \_&#123;j&#125;W\_&#123;ij&#125;x\_&#123;j&#125;+b\_&#123;i&#125; <span class="symbol">$</span><span class="symbol">$</span></div></pre></td></tr></table></figure></p>
<p>$$ a ^ 2 + b ^ 2 = c ^ 2 $$<br>$$ \sqrt{2} $$<br>$$ evidence_{i}=\sum _{j}W_{ij}x_{j}+b_{i} $$<br>细心的同学会发现， 里面有很多<strong>\\</strong>, <strong>\_</strong>之类， 原因是<strong>\</strong>本身在markdown和LaTex里都有含义， 因此需要转义。但是LaTex里面， <strong>\</strong>太常用了， 所以每次遇到都转义的话就很痛苦， 而且在hexo里面写的公式，复制到其他地方去就不支持了。</p>
<p>网上有改hexo渲染的源码的， 有换用pandoc的， 其实最简单的方式是用hexo-math里的tag。网上搜索到的很多资料都是用的{&#37; math_block %}，我试了发现总是不对， 后来看<a href="https://github.com/akfish/hexo-math" target="_blank" rel="external">官网</a>，发现这个方法已经deprecated了， 最新的用{&#37; math %}，如下：</p>
<figure class="highlight django"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="xml">这是行内公式：</span><span class="template-tag">&#123;% <span class="name">math</span> %&#125;</span><span class="xml">\sqrt&#123;2 + 3&#125;</span><span class="template-tag">&#123;% <span class="name">endmath</span> %&#125;</span><span class="xml"></span></div></pre></td></tr></table></figure>
<p>显示为：这是行内公式：<span>$\sqrt{2 + 3}$</span><!-- Has MathJax --><br>一行公式：<br><figure class="highlight tex"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="formula">$$ evidence<span class="tag">\<span class="name">_</span><span class="string">&#123;i&#125;</span>=</span><span class="tag">\<span class="name">sum</span></span> <span class="tag">\<span class="name">_</span><span class="string">&#123;j&#125;</span></span>W<span class="tag">\<span class="name">_</span><span class="string">&#123;ij&#125;</span></span>x<span class="tag">\<span class="name">_</span><span class="string">&#123;j&#125;</span></span>+b<span class="tag">\<span class="name">_</span><span class="string">&#123;i&#125;</span></span> $$</span></div><div class="line"></div><div class="line">&#123;<span class="comment">% math %&#125;</span></div><div class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;aligned&#125;</span></span></div><div class="line">evidence_&#123;i&#125;=<span class="tag">\<span class="name">sum</span></span> _&#123;j&#125;W_&#123;ij&#125;x_&#123;j&#125;+b_&#123;i&#125;</div><div class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;aligned&#125;</span></span></div><div class="line">&#123;<span class="comment">% endmath %&#125;</span></div></pre></td></tr></table></figure></p>
<p>$$ evidence_{i}=\sum _{j}W_{ij}x_{j}+b_{i} $$<br><span>$$\begin{aligned}
evidence_{i}=\sum _{j}W_{ij}x_{j}+b_{i}
\end{aligned}$$</span><!-- Has MathJax --><br>可以看出， 如果有需要转义的字符， 用{&#37; math %}tag这种方式要好很多。</p>
<p>再来一个复杂点的公式， 这是<a href="https://www.tensorflow.org/tutorials/word2vec" target="_blank" rel="external">word2vec</a>的损失函数公式（选中公式， 右键可以查看LaTex源码）：<br><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="variable">% math %</span>&#125;</div><div class="line">J_<span class="symbol">\t</span>ext&#123;NEG&#125; = <span class="symbol">\l</span>og Q_<span class="symbol">\t</span>heta(D=1 |w_t, h) +</div><div class="line">  k <span class="symbol">\m</span>athop&#123;<span class="symbol">\m</span>athbb&#123;E&#125;&#125;_&#123;<span class="symbol">\t</span>ilde w <span class="symbol">\s</span>im P_<span class="symbol">\t</span>ext&#123;noise&#125;&#125;</div><div class="line">     <span class="symbol">\l</span>eft[ <span class="symbol">\l</span>og Q_<span class="symbol">\t</span>heta(D = 0 |<span class="symbol">\t</span>ilde w, h) <span class="symbol">\r</span>ight]</div><div class="line">&#123;<span class="variable">% endmath %</span>&#125;</div></pre></td></tr></table></figure></p>
<span>$$J_\text{NEG} = \log Q_\theta(D=1 |w_t, h) +
  k \mathop{\mathbb{E}}_{\tilde w \sim P_\text{noise}}
     \left[ \log Q_\theta(D = 0 |\tilde w, h) \right]$$</span><!-- Has MathJax -->
<p>经过简单的配置， 我们的web页面已经可以支持很方便的书写数学公式了，而且由于不用特殊转义， 这里写的LaTex可以在其他markdown环境下使用， 比如<a href="http://mp.weixin.qq.com/s?__biz=MjM5NjAyNjkwMA==&amp;mid=2723942529&amp;idx=1&amp;sn=3b417dd77b4d5b92231ed59649844eb9&amp;chksm=81473ffab630b6ec843d77432c487e3e3a272ec26a5b9e0ae4007f5fce3dd826825a7b64a249&amp;mpshare=1&amp;scene=1&amp;srcid=0301zj3JKl85H692JGwUHZzM#rd" target="_blank" rel="external">有道云笔记</a>。</p>
<p>============update===========</p>
<p>刚发现由于引用了MathJax.js， 本身又会引用其他一些js、css以及font， 会多增加差不多100k资源， 并且由于都是国外的cdn， 速度受限制（貌似还要翻墙），所以比较影响阅读体验。后续再想办法优化吧。</p>
<p>============update===========<br>发现next主题好看一些， 换成了next。 看到next直接<a href="http://theme-next.iissnan.com/third-party-services.html#others" target="_blank" rel="external">支持MathJax</a>的，换成了qiniu的cdn。但是next自带的math，不能支持{&#37; math %}，发现还是需要hexo-math， 而且很奇怪的是， 发现不用在_config.yml里面写<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">plugins:</span></div><div class="line">  hexo-math</div></pre></td></tr></table></figure></p>
<p>居然也可以， 只要package.json里面有hexo-math就可以了。于是参考<a href="https://github.com/akfish/hexo-math" target="_blank" rel="external">hexo-math官网</a>，换成了qiniu的cdn。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">math</span>:</div><div class="line">  <span class="attribute">engine</span>: <span class="string">'mathjax'</span> # or <span class="string">'katex'</span></div><div class="line">  <span class="attribute">mathjax</span>:</div><div class="line">  <span class="attribute">src</span>: <span class="comment">//cdn.staticfile.org/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML</span></div></pre></td></tr></table></figure></p>
<p>奇怪的是，还是有一个网络请求，不知道从哪里来的。<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https:<span class="regexp">//</span>cdn.mathjax.org<span class="regexp">/mathjax/</span>contrib<span class="regexp">/a11y/</span>accessibility-menu.js?V=<span class="number">2.7</span>.<span class="number">0</span></div></pre></td></tr></table></figure></p>
<p>而且说的<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Your <span class="built_in">config</span> will be merged into <span class="built_in">default</span> <span class="built_in">config</span>:</div></pre></td></tr></table></figure></p>
<p>似乎也没有。生成的代码为<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/x-mathjax-config"</span>&gt;</span><span class="actionscript"></span></div><div class="line">  MathJax.Hub.Config(<span class="string">""</span>);</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>配置目没有了？！！好在似乎没有影响使用，那就先暂时这样用着吧~~</p>
<p>[Refs]</p>
<ul>
<li><a href="http://jzqt.github.io/2015/06/30/Markdown%E4%B8%AD%E5%86%99%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/" target="_blank" rel="external">http://jzqt.github.io/2015/06/30/Markdown%E4%B8%AD%E5%86%99%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/</a></li>
<li><a href="https://www.zybuluo.com/codeep/note/163962" target="_blank" rel="external">https://www.zybuluo.com/codeep/note/163962</a></li>
<li><a href="http://oiltang.com/2014/05/04/markdown-and-mathjax/" target="_blank" rel="external">http://oiltang.com/2014/05/04/markdown-and-mathjax/</a></li>
<li><a href="http://www.jeyzhang.com/how-to-insert-equations-in-markdown.html" target="_blank" rel="external">http://www.jeyzhang.com/how-to-insert-equations-in-markdown.html</a></li>
<li><a href="http://www.52nlp.cn/%E5%9C%A8%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E9%87%8C%E4%BD%BF%E7%94%A8latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F" target="_blank" rel="external">http://www.52nlp.cn/%E5%9C%A8%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E9%87%8C%E4%BD%BF%E7%94%A8latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F</a></li>
<li><a href="https://github.com/mathjax/MathJax-node" target="_blank" rel="external">https://github.com/mathjax/MathJax-node</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近准备写一下机器学习的一些学习笔记， 由于涉及到大量数学公式， 发现不把如何在markdown里写数学公式这个问题解决了会严重影响工作效率。大概而言， 主要有两种方式：&lt;/p&gt;
    
    </summary>
    
      <category term="ML" scheme="http://magicly.me/categories/ML/"/>
    
    
      <category term="math" scheme="http://magicly.me/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>机器学习计划</title>
    <link href="http://magicly.me/2017/02/12/ml-content/"/>
    <id>http://magicly.me/2017/02/12/ml-content/</id>
    <published>2017-02-12T14:04:10.000Z</published>
    <updated>2017-05-17T09:15:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>机器学习已经影响了我们生活中的每一个地方， 了解一些机器学习知识， 便于提高竞争力， 避免被机器替代。<br>下面是我参考咨询了很多大牛之后搜集整理的一些学习资料， 基本都是该领域世界最顶尖的高手亲自授课，以及一些最流行的工具库， 值得学习。</p>
<a id="more"></a>
<p><em>. Fast.ai课程，<a href="http://course.fast.ai/，" target="_blank" rel="external">http://course.fast.ai/，</a> 中文版<a href="http://geek.ai100.com.cn/tag/fast-ai，已完成，这个是我目前觉得最好的课程。" target="_blank" rel="external">http://geek.ai100.com.cn/tag/fast-ai，已完成，这个是我目前觉得最好的课程。</a>
</em>. Andrew NG <a href="https://www.coursera.org/learn/machine-learning（已完成）" target="_blank" rel="external">https://www.coursera.org/learn/machine-learning（已完成）</a><br><em>. Andrew NG Unsupervised Feature Learning and Deep Learning <a href="http://deeplearning.stanford.edu/tutorial/（学习ing）" target="_blank" rel="external">http://deeplearning.stanford.edu/tutorial/（学习ing）</a>
</em>. <a href="http://neuralnetworksanddeeplearning.com/" target="_blank" rel="external">http://neuralnetworksanddeeplearning.com/</a> （已完成）<br><em>. Andrew NG, standford的机器学习课程之一， <a href="http://cs229.stanford.edu/" target="_blank" rel="external">http://cs229.stanford.edu/</a>
</em>. Neural Networks for Machine Learning <a href="https://www.coursera.org/learn/neural-networks" target="_blank" rel="external">https://www.coursera.org/learn/neural-networks</a> by Geoffrey Hinton, Professor(深度学习创始人) （学习中），有点后悔， 这个课程并不是适合初学者。参考<a href="https://www.quora.com/Is-it-wise-to-learn-deep-learning-from-Hintons-course-on-Coursera" target="_blank" rel="external">这里</a><br><em>. 李飞飞课程<a href="http://cs231n.github.io/" target="_blank" rel="external">http://cs231n.github.io/</a>
</em>. 斯坦福自然语言处理 <a href="http://web.stanford.edu/class/cs224n/" target="_blank" rel="external">http://web.stanford.edu/class/cs224n/</a><br><em>. Tensorflow for Deep Learning Research <a href="http://web.stanford.edu/class/cs20si/" target="_blank" rel="external">http://web.stanford.edu/class/cs20si/</a>
</em>. 伯克利人工智能课程 <a href="http://www-inst.eecs.berkeley.edu/~cs188/archives.html" target="_blank" rel="external">http://www-inst.eecs.berkeley.edu/~cs188/archives.html</a><br><em>. <a href="http://www.deeplearningbook.org/" target="_blank" rel="external">http://www.deeplearningbook.org/</a>, by Ian Goodfellow and Yoshua Bengio（深度学习四大金刚之一） and Aaron Courville
</em>. udacity深度学习课程tensorflow <a href="https://classroom.udacity.com/courses/ud730/（学习中）" target="_blank" rel="external">https://classroom.udacity.com/courses/ud730/（学习中）</a><br><em>. <a href="https://keras.io" target="_blank" rel="external">https://keras.io</a>
</em>. <a href="https://scikit-learn.org" target="_blank" rel="external">https://scikit-learn.org</a><br><em>. <a href="https://www.tensorflow.org" target="_blank" rel="external">https://www.tensorflow.org</a>
</em>. <a href="http://deeplearning.net/" target="_blank" rel="external">http://deeplearning.net/</a><br>*. <a href="https://www.kaggle.com" target="_blank" rel="external">https://www.kaggle.com</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;机器学习已经影响了我们生活中的每一个地方， 了解一些机器学习知识， 便于提高竞争力， 避免被机器替代。&lt;br&gt;下面是我参考咨询了很多大牛之后搜集整理的一些学习资料， 基本都是该领域世界最顶尖的高手亲自授课，以及一些最流行的工具库， 值得学习。&lt;/p&gt;
    
    </summary>
    
      <category term="ML" scheme="http://magicly.me/categories/ML/"/>
    
    
      <category term="AI" scheme="http://magicly.me/tags/AI/"/>
    
      <category term="ML" scheme="http://magicly.me/tags/ML/"/>
    
      <category term="machine learning" scheme="http://magicly.me/tags/machine-learning/"/>
    
      <category term="deep learning" scheme="http://magicly.me/tags/deep-learning/"/>
    
      <category term="深度学习" scheme="http://magicly.me/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>bezier-curve</title>
    <link href="http://magicly.me/2016/11/29/bezier-curve/"/>
    <id>http://magicly.me/2016/11/29/bezier-curve/</id>
    <published>2016-11-29T03:09:52.000Z</published>
    <updated>2016-11-29T09:49:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是贝塞尔曲线"><a href="#什么是贝塞尔曲线" class="headerlink" title="什么是贝塞尔曲线"></a>什么是贝塞尔曲线</h1><p>最近做一个动画效果时需要将物体做曲线移动， 本来记得css3里的动画是可以指定beizer curve的， 结果用的时候发现css3的beizer curve只用来做easing timing function。简单来说就是拿来控制动画“非线性”移动，比如越来越快（ease-in）， 越来越慢（ease-out），先慢后快再慢（ease-in-out）等， 让动画效果更“灵动”， 避免线性（linear）的死板。</p>
<p>可以看看这两个页面， 有一个直观的感受。</p>
<a id="more"></a>
<ul>
<li><a href="http://cubic-bezier.com/" target="_blank" rel="external">http://cubic-bezier.com/</a></li>
<li><a href="http://easings.net/zh-cn" target="_blank" rel="external">http://easings.net/zh-cn</a></li>
</ul>
<p>beizer curve在css3中的使用， 可以自己google一下， 或者看下：</p>
<ul>
<li><a href="http://www.w3school.com.cn/css3/css3_transition.asp" target="_blank" rel="external">http://www.w3school.com.cn/css3/css3_transition.asp</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/02/css_transition_and_animation.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2014/02/css_transition_and_animation.html</a></li>
</ul>
<p>引用wiki上的介绍：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">在数学的数值分析领域中，贝塞尔曲线（英语：<span class="keyword">Bézier </span>curve）是计算机图形学中相当重要的参数曲线。更高维度的广泛化贝塞尔曲线就称作贝塞尔曲面，其中贝塞尔三角是一种特殊的实例。</div><div class="line">贝塞尔曲线于<span class="number">1962</span>年，由法国工程师皮埃尔·贝塞尔（Pierre <span class="keyword">Bézier）所广泛发表，他运用贝塞尔曲线来为汽车的主体进行设计。贝塞尔曲线最初由Paul </span>de Casteljau于<span class="number">1959</span>年运用de Casteljau算法开发，以稳定数值的方法求出贝塞尔曲线。</div></pre></td></tr></table></figure></p>
<p>有数学功底或者有兴趣的可以参考下面几篇文章， 我就不赘述了（最讨厌那种什么都要copy过来，弄得好像跟是自己写的样， 别人已经写得很清楚了， 干嘛再重复劳动一遍呢， 又没有自己的新的见解，赠人链接， 手留余香。 😁哈）。</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/B%C3%A9zier_curve" target="_blank" rel="external">https://en.wikipedia.org/wiki/B%C3%A9zier_curve</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E8%B2%9D%E8%8C%B2%E6%9B%B2%E7%B7%9A" target="_blank" rel="external">https://zh.wikipedia.org/wiki/%E8%B2%9D%E8%8C%B2%E6%9B%B2%E7%B7%9A</a></li>
<li><a href="http://www.html-js.com/article/1628" target="_blank" rel="external">http://www.html-js.com/article/1628</a></li>
<li><a href="http://www.cnblogs.com/hnfxs/p/3148483.html" target="_blank" rel="external">http://www.cnblogs.com/hnfxs/p/3148483.html</a></li>
<li></li>
</ul>
<h1 id="在线工具"><a href="#在线工具" class="headerlink" title="在线工具"></a>在线工具</h1><p>下面是几个比较有用的工具， 方便大家。</p>
<ul>
<li><a href="http://blogs.sitepointstatic.com/examples/tech/canvas-curves/quadratic-curve.html" target="_blank" rel="external">http://blogs.sitepointstatic.com/examples/tech/canvas-curves/quadratic-curve.html</a></li>
<li><a href="http://myst729.github.io/bezier-curve/" target="_blank" rel="external">http://myst729.github.io/bezier-curve/</a></li>
<li><a href="http://xuanfengge.com/easeing/ceaser/" target="_blank" rel="external">http://xuanfengge.com/easeing/ceaser/</a></li>
<li><a href="http://yisibl.github.io/cubic-bezier/#.17,.67,.83,.67" target="_blank" rel="external">http://yisibl.github.io/cubic-bezier/#.17,.67,.83,.67</a></li>
<li><a href="http://cubic-bezier.com/#.17,.67,.83,.67" target="_blank" rel="external">http://cubic-bezier.com/#.17,.67,.83,.67</a></li>
</ul>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>前面资料都是把bezier curve拿来当timing function的， 而我的需求是要让物体（某个dom节点）沿着某条beizer curve移动，于是继续google， 找到了几个。</p>
<ul>
<li>Android实现: <a href="https://github.com/Yasic/QQBubbleView" target="_blank" rel="external">https://github.com/Yasic/QQBubbleView</a></li>
</ul>
<p>Android的我用不到， 放这里主要是里面的gif图很直观，哈哈。</p>
<ul>
<li>CSS实现：<a href="http://jinlong.github.io/2016/01/14/moving-along-a-curved-path-in-css-with-layered-animation/，" target="_blank" rel="external">http://jinlong.github.io/2016/01/14/moving-along-a-curved-path-in-css-with-layered-animation/，</a> 原文：<a href="http://tobiasahlin.com/blog/curved-path-animations-in-css/" target="_blank" rel="external">http://tobiasahlin.com/blog/curved-path-animations-in-css/</a></li>
</ul>
<p>CSS的实现真是相当tricky， 我解释一下。CSS里面的animation translate是直接按照直线移动到目的地的， 这是因为沿X轴和Y轴都是匀速运动（linear），所以合成之后的速度必然是斜角45°移动过去的。我们可以把X轴看成时间轴， 这时如果Y轴的移动函数是某个beizer curve，那合成之后的移动曲线就是beizer curve了。具体实现的时候还用到了:after伪元素了。</p>
<p>复杂一点的我觉得还是需要用js去控制， 于是自然想到了用js代码去按照beizer curve公式实现。</p>
<ul>
<li>JS实现： <a href="http://blog.csdn.net/cuixiping/article/details/6872095" target="_blank" rel="external">http://blog.csdn.net/cuixiping/article/details/6872095</a></li>
</ul>
<p>这个用的公式不直观，应该是进行了变换之后的， 我直接照着公式写了一个。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function">function <span class="title">PointOnCubicBezier2</span><span class="params">(cp, t)</span>  </span>&#123;</div><div class="line">   <span class="comment">// B(t) = P0 * (1-t)^3 + 3 * P1 * t * (1-t)^2 + 3 * P2 * t^2 * (1-t) + P3 * t^3</span></div><div class="line">        <span class="keyword">const</span> <span class="keyword">one_t</span> = <span class="number">1.0</span> - t;</div><div class="line">        <span class="keyword">const</span> P0 = cp[<span class="number">0</span>];</div><div class="line">        <span class="keyword">const</span> P1 = cp[<span class="number">1</span>];</div><div class="line">        <span class="keyword">const</span> P2 = cp[<span class="number">2</span>];</div><div class="line">        <span class="keyword">const</span> P3 = cp[<span class="number">3</span>];</div><div class="line">        <span class="keyword">const</span> x =  (P0.x * Math.<span class="built_in">pow</span>(<span class="keyword">one_t</span>, <span class="number">3</span>) + <span class="number">3</span> * P1.x * t * Math.<span class="built_in">pow</span>(<span class="keyword">one_t</span>, <span class="number">2</span>) + <span class="number">3</span> * P2.x * Math.<span class="built_in">pow</span>(t, <span class="number">2</span>) * <span class="keyword">one_t</span> + P3.x * Math.<span class="built_in">pow</span>(t, <span class="number">3</span>));</div><div class="line">        <span class="keyword">const</span> y =  (P0.y * Math.<span class="built_in">pow</span>(<span class="keyword">one_t</span>, <span class="number">3</span>) + <span class="number">3</span> * P1.y * t * Math.<span class="built_in">pow</span>(<span class="keyword">one_t</span>, <span class="number">2</span>) + <span class="number">3</span> * P2.y * Math.<span class="built_in">pow</span>(t, <span class="number">2</span>) * <span class="keyword">one_t</span> + P3.y * Math.<span class="built_in">pow</span>(t, <span class="number">3</span>));</div><div class="line">        <span class="keyword">const</span> pointF = <span class="keyword">new</span> Point2D(x, y);</div><div class="line">        <span class="keyword">return</span> pointF;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对比了一下两个函数的输出值， 完全是一样的， 应该就是数学变换而已， 我懒得去做推倒了。</p>
<p>后来找到一个三阶beizer curve的实现，看这里<br><a href="https://github.com/gre/bezier-easing，" target="_blank" rel="external">https://github.com/gre/bezier-easing，</a> 这个实现可能有点NB，以至于<a href="https://facebook.github.io/react-native/" target="_blank" rel="external">React Native</a>、<a href="http://velocityjs.org/" target="_blank" rel="external">Velocity</a>等项目都使用了，屌屌的。</p>
<p>用<a href="https://github.com/bestiejs/benchmark.js" target="_blank" rel="external">benchmark</a>跑一下分：<a href="https://jsperf.com/beizer-curve5" target="_blank" rel="external">看这里</a>， chrome下我写的方法居然慢了94%！看样子代码可读性是要付出代价的哈。我还是老老实实用<a href="https://github.com/gre/bezier-easing吧。" target="_blank" rel="external">https://github.com/gre/bezier-easing吧。</a></p>
<p>刚刚又搜到一篇文章， 讲解地更细致深入， 害得我不想继续写了。 直接看这里吧。<a href="http://www.jianshu.com/p/55c721887568" target="_blank" rel="external">http://www.jianshu.com/p/55c721887568</a></p>
<h1 id="如何将多个点用贝塞尔曲线连起来"><a href="#如何将多个点用贝塞尔曲线连起来" class="headerlink" title="如何将多个点用贝塞尔曲线连起来"></a>如何将多个点用贝塞尔曲线连起来</h1><ul>
<li><a href="http://www.zheng-hang.com/?id=43" target="_blank" rel="external">http://www.zheng-hang.com/?id=43</a></li>
<li><a href="http://www.cnblogs.com/hnfxs/p/3148743.html" target="_blank" rel="external">http://www.cnblogs.com/hnfxs/p/3148743.html</a></li>
<li></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是贝塞尔曲线&quot;&gt;&lt;a href=&quot;#什么是贝塞尔曲线&quot; class=&quot;headerlink&quot; title=&quot;什么是贝塞尔曲线&quot;&gt;&lt;/a&gt;什么是贝塞尔曲线&lt;/h1&gt;&lt;p&gt;最近做一个动画效果时需要将物体做曲线移动， 本来记得css3里的动画是可以指定beizer curve的， 结果用的时候发现css3的beizer curve只用来做easing timing function。简单来说就是拿来控制动画“非线性”移动，比如越来越快（ease-in）， 越来越慢（ease-out），先慢后快再慢（ease-in-out）等， 让动画效果更“灵动”， 避免线性（linear）的死板。&lt;/p&gt;
&lt;p&gt;可以看看这两个页面， 有一个直观的感受。&lt;/p&gt;
    
    </summary>
    
      <category term="FE" scheme="http://magicly.me/categories/FE/"/>
    
    
      <category term="js" scheme="http://magicly.me/tags/js/"/>
    
      <category term="css" scheme="http://magicly.me/tags/css/"/>
    
      <category term="animation" scheme="http://magicly.me/tags/animation/"/>
    
      <category term="beizer curve" scheme="http://magicly.me/tags/beizer-curve/"/>
    
  </entry>
  
  <entry>
    <title>利用webhook实现github pages的自动部署</title>
    <link href="http://magicly.me/2015/09/16/auto-deploy-githubPages-by-webhook-md/"/>
    <id>http://magicly.me/2015/09/16/auto-deploy-githubPages-by-webhook-md/</id>
    <published>2015-09-16T10:12:39.000Z</published>
    <updated>2016-11-29T02:57:46.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://blog.coderzh.com/2015/09/13/use-webhook-automated-deploy-hugo/?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io" target="_blank" rel="external">http://blog.coderzh.com/2015/09/13/use-webhook-automated-deploy-hugo/?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io</a></p>
<p>…</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://blog.coderzh.com/2015/09/13/use-webhook-automated-deploy-hugo/?hmsr=toutiao.io&amp;amp;utm_medium=toutiao.io&amp;amp;utm_source=t
    
    </summary>
    
      <category term="default" scheme="http://magicly.me/categories/default/"/>
    
    
      <category term="github" scheme="http://magicly.me/tags/github/"/>
    
      <category term="webhook" scheme="http://magicly.me/tags/webhook/"/>
    
      <category term="ssh" scheme="http://magicly.me/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>javascript箭头函数</title>
    <link href="http://magicly.me/2015/09/07/js-arrow-functions-md/"/>
    <id>http://magicly.me/2015/09/07/js-arrow-functions-md/</id>
    <published>2015-09-07T12:48:42.000Z</published>
    <updated>2016-11-29T02:57:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>javascript es6 arrow function.</p>
<a id="more"></a>
<p>开始学习ES6.<br><a href="https://hacks.mozilla.org/category/es6-in-depth/" target="_blank" rel="external">https://hacks.mozilla.org/category/es6-in-depth/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;javascript es6 arrow function.&lt;/p&gt;
    
    </summary>
    
      <category term="JS" scheme="http://magicly.me/categories/JS/"/>
    
    
      <category term="js" scheme="http://magicly.me/tags/js/"/>
    
      <category term="javascript" scheme="http://magicly.me/tags/javascript/"/>
    
      <category term="es6" scheme="http://magicly.me/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>利用SSH反向通道在本地调试微信公共号</title>
    <link href="http://magicly.me/2015/07/26/ssh-reverse-tunnel-wx-local/"/>
    <id>http://magicly.me/2015/07/26/ssh-reverse-tunnel-wx-local/</id>
    <published>2015-07-26T03:40:25.000Z</published>
    <updated>2016-11-29T02:57:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>微信公共号现在很火，一些简单的应用，做一个公共号比开发一款app成本要小很多，而且利用朋友圈的转发，相比app去app store里上架等着用户下载，要容易很多。</p>
<p>但是微信公共号的调试有点不方便，必须在微信<a href="https://mp.weixin.qq.com/" target="_blank" rel="external">管理后台</a>配置一个微信能访问到（公网）的url，然后在公共号里输入内容，微信以xml格式转发给这个url，url回复之后微信再将response回复给使用公共号的微信用户。当然微信也提供了<a href="http://mp.weixin.qq.com/debug" target="_blank" rel="external">调试工具</a>， 可以直接构造数据，方便调试各个接口。 但是依然需要一个公网的url作为接口。于是最原始的开发方式就是，修改代码，上传到server，（如果是有些静态语言还需要重启服务器），然后看是否正常work，如果不行的话，在可能错误的地方打出log，然后又是修改代码，上传server，重启。。。。。就这样，每次改一点点，你都可以泡杯咖啡了，老板就会觉得你很闲。参看<a href="http://www.oschina.net/news/15579/reasons-why-people-who-work-with-computers-seem-to" target="_blank" rel="external">为什么搞计算机工作的人总是看上去很清闲</a>。</p>
<a id="more"></a>
<p>有没有办法可以直接在本地调试呢，简单说，就是微信把数据传到我本地的电脑上，我每次改完代码，不用重新上传server，直接在本地加log等。经过研究，找到几个方法，记录下来，与大家分享，绝对能节约很多很多很多时间，然后就可以去陪妹纸了， 如果你有的话，没有的话<a href="http://www.zhihu.com/question/20385321" target="_blank" rel="external">here</a>。</p>
<p>第一种方法，你本地电脑有公网ip。比如家里宽带，没用路由，直接把网线插上，应该就是公网IP，吧。 如果家里有多人使用，你可以再路由器里配置NAT地址转换。自行<a href="https://www.google.com.hk/webhp?sourceid=chrome-instant&amp;ion=1&amp;espv=2&amp;ie=UTF-8#q=NAT%20%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2" target="_blank" rel="external">Google</a>吧。</p>
<p>第二种，也是我搜到的最多的，用ngrok这个神器！网上一堆资料，比如<a href="http://www.mbnow.tk/2014/12/05/ngrok/" target="_blank" rel="external">这个</a>，我Google到的最多的也是这个，而且看上去也应该很简单。 <a href="http://www.oray.com/" target="_blank" rel="external">花生壳</a>我10年前用过（x，不小心暴露年龄了），应该是一样的。网上说，缺点是</p>
<blockquote>
<p>不过 ngrok 速度较慢，微信服务器对实时性要求较高，每次通信超过 5 秒便超时，所以此法也不建议使用。</p>
</blockquote>
<p>我觉得用花生壳的话可能好点，因为是国内的（有兴趣的可以自己去试试哈）。没有用ngrok试一下，因为“无法显示此网页”！网上就是“骗子”多，明明没有的网站，大家都描绘的绘声绘色。</p>
<p>第三种，用ssh建立反向通道。对了，使用此种方法，你还是需要一个公网IP的。 作为一名专业工程师，拥有公网 ip 地址的 VPS 服务器基本成了标配，<a href="http://www.qcloud.com/redirect.php?redirect=1002&amp;cps_key=0a3641075e434bf76a016a44d2918e4a" target="_blank" rel="external">腾讯云VPS</a> 最便宜的一款每年也就几百块钱，平时挂挂自己喜欢的服务，做个站长，跑跑自己的开源项目甚爽。</p>
<ol>
<li>申请<a href="http://www.qcloud.com/redirect.php?redirect=1001&amp;cps_key=0a3641075e434bf76a016a44d2918e4a" target="_blank" rel="external">腾讯云</a></li>
<li>本地安装ssh，如果是linux或mac，都是自带的。如果是windows的话，可以安装<a href="https://www.cygwin.com/" target="_blank" rel="external">Cygwin</a>，如果你嫌弃它太重了，安装了<a href="https://git-scm.com/download/gui/win" target="_blank" rel="external">Git</a>也是可以的。如果你也不想装或者不会装Git，额，(⊙o⊙)…，好吧，那你还是不要写程序了。</li>
<li>建立ssh反向通道。<br>这一步里有很多坑，我花了差不多一天才完全搞定。你们可以先参考这几篇文章，了解下原理啥的。<ul>
<li><a href="http://blog.zjutoe.net/?p=95" target="_blank" rel="external">http://blog.zjutoe.net/?p=95</a></li>
<li><a href="http://my.oschina.net/abcfy2/blog/177094" target="_blank" rel="external">http://my.oschina.net/abcfy2/blog/177094</a></li>
<li><a href="http://www.zzbaike.com/wiki/PuTTY/Putty%E5%BB%BA%E7%AB%8B%E9%9A%A7%E9%81%93%E7%9A%84%E6%96%B9%E6%B3%95" target="_blank" rel="external">http://www.zzbaike.com/wiki/PuTTY/Putty%E5%BB%BA%E7%AB%8B%E9%9A%A7%E9%81%93%E7%9A%84%E6%96%B9%E6%B3%95</a></li>
<li><a href="http://www.freeoa.net/osuport/netmanage/linux-ssh-tunneling-proxy_1892.html" target="_blank" rel="external">http://www.freeoa.net/osuport/netmanage/linux-ssh-tunneling-proxy_1892.html</a></li>
<li><a href="https://qdan.me/list/VOSXmsI4tv7fIciF" target="_blank" rel="external">https://qdan.me/list/VOSXmsI4tv7fIciF</a></li>
</ul>
</li>
</ol>
<p>好吧，来看我的具体一步一步做法。</p>
<ol>
<li><p>ssh -R 9999:localhost:9000 ubuntu@myserver_ip_address，输入密码</p>
</li>
<li><p>server上查看一下是否监听了9999端口，netstat -anltp | grep 9999</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ubuntu@VM-39-45-ubuntu:~$ netstat -anltp | grep 9999</div><div class="line">(Not all processes could be identified, non-owned process info</div><div class="line">will not be shown, you would have to be root to see it all.)</div><div class="line">tcp        0      0 127.0.0.1:9999          0.0.0.0:*               LISTEN      -</div><div class="line">tcp6       0      0 ::1:9999                :::*                    LISTEN      -</div></pre></td></tr></table></figure>
</li>
<li><p>在本地9000（我用的<a href="https://www.playframework.com/documentation/1.3.x/home" target="_blank" rel="external">play 1</a>，可以了解下它到底为啥这么好用<a href="http://segmentfault.com/a/1190000000374033" target="_blank" rel="external">Play Framework —— Java开发者的梦想框架</a>）上开启web服务</p>
</li>
<li><p>在浏览器里输入<a href="http://myserver_ip_address:9999，" target="_blank" rel="external">http://myserver_ip_address:9999，</a> 居然是没有响应！奇怪！直接在server上用curl <a href="http://localhost:9999" target="_blank" rel="external">http://localhost:9999</a> 是可以的！仔细看netstat输出，发现监听的9999端口是本地的！！！也就是说只能在本地访问，那有xx用啊！！！</p>
</li>
<li><p>看看ssh –help， 原来是可以指定bind_address的， man ssh看看</p>
<blockquote>
<p>By default, the listening socket on the server will be bound to the loopback interface only.  This may be overridden by specifying a bind_address. An empty bind_address, or the address ‘*’, indicates that the remote socket should listen on all interfaces.  Specifying a remote bind_address will only succeed if the server’s GatewayPorts option is enabled (see sshd_config(5)).</p>
</blockquote>
<p>继续看看 man sshd_config</p>
<blockquote>
<p>GatewayPorts<br>Specifies whether remote hosts are allowed to connect to ports forwarded for the client.  By default, sshd(8) binds remote port forwardings to the<br>loopback address.  This prevents other remote hosts from connecting to forwarded ports.  GatewayPorts can be used to specify that sshd should allow<br> remote port forwardings to bind to non-loopback addresses, thus allowing other hosts to connect.  The argument may be “no” to force remote port<br> forwardings to be available to the local host only, “yes” to force remote port forwardings to bind to the wildcard address, or “clientspecified” to<br> allow the client to select the address to which the forwarding is bound.  The default is “no”.</p>
</blockquote>
<p>sudo vim /etc/ssh/sshd_config，添加GatewayPorts clientspecified，GatewayPorts yes也可以，退出，sudo service sshd restart，重启ssh服务。重新ssh -R :9999:localhost:9000 ubuntu@myserver_ip_address（仔细看，就9999前多了一个冒号:），输入密码，netstat -anltp | grep 9999，果然</p>
 <figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">tcp</span>        0      0 0<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-pseudo">:9999</span>            0<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.0</span>:*               <span class="selector-tag">LISTEN</span>      <span class="selector-tag">-</span></div><div class="line"><span class="selector-tag">tcp6</span>       0      0 :<span class="selector-pseudo">::9999</span>                 :::*                    <span class="selector-tag">LISTEN</span>      <span class="selector-tag">-</span></div></pre></td></tr></table></figure>
<p> 浏览器里输入<a href="http://myserver_ip_address:9999，" target="_blank" rel="external">http://myserver_ip_address:9999，</a> 这回可以看到本地打出日志了。</p>
</li>
<li><p>然后发现微信里面配置的url只能是80端口。简单，直接改成ssh -R :80:localhost:9000 ubuntu@myserver_ip_address就可以了，吧！奇怪，直接访问<a href="http://myserver_ip_address，" target="_blank" rel="external">http://myserver_ip_address，</a> 打不开网页！用netstat -anltp | grep 80，居然什么都没有！说明server没有在80端口监听呀！哦，对了ubuntu低于1024的端口是需要用root权限的。</p>
</li>
<li><p>ubuntu里root默认是关闭的。sudo passwd root，设置root密码后，可以打开。还需要在sudo vim /etc/ssh/sshd_config    添加</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#PermitRootLogin without-password</span></div><div class="line"><span class="attribute">PermitRootLogin</span> <span class="literal">yes</span></div></pre></td></tr></table></figure>
</li>
<li><p>重启ssh，再重新用root账号连接，ssh -R :80:localhost:9000 root@myserver_ip_address， 一切ok，<a href="http://myserver_ip_address，" target="_blank" rel="external">http://myserver_ip_address，</a> 本地代码打出日志，说明流量已经导入到本地了。</p>
</li>
<li>最后，就可以在<a href="http://mp.weixin.qq.com/debug" target="_blank" rel="external">微信公众平台接口调试工具</a>里调试了，配合<a href="http://playframework.com/" target="_blank" rel="external">Play!</a>的hot reload，随时修改代码，加log，然后马上就可以看到效果，不用重新编译，不用上传server，不用重启。。。。生活真是幸福美满啊。。。。</li>
<li>几个问题说明：<ol>
<li>直接用ssh连接的话，断开之后端口映射就没有了，可以用autossh， 只是我就是临时需要调试用的时候才ssh建立反向隧道，所以我不用autossh。</li>
<li>直接用root登陆ssh，开通80端口。应该是有安全隐患的， 吧！对安全不是很了解，但感觉直接用root肯定不是最佳实践。网上有各种方法解决这个问题，比如用iptables端口映射，或者nginx反向代理的，<a href="http://stackoverflow.com/questions/23281895/node-js-eacces-error-when-listening-on-http-80-port-permission-denied" target="_blank" rel="external">看这里</a>，参看1的原因，我没有采用。还是一次focus一个点吧，不然光环境就配置几天，有点太慢了。</li>
</ol>
</li>
</ol>
<p>通过本文的配置，可以在本地方便的开发调试微信公共号了。但是对于微信提供的<a href="http://mp.weixin.qq.com/wiki/7/aaa137b55fb2e0456bf8dd9148dd613f.html" target="_blank" rel="external">JS-SDK</a>，又存在另外的问题，这个我会<a href="http://my.oschina.net/magicly007/blog/480704" target="_blank" rel="external">另外写一篇blog来解决</a>。毕竟，我们程序员应该坚持<a href="https://en.wikipedia.org/wiki/Single_responsibility_principle" target="_blank" rel="external">Single responsibility principle</a>嘛。</p>
<p>Refs</p>
<ol>
<li><a href="http://www.mbnow.tk/2014/12/05/ngrok/" target="_blank" rel="external">http://www.mbnow.tk/2014/12/05/ngrok/</a></li>
<li><a href="http://my.oschina.net/jfinal/blog/336861" target="_blank" rel="external">http://my.oschina.net/jfinal/blog/336861</a></li>
<li><a href="http://www.mbnow.tk/2014/12/05/ngrok/" target="_blank" rel="external">http://www.mbnow.tk/2014/12/05/ngrok/</a></li>
<li><a href="http://liyaodong.com/2015/07/06/%E5%BE%AE%E4%BF%A1%E8%B0%83%E8%AF%95%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/" target="_blank" rel="external">http://liyaodong.com/2015/07/06/%E5%BE%AE%E4%BF%A1%E8%B0%83%E8%AF%95%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/</a></li>
<li><a href="http://my.oschina.net/abcfy2/blog/177094" target="_blank" rel="external">http://my.oschina.net/abcfy2/blog/177094</a></li>
<li><a href="http://www.zhihu.com/question/25456655" target="_blank" rel="external">http://www.zhihu.com/question/25456655</a></li>
<li>. <a href="http://my.oschina.net/atanl/blog/391611" target="_blank" rel="external">http://my.oschina.net/atanl/blog/391611</a></li>
</ol>
<blockquote>
<p>Written with <a href="https://stackedit.io/" target="_blank" rel="external">StackEdit</a>.</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;微信公共号现在很火，一些简单的应用，做一个公共号比开发一款app成本要小很多，而且利用朋友圈的转发，相比app去app store里上架等着用户下载，要容易很多。&lt;/p&gt;
&lt;p&gt;但是微信公共号的调试有点不方便，必须在微信&lt;a href=&quot;https://mp.weixin.qq.com/&quot;&gt;管理后台&lt;/a&gt;配置一个微信能访问到（公网）的url，然后在公共号里输入内容，微信以xml格式转发给这个url，url回复之后微信再将response回复给使用公共号的微信用户。当然微信也提供了&lt;a href=&quot;http://mp.weixin.qq.com/debug&quot;&gt;调试工具&lt;/a&gt;， 可以直接构造数据，方便调试各个接口。 但是依然需要一个公网的url作为接口。于是最原始的开发方式就是，修改代码，上传到server，（如果是有些静态语言还需要重启服务器），然后看是否正常work，如果不行的话，在可能错误的地方打出log，然后又是修改代码，上传server，重启。。。。。就这样，每次改一点点，你都可以泡杯咖啡了，老板就会觉得你很闲。参看&lt;a href=&quot;http://www.oschina.net/news/15579/reasons-why-people-who-work-with-computers-seem-to&quot;&gt;为什么搞计算机工作的人总是看上去很清闲&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="weixin" scheme="http://magicly.me/categories/weixin/"/>
    
    
      <category term="ssh" scheme="http://magicly.me/tags/ssh/"/>
    
      <category term="weixin" scheme="http://magicly.me/tags/weixin/"/>
    
      <category term="微信" scheme="http://magicly.me/tags/%E5%BE%AE%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>我的第一个hexo Blog</title>
    <link href="http://magicly.me/2015/07/26/my-first-hexo-blog/"/>
    <id>http://magicly.me/2015/07/26/my-first-hexo-blog/</id>
    <published>2015-07-26T03:09:45.000Z</published>
    <updated>2016-11-29T02:57:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>引用<a href="http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html" target="_blank" rel="external">阮老师</a>的话，</p>
<blockquote>
<p>喜欢写Blog的人，会经历三个阶段。</p>
<pre><code>第一阶段，刚接触Blog，觉得很新鲜，试着选择一个免费空间来写。
第二阶段，发现免费空间限制太多，就自己购买域名和空间，搭建独立博客。
第三阶段，觉得独立博客的管理太麻烦，最好在保留控制权的前提下，让别人来管，自己只负责写文章。
</code></pre></blockquote>
<p>自己比较懒惰，也就偶尔在<a href="http://my.oschina.net/magicly007/blog" target="_blank" rel="external">OC</a>上写点闲散的笔记，最近觉得还是应该要把自己的知识系统地梳理一下，便决定开一个独立的域名，自己记录Blog。</p>
<p>之前就了解Github Pages，也断断续续用MarkDown写过几篇放着，但是没有用<a href="http://jekyllrb.com/" target="_blank" rel="external">jekyll</a>，或者<a href="http://octopress.org/" target="_blank" rel="external">octpress</a>等串起来，上个月再次想配置好jekyll，结果在mac下始终配置不好（怪我咯）。今天决定一定要配置好，搜集了大量资料（google “jekyll 像黑客一样”），结果意外在<a href="http://www.douban.com/group/topic/39939196/" target="_blank" rel="external">http://www.douban.com/group/topic/39939196/</a>的回复中看到“用pelican吧 python的 还有hexo是nodejs的 ”。因为最近刚好在看nodejs，觉得很有兴趣，于是改为尝试<a href="https://hexo.io/zh-cn/" target="_blank" rel="external">hexo</a>。</p>
<a id="more"></a>
<p>#简介</p>
<p><a href="http://ibruce.info/2013/11/22/hexo-your-blog/" target="_blank" rel="external">http://ibruce.info/2013/11/22/hexo-your-blog/</a></p>
<blockquote>
<p>hexo出自台湾大学生<a href="https://twitter.com/tommy351" target="_blank" rel="external">tommy351</a>之手，是一个基于<a href="https://nodejs.org/" target="_blank" rel="external">Node.js</a>的静态博客程序，其编译上百篇文字只需要几秒。hexo生成的静态网页可以直接放到GitHub Pages，BAE，SAE等平台上。先看看tommy是如何吐槽Octopress的 →＿→ <a href="http://zespia.tw/blog/2012/10/11/hexo-debut/" target="_blank" rel="external">Hexo颯爽登場</a>。</p>
</blockquote>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>首先安装Node.js，然后运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">npm install -g hexo-cli</div><div class="line">npm install hexo --save</div></pre></td></tr></table></figure></p>
<h1 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hexo init</div><div class="line">npm install</div></pre></td></tr></table></figure>
<h1 id="写blog"><a href="#写blog" class="headerlink" title="写blog"></a>写blog</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo n</div></pre></td></tr></table></figure>
<h1 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo g</div></pre></td></tr></table></figure>
<h1 id="本地预览"><a href="#本地预览" class="headerlink" title="本地预览"></a>本地预览</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo s</div></pre></td></tr></table></figure>
<h1 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo d</div></pre></td></tr></table></figure>
<p>实在觉得没必<a href="https://en.wikipedia.org/wiki/Reinventing_the_wheel" target="_blank" rel="external">重复造轮子</a>，重写已经有很详细资料的东西。强烈推荐<a href="http://ibruce.info/2013/11/22/hexo-your-blog/" target="_blank" rel="external">这篇</a>。 我觉得基本涵盖了方方面面，如果以后有新东西这里面没有的，我再写吧~</p>
<p>Refs</p>
<ol>
<li><a href="http://ibruce.info/2013/11/22/hexo-your-blog/" target="_blank" rel="external">http://ibruce.info/2013/11/22/hexo-your-blog/</a></li>
<li><a href="http://wsgzao.github.io/post/hexo-guide/" target="_blank" rel="external">http://wsgzao.github.io/post/hexo-guide/</a></li>
<li><a href="http://www.jianshu.com/p/05289a4bc8b2" target="_blank" rel="external">http://www.jianshu.com/p/05289a4bc8b2</a></li>
<li><a href="http://yangjian.me/workspace/building-blog-with-hexo/" target="_blank" rel="external">http://yangjian.me/workspace/building-blog-with-hexo/</a></li>
<li><a href="http://yangjian.me/workspace/building-blog-with-hexo/" target="_blank" rel="external">http://yangjian.me/workspace/building-blog-with-hexo/</a></li>
<li><a href="http://blog.csdn.net/jackystudio/article/details/16117585" target="_blank" rel="external">http://blog.csdn.net/jackystudio/article/details/16117585</a></li>
</ol>
<blockquote>
<p>Written with <a href="https://stackedit.io/" target="_blank" rel="external">StackEdit</a>.</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引用&lt;a href=&quot;http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html&quot;&gt;阮老师&lt;/a&gt;的话，&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;喜欢写Blog的人，会经历三个阶段。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;第一阶段，刚接触Blog，觉得很新鲜，试着选择一个免费空间来写。
第二阶段，发现免费空间限制太多，就自己购买域名和空间，搭建独立博客。
第三阶段，觉得独立博客的管理太麻烦，最好在保留控制权的前提下，让别人来管，自己只负责写文章。
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;自己比较懒惰，也就偶尔在&lt;a href=&quot;http://my.oschina.net/magicly007/blog&quot;&gt;OC&lt;/a&gt;上写点闲散的笔记，最近觉得还是应该要把自己的知识系统地梳理一下，便决定开一个独立的域名，自己记录Blog。&lt;/p&gt;
&lt;p&gt;之前就了解Github Pages，也断断续续用MarkDown写过几篇放着，但是没有用&lt;a href=&quot;http://jekyllrb.com/&quot;&gt;jekyll&lt;/a&gt;，或者&lt;a href=&quot;http://octopress.org/&quot;&gt;octpress&lt;/a&gt;等串起来，上个月再次想配置好jekyll，结果在mac下始终配置不好（怪我咯）。今天决定一定要配置好，搜集了大量资料（google “jekyll 像黑客一样”），结果意外在&lt;a href=&quot;http://www.douban.com/group/topic/39939196/&quot;&gt;http://www.douban.com/group/topic/39939196/&lt;/a&gt;的回复中看到“用pelican吧 python的 还有hexo是nodejs的 ”。因为最近刚好在看nodejs，觉得很有兴趣，于是改为尝试&lt;a href=&quot;https://hexo.io/zh-cn/&quot;&gt;hexo&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="default" scheme="http://magicly.me/categories/default/"/>
    
    
      <category term="github" scheme="http://magicly.me/tags/github/"/>
    
      <category term="hexo" scheme="http://magicly.me/tags/hexo/"/>
    
      <category term="githubPages" scheme="http://magicly.me/tags/githubPages/"/>
    
  </entry>
  
  <entry>
    <title>Java发送邮件</title>
    <link href="http://magicly.me/2015/07/13/java-email/"/>
    <id>http://magicly.me/2015/07/13/java-email/</id>
    <published>2015-07-13T13:34:10.000Z</published>
    <updated>2016-11-29T02:57:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>需要在代码里面发邮件是很经常的事情，包括找回密码，通知用户领奖，监控报警等。</p>
<p>在Java里面实现比较简单，Oracle自己提供了<a href="http://www.oracle.com/technetwork/java/javasebusiness/downloads/java-archive-downloads-eeplat-419426.html#javamail-1.4.7-oth-JPR" target="_blank" rel="external">JavaMail</a>， 不过API比较底层，用起来不方便，可以自己封装下，也可以直接使用Apache的开源项目<a href="https://commons.apache.org/proper/commons-email/" target="_blank" rel="external">Commons Email</a>。 下面的代码，可以以小马哥的名义给自己发邮件，该功能仅用于测试，请谨慎使用，产生的问题，本人概不负责。 /微笑</p>
<a id="more"></a>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="meta"><span class="meta-keyword">import</span> org.apache.commons.mail.EmailAttachment;</span></div><div class="line"><span class="meta"><span class="meta-keyword">import</span> org.apache.commons.mail.EmailException;</span></div><div class="line"><span class="meta"><span class="meta-keyword">import</span> org.apache.commons.mail.MultiPartEmail;</span></div><div class="line"></div><div class="line"><span class="meta"><span class="meta-keyword">import</span> java.net.MalformedURLException;</span></div><div class="line"><span class="meta"><span class="meta-keyword">import</span> java.net.URL;</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by magicalli on 2015/7/6.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiPartEmailTest</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) throws EmailException, MalformedURLException &#123;</div><div class="line">        MultiPartEmail email = <span class="keyword">new</span> MultiPartEmail();</div><div class="line"></div><div class="line">        email.setHostName(<span class="string">"smtp.tencent.com"</span>);</div><div class="line"><span class="comment">//        email.setAuthentication("youremail@tencent.com", "***");//邮件服务器验证：用户名/密码</span></div><div class="line">        email.setCharset(<span class="string">"UTF-8"</span>);</div><div class="line"></div><div class="line">        email.setFrom(<span class="string">"pony@qq.com"</span>, <span class="string">"马化腾"</span>);</div><div class="line">        email.addTo(<span class="string">"magicalli@tencent.com"</span>);</div><div class="line"></div><div class="line">        email.setSubject(<span class="string">"加油奋斗！"</span>);</div><div class="line">        email.setMsg(<span class="string">"come on! 加油奋斗吧，早晚有一天你会出任CEO，迎娶白富美，走上人生巅峰！ http://www.qq.com\n\n\n pony"</span>);</div><div class="line"></div><div class="line">        EmailAttachment attachment = <span class="keyword">new</span> EmailAttachment();</div><div class="line">        attachment.setPath(<span class="string">"d:/lzl.jpg"</span>);<span class="comment">// 本地文件</span></div><div class="line">        attachment.setDisposition(EmailAttachment.ATTACHMENT);</div><div class="line">        attachment.setDescription(<span class="string">"林志玲1"</span>);</div><div class="line">        attachment.setName(<span class="string">"lzl_1"</span>);</div><div class="line">        email.attach(attachment);</div><div class="line"></div><div class="line">        EmailAttachment attachment2 = <span class="keyword">new</span> EmailAttachment();</div><div class="line">        attachment2.setURL(<span class="keyword">new</span> URL(<span class="string">"http://mat1.qq.com/datalib_img/star/pic/lib/2007-01-15/2007011511104716122311.jpg"</span>));<span class="comment">//远程文件, 如果不是qq.com域名下，内网是访问不了的哈</span></div><div class="line">        attachment2.setDisposition(EmailAttachment.ATTACHMENT);</div><div class="line">        attachment2.setDescription(<span class="string">"林志玲2"</span>);</div><div class="line">        attachment2.setName(<span class="string">"lzl_2"</span>);</div><div class="line">        email.attach(attachment2);</div><div class="line"></div><div class="line">        email.send();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://commons.apache.org/proper/commons-email/" target="_blank" rel="external">Commons Email</a>支持好几种格式，包括简单文本，html，带附件等。需要的可以自己查看文档。</p>
<p>基于smtp的协议邮件协议很简单，大家甚至可以直接用telnet来发送，可以参考这边文章<a href="http://blog.csdn.net/ghsau/article/details/8602076" target="_blank" rel="external">Java Mail(一)：telnet实现发送收取邮件</a>. </p>
<p>一般公司内网没有验证发送方，你可以冒充公司任何一个员工发送邮件（包括你们老板），一般外面的邮件服务器，比如qq, 126, 163等，是需要验证密码的。</p>
<p>重申一遍，别用这个代码干坏事，后果自负， 与本人无关！</p>
<p>Refs</p>
<ol>
<li><a href="http://blog.csdn.net/ghsau/article/details/8602076" target="_blank" rel="external">http://blog.csdn.net/ghsau/article/details/8602076</a></li>
<li><a href="http://blog.csdn.net/ghsau/article/details/17839983" target="_blank" rel="external">http://blog.csdn.net/ghsau/article/details/17839983</a></li>
<li><a href="http://haolloyin.blog.51cto.com/1177454/354320" target="_blank" rel="external">http://haolloyin.blog.51cto.com/1177454/354320</a></li>
<li><a href="http://www.runoob.com/java/java-sending-email.html" target="_blank" rel="external">http://www.runoob.com/java/java-sending-email.html</a></li>
<li><a href="https://commons.apache.org/proper/commons-email/" target="_blank" rel="external">https://commons.apache.org/proper/commons-email/</a></li>
<li><a href="http://blog.csdn.net/qiaqia609/article/details/11580589" target="_blank" rel="external">http://blog.csdn.net/qiaqia609/article/details/11580589</a></li>
</ol>
<blockquote>
<p>Written with <a href="https://stackedit.io/" target="_blank" rel="external">StackEdit</a>.</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      this is desc.
    
    </summary>
    
      <category term="Java" scheme="http://magicly.me/categories/Java/"/>
    
    
      <category term="Java" scheme="http://magicly.me/tags/Java/"/>
    
      <category term="Email" scheme="http://magicly.me/tags/Email/"/>
    
      <category term="JavaMail" scheme="http://magicly.me/tags/JavaMail/"/>
    
      <category term="Apache Commons" scheme="http://magicly.me/tags/Apache-Commons/"/>
    
  </entry>
  
  <entry>
    <title>一个Java对象到底有多大</title>
    <link href="http://magicly.me/2015/06/13/how-big-is-a-java-object/"/>
    <id>http://magicly.me/2015/06/13/how-big-is-a-java-object/</id>
    <published>2015-06-13T13:34:10.000Z</published>
    <updated>2017-03-10T05:28:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>经常遇到一个问题，需要在内存里缓存一批数据来提高效率（避免每次都读取DB）。那问题来了，这些对象到底会占用多大内存呢，这直接决定了可以缓存多少条记录，以及上线之后是否会内存不够等问题。</p>
<p>来看几种解决方法。</p>
<a id="more"></a>
<p>#测试</p>
<p>实践是检验真理的唯一标准！比如你要想cache10w条记录，那你就把10w条记录加载到内存，然后看看到底用了多少内存。至于怎么看内存花了多少，你可以</p>
<ol>
<li>任务管理器</li>
<li>top</li>
<li>Java Runtime类</li>
<li>blabla。。。。</li>
</ol>
<p>我们来看看直接从Java程序里能获取到的Runtime。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.*;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by magicalli on 2015/2/3.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> class TestMemory &#123;</div><div class="line">    <span class="keyword">static</span> class A &#123;</div><div class="line">        <span class="built_in">int</span> a;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">        System.out.<span class="built_in">println</span>(<span class="string">"--- Memory Usage ---:"</span>);</div><div class="line">        Runtime rt = Runtime.getRuntime();</div><div class="line">        <span class="comment">//打印总内存大小 //打印空闲内存大小 //打印已用内存大小 单位(字节)</span></div><div class="line">        <span class="keyword">long</span> usedMemory = rt.totalMemory() - rt.freeMemory();</div><div class="line">        System.out.<span class="built_in">println</span>(<span class="string">"Total Memory= "</span> + rt.totalMemory() + <span class="string">" Free Memory = "</span> + rt.freeMemory() + <span class="string">" Used　Memory="</span> + usedMemory);</div><div class="line"></div><div class="line">        <span class="comment">// 把你要测试的占用内存的代码放在这里------start--------------</span></div><div class="line">        <span class="keyword">final</span> <span class="built_in">int</span> N = <span class="number">100000</span>;</div><div class="line">        <span class="built_in">int</span>[] arr = <span class="keyword">new</span> <span class="built_in">int</span>[N];</div><div class="line">        Integer[] arr2 = <span class="keyword">new</span> Integer[N];</div><div class="line">        A[] arrA = <span class="keyword">new</span> A[N];</div><div class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</div><div class="line">            arr[i] = i;</div><div class="line"><span class="comment">//            arr2[i] = i;</span></div><div class="line"><span class="comment">//            arrA[i] = new A();</span></div><div class="line">        &#125;</div><div class="line"><span class="comment">//        List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span></div><div class="line">        Map&lt;Integer, <span class="keyword">String</span>&gt; <span class="built_in">map</span> = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;Integer, <span class="keyword">String</span>&gt;();</div><div class="line"><span class="comment">//        for (int i = 0; i &lt; N; i++) &#123;</span></div><div class="line"><span class="comment">//            list.add(i);</span></div><div class="line"><span class="comment">//            map.put(i, UUID.randomUUID().toString());</span></div><div class="line"><span class="comment">//        &#125;</span></div><div class="line"><span class="comment">//        System.out.println(map.size());</span></div><div class="line">        <span class="comment">// 把你要测试的占用内存的代码放在这里------end--------------</span></div><div class="line"></div><div class="line">        <span class="keyword">long</span> usedMemory2 = rt.totalMemory() - rt.freeMemory();</div><div class="line">        System.out.<span class="built_in">println</span>(<span class="string">"Total Memory= "</span> + rt.totalMemory() + <span class="string">" Free Memory = "</span> + rt.freeMemory() + <span class="string">" Used　Memory="</span> + usedMemory2);</div><div class="line">        <span class="keyword">long</span> objMemory = usedMemory2 - usedMemory;</div><div class="line">        System.out.<span class="built_in">println</span>(<span class="string">"object use memory: "</span> + objMemory / <span class="number">1024</span> + <span class="string">"k"</span> + <span class="string">" each is: "</span> + objMemory / N);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面方法的最大好处就是可以直接获得实际占用内存大小，是比较简单有效的方法。不好的地方就是如果数据量比较小，可能偏差比较大，而且你也不能解释为什么Integer[]比int[]占用内存大很多，关键是专家说：这种内存占用应该是心里算出来的，你还要去run一下程序，明显就low了，还想晋级？再练练吧！所以我们来看看怎么掐指一算！</p>
<p>#计算</p>
<p>这个需要了解JVM里的内存分布，知道每个对象都有object header，blabal。这里推荐一篇好文<a href="http://www.cnblogs.com/magialmoon/p/3757767.html" target="_blank" rel="external">一个Java对象到底占用多大内存？</a>，我就不重复了。</p>
<p>还看到另一种计算方式，用的Unsafe，不过感觉没有前面用Instrumentation的好。参考这里<a href="http://blog.csdn.net/bobpauline/article/details/20699233" target="_blank" rel="external">Java计算一个对象占用内存的大小</a></p>
<p>#线上查看</p>
<p>如果是要查看线上程序哪个对象占用了大量内存（比如分析内存泄露），那么可以使用jmap。</p>
<p>#相关知识<br>你可能需要了解jps，jinfo，打包jar，manifest，查看jvm运行参数等。</p>
<p>#refers</p>
<ol>
<li><a href="http://www.importnew.com/14948.html" target="_blank" rel="external">http://www.importnew.com/14948.html</a></li>
<li><a href="http://www.cnblogs.com/magialmoon/p/3757767.html" target="_blank" rel="external">http://www.cnblogs.com/magialmoon/p/3757767.html</a></li>
<li><a href="http://www.oschina.net/question/1_4486" target="_blank" rel="external">http://www.oschina.net/question/1_4486</a></li>
<li><a href="http://blog.csdn.net/bobpauline/article/details/20699233" target="_blank" rel="external">http://blog.csdn.net/bobpauline/article/details/20699233</a></li>
<li><a href="http://happyqing.iteye.com/blog/2013639" target="_blank" rel="external">http://happyqing.iteye.com/blog/2013639</a></li>
<li><a href="http://sunqi.iteye.com/blog/1917802" target="_blank" rel="external">http://sunqi.iteye.com/blog/1917802</a></li>
<li><a href="http://www.blogjava.net/stone2083/archive/2013/06/08/400410.html" target="_blank" rel="external">http://www.blogjava.net/stone2083/archive/2013/06/08/400410.html</a></li>
<li><a href="http://yueyemaitian.iteye.com/blog/2033046" target="_blank" rel="external">http://yueyemaitian.iteye.com/blog/2033046</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/java/j-lo-jse61/index.html" target="_blank" rel="external">http://www.ibm.com/developerworks/cn/java/j-lo-jse61/index.html</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/java/j-lo-instrumentation/" target="_blank" rel="external">http://www.ibm.com/developerworks/cn/java/j-lo-instrumentation/</a></li>
</ol>
<blockquote>
<p>Written with <a href="https://stackedit.io/" target="_blank" rel="external">StackEdit</a>.</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;经常遇到一个问题，需要在内存里缓存一批数据来提高效率（避免每次都读取DB）。那问题来了，这些对象到底会占用多大内存呢，这直接决定了可以缓存多少条记录，以及上线之后是否会内存不够等问题。&lt;/p&gt;
&lt;p&gt;来看几种解决方法。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://magicly.me/categories/Java/"/>
    
    
      <category term="Java" scheme="http://magicly.me/tags/Java/"/>
    
      <category term="JVM" scheme="http://magicly.me/tags/JVM/"/>
    
      <category term="Java反射" scheme="http://magicly.me/tags/Java%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>J.U.C源码解读之atomic</title>
    <link href="http://magicly.me/2015/01/13/juc-source-code-read-atomic/"/>
    <id>http://magicly.me/2015/01/13/juc-source-code-read-atomic/</id>
    <published>2015-01-13T13:34:10.000Z</published>
    <updated>2016-11-29T02:57:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>java5之后的java.util.concurrent包是世界级并发大师Doug Lea的作品，里面主要实现了</p>
<ol>
<li>atomic包里Integer/Long对应的原子类，主要基于CAS；</li>
<li>一些同步子，包括Lock，CountDownLatch，Semaphore，FutureTask等，这些都是基于AbstractQueuedSynchronizer类；</li>
<li>关于线程执行的Executors类等；</li>
<li>一些并发的集合类，比如ConcurrentHashMap，ConcurrentLinkedQueue，CopyOnWriteArrayList等。</li>
</ol>
<p>今天我们主要介绍atomic包下相关内容。</p>
<a id="more"></a>
<p>#CAS</p>
<p>atomic包下的类主要基于现代主流 CPU 都支持的一种指令，Compare and Swap（CAS），这个指令能为多线程编程带来更好的性能。引用《Java Concurrency in Practice》里的一段描述：</p>
<blockquote>
<p>在这里，CAS 指的是现代 CPU 广泛支持的一种对内存中的共享数据进行操作的一种特殊指令。这个指令会对内存中的共享数据做原子的读写操作。简单介绍一下这个指令的操作过程：首先，CPU 会将内存中将要被更改的数据与期望的值做比较。然后，当这两个值相等时，CPU 才会将内存中的数值替换为新的值。否则便不做操作。最后，CPU 会将旧的数值返回。这一系列的操作是原子的。它们虽然看似复杂，但却是 Java 5 并发机制优于原有锁机制的根本。简单来说，CAS 的含义是“我认为原有的值应该是什么，如果是，则将原有的值更新为新值，否则不做修改，并告诉我原来的值是多少”。</p>
</blockquote>
<p>#AtomicInteger<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> <span class="keyword">value</span>;</div></pre></td></tr></table></figure></p>
<p>AtomicInteger里面只包含一个字段，用来记录当前值，定义为volatile是为了满足<strong>可见性</strong>。<br><figure class="highlight d"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// setup to use Unsafe.compareAndSwapInt for updates</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">long</span> valueOffset;</div><div class="line"></div><div class="line">  <span class="keyword">static</span> &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      valueOffset = unsafe.objectFieldOffset</div><div class="line">          (AtomicInteger.<span class="keyword">class</span>.getDeclaredField(<span class="string">"value"</span>));</div><div class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>一开始定义了static变量Unsafe，AtomicInteger里面的方法都是对unsafe里面<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</div></pre></td></tr></table></figure></p>
<p>方法的封装。<br>我们来看原子性的i++，<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> getAndIncrement() &#123;</div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        <span class="keyword">int</span> current = get();</div><div class="line">        <span class="keyword">int</span> <span class="keyword">next</span> = current + <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (compareAndSet(current, <span class="keyword">next</span>))</div><div class="line">            <span class="keyword">return</span> current;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在一个无限循环里面，首先获取当前值，用当前值+1，然后调用<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">return</span> unsafe.<span class="title">compareAndSwapInt</span><span class="params">(<span class="keyword">this</span>, valueOffset, expect, update)</span></span>;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>unsafe.compareAndSwapInt(this, valueOffset, expect, update)的含义是把this对象里面valueOffset（在一开始static代码里面获取）这个位置（即value值）跟expect比较，如果相等，则修改为update，返回true；如果不相等，说明在获取到current之后有其他线程修改过value的值，则重新来一遍，一直到修改成功为止。这里就可以看出，理论上来说，这个方法是有可能永远不能返回的，实际而言，当并发冲突很严重，反复compareAndSet(current, next)失败，有可能也需要花费很多时间。</p>
<p>AtomicInteger里面的其他方法，基本类似；其他类包括AtomicLong，AtomicReference等也是基本对Unsafe里面compareAndSet的一个封装。</p>
<p>#Unsafe</p>
<p>前面可以看到Unsafe类在实现atomic的重要性。为什么有Unsafe这个class呢，基本原因是Java不允许代码直接操作内存，好处是更安全，一般不会出现内存泄露，因为有JVM的GC；坏处是有些底层调用执行不了。我的理解是，Unsafe就是这个java安全围城通向比如c++这个不安全外围的一道门，所以叫Unsafe嘛。Unsafe里面基本都是native，即通过JNI调用c/c++等代码。大部分是直接内存操作，以及后面会讲到的挂起唤醒线程等，包括park和unpark。</p>
<p>前面到<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</div></pre></td></tr></table></figure></p>
<p>这个方法就不是java代码了，如果想看实现的话，需要下载OpenJDK源码，里面是c++代码调用汇编代码，blabla。我不建议大家再往下继续了，原因有几个，一是我们用java等高级语言的目的就是为了避免纠结复杂的底层细节，站在更高层的角度思考问题，而且java里面还有更多的问题等待你去解决，更多的知识可以学习呢！如果你说你已经把java完全掌握了，包括把jdk源码，tomcat、spring，xxxxx源码都看过了，实在没得看了，那我会说，多陪陪家人吧~除非你是JVM开发工程师，哦，那不好意思，大神，当我啥都没说。。。。为了完整性，我贴几个参考链接<a href="http://www.blogjava.net/mstar/archive/2013/04/24/398351.html" target="_blank" rel="external">http://www.blogjava.net/mstar/archive/2013/04/24/398351.html</a>, <a href="http://zl198751.iteye.com/blog/1848575" target="_blank" rel="external">http://zl198751.iteye.com/blog/1848575</a>.</p>
<p>那么如果获取Unsafe呢？Unsafe有一个static方法可以获取Unsafe实例，如下<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function">Unsafe <span class="title">getUnsafe</span><span class="params">()</span> </span>&#123;</div><div class="line">       Class var0 = Reflection.getCallerClass(<span class="number">2</span>);</div><div class="line">       <span class="keyword">if</span>(var0.getClassLoader() != <span class="keyword">null</span>) &#123;</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"Unsafe"</span>);</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           <span class="keyword">return</span> theUnsafe;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>可是你如果在自己代码里使用，可以编译通过，但是运行时候报错。因为里面限制了调用getUnsafe()这个方法的类必须是启动类加载器Bootstrap Loader。所以如果想在自己代码里面调用Unsafe的话（强烈建议不要这样子做），可以用Java的反射来实现：</p>
<pre><code>    static class UnsafeSupport {
        private static Unsafe unsafe;

        static {
            Field field;
            try {
                // 由反编译Unsafe类获得的信息
                field = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);
                field.setAccessible(true);
                // 获取静态属性,Unsafe在启动JVM时随rt.jar装载
                unsafe = (Unsafe) field.get(null);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        public static Unsafe getInstance() {
//            return Unsafe.getUnsafe();//没有用，只能native获取，否则会抛异常
            return unsafe;
        }
    }
</code></pre><p>获取到了Unsafe的实例之后，你照样可以自己实现Atomic类，再说一遍，强烈建议不要这样做！！！</p>
<p>#CAS优点</p>
<p>Compare and Set 是一个非阻塞的算法，这是它的优势。因为使用的是CPU支持的指令，提供了比原有的并发机制更好的性能和伸缩性。可以认为一般情况下性能更好，并且也更容易使用（这才是关键啊）。</p>
<p>#CAS缺点</p>
<p>##ABA问题</p>
<p>CAS操作容易导致ABA问题,也就是在做a++之间，a可能被多个线程修改过了，只不过回到了最初的值，这时CAS会认为a的值没有变。a在外面逛了一圈回来，你能保证它没有做任何坏事，不能！！也许它讨闲，把b的值减了一下，把c的值加了一下等等。解决ABA问题的方法有很多，可以考虑增加一个修改计数（版本号），只有修改计数不变的且a值不变的情况下才做a++，atomic包下有AtomicStampedReference类做这个事情，这和事务原子性处理有点类似！</p>
<p>##循环时间长开销大</p>
<ol>
<li>即使没有任何争用也会做一些无用功</li>
<li>如果冲突比较严重的话，可能导致多次修改失败，for循环时间很长，可能比同步还慢</li>
</ol>
<p>我在自己的电脑上用100个线程去修改一个共享变量，发现用AtomicInteger就比synchronized慢，但是都很快！所以还是那个建议，不要过早优化，不要纠结到底是1ms还是2ms，除非测试之后发现确实是性能瓶颈，然后再仔细看一下，是不是代码的使用有问题，要相信，能写到JDK里的代码，一般都不会有问题。一般不到一天几千万上亿的PV，应该是没啥问题的。而且JVM对synchronized做了很多优化，包括锁去除（Lock Elimination），轻量级锁，偏向锁等，所以写代码的时候首先还是主要考虑代码正确、清晰、可维护。</p>
<p>##只能保证一个共享变量的原子操作</p>
<p>如果并发约束条件涉及到两个变量，就不能用两个原子变量来达到整体的原子性，还是得用同步。当然你也可以用一个变通的方法，定义一个class，里面包含约束条件涉及到的变量，然后用AtomicReference来实现原子性。</p>
<p>#总结</p>
<p>atomic包下的类比如AtomicInteger实现原子性的方法主要是依靠现代主流 CPU 都支持的CAS指令，它是通过Unsafe类的native方法调用的。一般而言性能比用锁同步要好，但是都已经很好了，一般而言不会遇到性能问题，关键还是看它的语义是否满足使用要求，以及是否可以让代码更清新。</p>
<p>Refers</p>
<ol>
<li><a href="http://my.oschina.net/lifany/blog/133513" target="_blank" rel="external">http://my.oschina.net/lifany/blog/133513</a></li>
<li><a href="http://zl198751.iteye.com/blog/1848575" target="_blank" rel="external">http://zl198751.iteye.com/blog/1848575</a></li>
<li><a href="http://blog.csdn.net/aesop_wubo/article/details/7537960" target="_blank" rel="external">http://blog.csdn.net/aesop_wubo/article/details/7537960</a></li>
<li><a href="http://my.oschina.net/u/177808/blog/166819" target="_blank" rel="external">http://my.oschina.net/u/177808/blog/166819</a></li>
<li><a href="http://www.blogjava.net/mstar/archive/2013/04/24/398351.html" target="_blank" rel="external">http://www.blogjava.net/mstar/archive/2013/04/24/398351.html</a></li>
<li><a href="http://mishadoff.com/blog/java-magic-part-4-sun-dot-misc-dot-unsafe/" target="_blank" rel="external">http://mishadoff.com/blog/java-magic-part-4-sun-dot-misc-dot-unsafe/</a></li>
<li><a href="http://zeroturnaround.com/rebellabs/dangerous-code-how-to-be-unsafe-with-java-classes-objects-in-memory/" target="_blank" rel="external">http://zeroturnaround.com/rebellabs/dangerous-code-how-to-be-unsafe-with-java-classes-objects-in-memory/</a></li>
<li><a href="http://www.pwendell.com/2012/08/13/java-lock-free-deepdive.html" target="_blank" rel="external">http://www.pwendell.com/2012/08/13/java-lock-free-deepdive.html</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;java5之后的java.util.concurrent包是世界级并发大师Doug Lea的作品，里面主要实现了&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;atomic包里Integer/Long对应的原子类，主要基于CAS；&lt;/li&gt;
&lt;li&gt;一些同步子，包括Lock，CountDownLatch，Semaphore，FutureTask等，这些都是基于AbstractQueuedSynchronizer类；&lt;/li&gt;
&lt;li&gt;关于线程执行的Executors类等；&lt;/li&gt;
&lt;li&gt;一些并发的集合类，比如ConcurrentHashMap，ConcurrentLinkedQueue，CopyOnWriteArrayList等。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;今天我们主要介绍atomic包下相关内容。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://magicly.me/categories/Java/"/>
    
    
      <category term="Java" scheme="http://magicly.me/tags/Java/"/>
    
      <category term="concurrency" scheme="http://magicly.me/tags/concurrency/"/>
    
      <category term="jdk" scheme="http://magicly.me/tags/jdk/"/>
    
      <category term="源码阅读" scheme="http://magicly.me/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>Java Concurrency（三）——J.U.C AQS源码解读</title>
    <link href="http://magicly.me/2015/01/13/java-concurrrency-3-juc-source-code-read/"/>
    <id>http://magicly.me/2015/01/13/java-concurrrency-3-juc-source-code-read/</id>
    <published>2015-01-13T13:34:10.000Z</published>
    <updated>2017-03-10T05:28:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>java5之后的java.util.concurrent包是世界级并发大师Doug Lea的作品，里面主要实现了</p>
<ol>
<li>atomic包里Integer/Long对应的原子类，主要基于CAS；</li>
<li>一些同步子，包括Lock，CountDownLatch，Semaphore，FutureTask等，这些都是基于AbstractQueuedSynchronizer类；</li>
<li>关于线程执行的Executors类等；</li>
<li>一些并发的集合类，比如ConcurrentHashMap，ConcurrentLinkedQueue，CopyOnWriteArrayList等。</li>
</ol>
<p>今天我们主要介绍AbstractQueuedSynchronizer这个可以说是最核心的类，没有之一。整个concurrent包里，基本都直接或间接地用到了这个类。Doug Lea的这篇<a href="http://gee.cs.oswego.edu/dl/papers/aqs.pdf" target="_blank" rel="external">论文</a>里面讲AQS的实现。</p>
<a id="more"></a>
<p>#AQS</p>
<p>首先，我们来想象一下，一间屋里有一个大家都想要得到的会让你很爽的东西（something which makes you so happy, e.g. W.C）。当有人进去把门关起来在独占享用的时候，其他人就只能在外面排队等待，既然在等待，你就不能老是去敲门说哎，好了没有啊。老是这样的话里面的人就很不爽了，而且你可以利用这点等待时间干点别的，比如看看小说视频背背单词或者就干脆椅子上睡觉，当前面独占的人爽完之后，就会出来说，啊，好爽，到你们了。然后大家可能按照排队顺序获取或者大家疯抢这个状态，有可能一个人自己进去独占，有可能几个人说，哎没关系，我们可以一起来。然后他们进去爽，爽完之后再出来通知下一个。</p>
<p>我们来把上面这段话翻译成AQS里面的术语。有一个状态state，会有多个Thread尝试获取，当一个Thread独占（EXCLUSIVE，比如Lock）之后，其他后面到来的Thread就会被放到一个Queue的队尾（tail），然后睡眠（park），一直等到前面的Thread唤醒（unpark）它，当然这里有可能被假唤醒（就好比你定了闹钟8点起床，结果7点就自然醒或者被外面车吵醒），所以这个Thread会判断一下是不是到自己了，没有的话就继续park（在一个死循环里）；当拥有state的Thread释放（release）之后，它会唤醒Queue中的下一个Thread（unparkSuccessor）。然后下一个Thread获取（acquire）到state，完成自己的任务，然后继续unparkSuccessor。前面主要说的是EXCLUSIVE模式，AQS还支持共享（SHARED）模式，区别在于尝试获取（tryAcquireShared）的时候即使之前已经有Thread获取了state，但是可能仍然能获取（比如ReadLock）。同样释放（doReleaseShared）的时候除了通知Queue里面第一个（head），还会继续通知后续的节点（Node），只要它们是SHARED。</p>
<p>AQS就是实现了：</p>
<ol>
<li>自动管理这个同步状态state（int类型），更新的时候需要用CAS保证原子性</li>
<li>阻塞和唤醒线程park/unpark</li>
<li>队列管理，一个双向链表实现queue</li>
</ol>
<p>AQS是一个abstract class，可以通过继承AQS，定义state的含义，以及tryAcquire，tryRelease，以及对应的share模式下tryAcquireShared，tryReleaseShared这几个方法，定义出自己想要的同步子（Synchronizers）。一般而言，是定义一个内部类Sync extends AQS，实现前面说的几个方法，然后再包一层，暴露出相应的方法。这样做的好处是你可以在包装器类里面取更直观的名字，如ReentrantLock里的lock，unlock和CountDownLatch里的countDown，await，而不是太通用的acquire和release等。而且AQS里面一些方法是为了监控和调试使用，直接暴露出来也不好。</p>
<p>下面我们来看J.U.C里面两个常用的Synchronizers。</p>
<p>#ReentrantLock</p>
<p>##使用</p>
<p>ReentrantLock的语义跟synchronized关键字基本一样，而且我之前看<a href="http://book.douban.com/subject/6522893/" target="_blank" rel="external">《深入理解Java虚拟机》</a>里面的评测说JDK6之后，两者的效率基本一致了（JDK5之前ReentrantLock要比synchronized快很多）。Javadoc里面说基本用法如下：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> <span class="title">X</span> &#123;</div><div class="line">  <span class="keyword">private</span> final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">new</span> ReentrantLock();</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">lock</span>.<span class="keyword">lock</span>();  <span class="comment">// block until condition holds</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="comment">// ... method body</span></div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">      <span class="keyword">lock</span>.unlock()</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>##源码</p>
<p>ReentrantLock用state表示是否被锁，0表示没有线程获取到锁，&gt;=1表示某个线程获取了N次锁（因为是重入的，只要保证lock和unlock成对出现就没有问题）。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Synchronizer providing all implementation mechanics */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Sync</span> sync;</div><div class="line"></div><div class="line"><span class="keyword">abstract</span> static <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</div></pre></td></tr></table></figure></p>
<p>定义了一个内部类，基本任务都代理给sync完成。而Sync又是一个abstract class，这里主要是因为实现了两种抢占锁的机制，公平锁和非公平锁。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">static <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span></span></div><div class="line"></div><div class="line">static <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span></span></div></pre></td></tr></table></figure></p>
<p>所谓公平不公平简单来说就是本文开头说的，当资源释放的时候，大家是按照排队顺序先到先得，还是有人插队大家疯抢。</p>
<p>提供了两个构造函数：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</div><div class="line">       sync = <span class="keyword">new</span> NonfairSync();<span class="comment">//默认非公平锁，AQS论文说非公平锁效率高些，理由其实很简单，公平锁通知队列第一个节点，要把它唤醒，而唤醒是需要时间的，在锁释放到第一个节点被唤醒这段时间其实锁是可以用但是没有被用的（available but not used）；而非公平锁，释放了之后立马就可以被别人用，所以提高了效率，但是有可能导致饥饿锁，这个就要具体看业务需求了。</span></div><div class="line">   &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</div><div class="line">       sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();<span class="comment">//指定公平与否</span></div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>加锁的实现<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span>(<span class="params"></span>) </span>&#123;</div><div class="line">       sync.<span class="keyword">lock</span>();</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>简单代理给了sync，在FairSync里为<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</div><div class="line">	acquire(<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>acquire的实现在AQS里面：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</div><div class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</div><div class="line">        selfInterrupt();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>tryAcquire是要在子类里自己实现的，在FairSync如下;<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">         <span class="keyword">final</span> Thread current = Thread.currentThread();</div><div class="line">         <span class="keyword">int</span> c = getState();</div><div class="line">         <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;<span class="comment">//0表示锁没有被线程用，1表示已经有线程占用</span></div><div class="line">             <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; <span class="comment">//判断自己是否是第一个节点，实现公平</span></div><div class="line">                 compareAndSetState(<span class="number">0</span>, acquires)) &#123;<span class="comment">//CAS更新状态</span></div><div class="line">                 setExclusiveOwnerThread(current);<span class="comment">//设置当前线程拥有状态</span></div><div class="line">                 <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">             &#125;</div><div class="line">         &#125;</div><div class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<span class="comment">//1表示已经有线程占用，再判断一下是否被当前线程占用，来实现重入（Reentrant）特性</span></div><div class="line">             <span class="keyword">int</span> nextc = c + acquires;</div><div class="line">             <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</div><div class="line">                 <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line">             setState(nextc);<span class="comment">//更新状态</span></div><div class="line">             <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">         &#125;</div><div class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">     &#125;</div></pre></td></tr></table></figure></p>
<p>如果获取失败，addWaiter(Node.EXCLUSIVE)将当前线程加入队尾<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">private <span class="keyword">Node</span> <span class="title">addWaiter</span>(<span class="keyword">Node</span> <span class="title">mode</span>) &#123;</div><div class="line">       <span class="keyword">Node</span> <span class="title">node</span> = new <span class="keyword">Node</span><span class="title">(Thread</span>.currentThread(), mode);//用当前线程构造<span class="keyword">Node</span><span class="title">，独占模式</span></div><div class="line">       // Try the fast path of enq; backup to full enq on failure</div><div class="line">       <span class="keyword">Node</span> <span class="title">pred</span> = tail;</div><div class="line">       if (pred != null) &#123;</div><div class="line">           <span class="keyword">node</span>.<span class="title">prev</span> = pred;</div><div class="line">           if (compareAndSetTail(pred, <span class="keyword">node</span><span class="title">)) &#123;//快速判断，CAS</span>更新tail节点</div><div class="line">               pred.next = <span class="keyword">node</span><span class="title">;</span></div><div class="line">               return <span class="keyword">node</span><span class="title">;</span></div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       enq(<span class="keyword">node</span><span class="title">);//如果失败，进入enq</span>方法</div><div class="line">       return <span class="keyword">node</span><span class="title">;</span></div><div class="line">   &#125;</div><div class="line">   </div><div class="line"> private <span class="keyword">Node</span> <span class="title">enq</span>(final <span class="keyword">Node</span> <span class="title">node</span>) &#123;</div><div class="line">       for (;;) &#123;</div><div class="line">           <span class="keyword">Node</span> <span class="title">t</span> = tail;</div><div class="line">           if (t == null) &#123; // Must initialize</div><div class="line">               if (compareAndSetHead(new <span class="keyword">Node</span><span class="title">()))//如果还没有head</span>，CAS初始化一个head</div><div class="line">                   tail = head;</div><div class="line">           &#125; else &#123;//这段代码跟addWaiter里一样，CAS更新tail节点</div><div class="line">               <span class="keyword">node</span>.<span class="title">prev</span> = t;</div><div class="line">               if (compareAndSetTail(t, <span class="keyword">node</span><span class="title">)) &#123;</span></div><div class="line">                   t.next = <span class="keyword">node</span><span class="title">;</span></div><div class="line">                   return t;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>现在我们已经将获取不到锁的线程加入队尾了，现在要将它挂起acquireQueued(addWaiter(Node.EXCLUSIVE), arg))：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">       <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</div><div class="line">           <span class="keyword">for</span> (;;) &#123;<span class="comment">//在一个死循环中，避免假唤醒</span></div><div class="line">               <span class="keyword">final</span> Node p = node.predecessor();<span class="comment">//获取当前节点的前一个节点，如果是head说明自己是第一个可以获取资源的线程，实现公平</span></div><div class="line">               <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<span class="comment">//是第一个可以获取资源的线程并且尝试获取成功</span></div><div class="line">                   setHead(node);</div><div class="line">                   p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">                   failed = <span class="keyword">false</span>;</div><div class="line">                   <span class="keyword">return</span> interrupted;</div><div class="line">               &#125;</div><div class="line">               <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                   parkAndCheckInterrupt())<span class="comment">//没有获取到资源，睡眠park去</span></div><div class="line">                   interrupted = <span class="keyword">true</span>;</div><div class="line">           &#125;</div><div class="line">       &#125; <span class="keyword">finally</span> &#123;</div><div class="line">           <span class="keyword">if</span> (failed)</div><div class="line">               cancelAcquire(node);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</div><div class="line">       LockSupport.park(<span class="keyword">this</span>);</div><div class="line">       <span class="function"><span class="keyword">return</span> Thread.<span class="title">interrupted</span><span class="params">()</span></span>;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>上面完成了获取锁的过程，简单来说就是尝试获取，失败就加入队尾，挂起，等待被唤醒。</p>
<p>下面来看看释放锁<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</div><div class="line">        sync.release(<span class="number">1</span>);<span class="comment">//代理给sync，调用AQS的release</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="comment">//下面代码在AQS中</span></div><div class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;<span class="comment">//尝试释放资源，需要在子类里实现</span></div><div class="line">            Node h = head;</div><div class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</div><div class="line">                unparkSuccessor(h);<span class="comment">//通知下一个节点</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * If status is negative (i.e., possibly needing signal) try</div><div class="line">         * to clear in anticipation of signalling.  It is OK if this</div><div class="line">         * fails or if status is changed by waiting thread.</div><div class="line">         */</div><div class="line">        <span class="keyword">int</span> ws = node.waitStatus;</div><div class="line">        <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</div><div class="line">            compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line">         * Thread to unpark is held in successor, which is normally</div><div class="line">         * just the next node.  But if cancelled or apparently null,</div><div class="line">         * traverse backwards from tail to find the actual</div><div class="line">         * non-cancelled successor.</div><div class="line">         */</div><div class="line">         <span class="comment">// 主要在这里找到下一个需要通知的节点，如果node.next就是需要通知的节点，则直接通知；否则，可能node.next == null（原因是双向链表设置b.pre = a和a.next = b的时候不能保证原子性，只能保证b.pre = a成功，这时候另一条线程可能看到a.next == null）或者s.waitStatus &gt; 0（原因是线程等不及被取消了static final int CANCELLED = 1;），这个时候就要从队尾tail开始找，找到离队头head最近的一个需要通知的节点Node。</span></div><div class="line">        Node s = node.next;</div><div class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</div><div class="line">            s = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</div><div class="line">                <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</div><div class="line">                    s = t;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (s != <span class="keyword">null</span>)</div><div class="line">            LockSupport.unpark(s.thread);<span class="comment">//唤醒线程</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>看看需要在子类里实现的tryRelease：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</div><div class="line">          <span class="keyword">int</span> c = getState() - releases;<span class="comment">//释放锁，state减去相应的值</span></div><div class="line">          <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</div><div class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();<span class="comment">//避免A线程锁了之后，B线程故意捣乱释放锁</span></div><div class="line">          <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</div><div class="line">          <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;<span class="comment">//当前线程已经完全释放了锁</span></div><div class="line">              free = <span class="keyword">true</span>;</div><div class="line">              setExclusiveOwnerThread(<span class="keyword">null</span>);<span class="comment">//释放锁的拥有者</span></div><div class="line">          &#125;</div><div class="line">          setState(c);<span class="comment">//设置状态，这个方面没有同步，没有CAS，有同学问过岂不是有线程并发问题？其实到这里，只有一个线程会调用这个方法，所以不会有并发错误，仔细想想，是吧？是吧？</span></div><div class="line">          <span class="keyword">return</span> free;</div><div class="line">      &#125;</div></pre></td></tr></table></figure></p>
<p>到这里，基本都已经完成，对了，还没有说非公平锁NonfairSync是怎么抢占锁的。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</div><div class="line">          <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))<span class="comment">//先抢一把（插队），万一成功了就不排队，不公平性就体现在这里！</span></div><div class="line">              setExclusiveOwnerThread(Thread.currentThread());</div><div class="line">          <span class="keyword">else</span></div><div class="line">              acquire(<span class="number">1</span>);</div><div class="line">      &#125;</div></pre></td></tr></table></figure></p>
<p>跟FairSync.lock()对比，可以看出，只是在acquire(1)之前，先抢一把，抢不到才乖乖的去排队。</p>
<p>我们再看看NonfairSync.tryAcquire()怎么实现的<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">          <span class="function"><span class="keyword">return</span> <span class="title">nonfairTryAcquire</span><span class="params">(acquires)</span></span>;<span class="comment">//调用父类方法nonfairTryAcquire</span></div><div class="line">      &#125;</div><div class="line"></div><div class="line"><span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">          <span class="keyword">final</span> Thread current = Thread.currentThread();</div><div class="line">          <span class="keyword">int</span> c = getState();</div><div class="line">          <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</div><div class="line">              <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;<span class="comment">//跟FairSync.tryAcquire只有这里一行有差异，即少了!hasQueuedPredecessors()，也就是说不判断前面有没有人，任何时候只要它醒来，都会去抢，所以不公平！============刚又看了一遍，发现其实final boolean acquireQueued(final Node node, int arg)方法里已经有node.predecessor() == head的判断，感觉这个不公平的tryAcquire貌似没有意义，各位看官怎么看呢，请留言哈，谢谢~</span></div><div class="line">                  setExclusiveOwnerThread(current);</div><div class="line">                  <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</div><div class="line">              <span class="keyword">int</span> nextc = c + acquires;</div><div class="line">              <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></div><div class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line">              setState(nextc);</div><div class="line">              <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">      &#125;</div></pre></td></tr></table></figure></p>
<p>#CountDownLatch</p>
<p>我们之前说了，AQS支持独占EXCLUSIVE和共享SHARED两种模式，而刚刚的ReentrantLock的就是独占模式，我们来看看一个使用共享模式的类。</p>
<p>##使用</p>
<p>CountDownLatch就好比一道门，它可以用来等所有资源都到齐了，才开门，让这些线程同时通过。比如如下是CountDownLatch一个通用用法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> concurrentStudy;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by magicalli on 2014/12/13.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexPlusPlusTest01</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NThreads = <span class="number">10</span>;<span class="comment">// 线程数</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> M = <span class="number">100000</span>;<span class="comment">//循环次数，太小的话（比如10）可能看不出来效果</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> n = <span class="number">0</span>;<span class="comment">//加volatile的目的是为了证明volatile没有“原子性”！</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="keyword">final</span> CountDownLatch startGate = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</div><div class="line">        <span class="keyword">final</span> CountDownLatch endGate = <span class="keyword">new</span> CountDownLatch(NThreads);</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NThreads; i++) &#123;</div><div class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        startGate.await();<span class="comment">//所有线程start之后等待“门“打开，保证同时真正开始运行</span></div><div class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; j++) &#123;</div><div class="line">                        n += <span class="number">1</span>;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    endGate.countDown();</div><div class="line">                &#125;</div><div class="line">            &#125;).start();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        startGate.countDown();<span class="comment">//打开“门”，让所有线程同时run起来</span></div><div class="line">        <span class="keyword">long</span> t1 = System.currentTimeMillis();</div><div class="line">        endGate.await();<span class="comment">//等所有线程都结束之后才打印n，否则总是会打出错误的n；我见过这里用Thread.sleep()，但是问题在于，你怎么知道该等多久才能保证所有线程结束以及刚好结束呢？！</span></div><div class="line">        <span class="keyword">long</span> t2 = System.currentTimeMillis();</div><div class="line">        System.out.println(<span class="string">"cost time: "</span> + (t2 - t1));</div><div class="line">        System.out.println(<span class="string">"n: "</span> + n);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对了，上面代码是拿来验证volatile不具备原子性的，是错误的代码哦。如果想并发安全，大家可以想想可以用哪些方式实现。</p>
<p>##源码</p>
<p>CountDownLatch同样也是定义了一个继承自AQS的内部类Sync：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> static <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></div></pre></td></tr></table></figure></p>
<p>构造函数如下：<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> CountDownLatch(<span class="keyword">int</span> <span class="keyword">count</span>) &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">count</span> &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count &lt; 0"</span>);</div><div class="line">    <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(<span class="keyword">count</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>count表示有多少个任务还在运行，每个Thread完成了任务或者准备好开始之前，就会调用countDown方法将count-1，当count==0时候，await就不再阻塞，所有在上面阻塞的Thread都可以顺利通过。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>直接调用AQS的acquireSharedInterruptibly方法，从方法名可以看出，支持中断响应<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></div><div class="line">        <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">    <span class="keyword">if</span> (Thread.interrupted())</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();<span class="comment">//响应中断</span></div><div class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</div><div class="line">        doAcquireSharedInterruptibly(arg);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>tryAcquireShared在子类中实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">-1</span>;<span class="comment">//如果state为0，说明所有Thread完成任务，可以不阻塞了</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果没有获取到，将Thread加入队尾，挂起。下面这个方法跟独占模式下acquireQueued(addWaiter(Node.EXCLUSIVE), arg))这个方法代码是基本一致的。<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">private void doAcquireSharedInterruptibly(int arg)</div><div class="line">       throws InterruptedException &#123;</div><div class="line">       final <span class="keyword">Node</span> <span class="title">node</span> = addWaiter(<span class="keyword">Node</span>.<span class="title">SHARED</span>);//共享模式</div><div class="line">       boolean failed = <span class="literal">true</span>;</div><div class="line">       try &#123;</div><div class="line">           for (;;) &#123;</div><div class="line">               final <span class="keyword">Node</span> <span class="title">p</span> = <span class="keyword">node</span>.<span class="title">predecessor</span>();</div><div class="line">               if (p == head) &#123;</div><div class="line">                   int r = tryAcquireShared(arg);</div><div class="line">                   if (r &gt;= <span class="number">0</span>) &#123;</div><div class="line">                       setHeadAndPropagate(<span class="keyword">node</span><span class="title">, r</span>);//跟EXCLUSIVE的一大区别</div><div class="line">                       p.next = null; // help GC</div><div class="line">                       failed = <span class="literal">false</span>;</div><div class="line">                       return;</div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">               if (shouldParkAfterFailedAcquire(p, <span class="keyword">node</span><span class="title">) &amp;&amp;</span></div><div class="line">                   parkAndCheckInterrupt())</div><div class="line">                   throw new InterruptedException();//响应中断，这里直接抛异常</div><div class="line">           &#125;</div><div class="line">       &#125; finally &#123;</div><div class="line">           if (failed)</div><div class="line">               cancelAcquire(<span class="keyword">node</span><span class="title">);</span></div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">private void setHeadAndPropagate(<span class="keyword">Node</span> <span class="title">node</span>, int propagate) &#123;</div><div class="line">       <span class="keyword">Node</span> <span class="title">h</span> = head; // Record old head for check below</div><div class="line">       setHead(<span class="keyword">node</span><span class="title">);</span></div><div class="line">       /*</div><div class="line">        * Try to signal next queued <span class="keyword">node</span> if:<span class="title"></span></div><div class="line">        *   Propagation was indicated by caller,</div><div class="line">        *     <span class="keyword">or</span> was recorded (as h.waitStatus either before</div><div class="line">        *     <span class="keyword">or</span> after setHead) by a previous operation</div><div class="line">        *     (note: this uses sign-check of waitStatus because</div><div class="line">        *      PROPAGATE status may transition to SIGNAL.)</div><div class="line">        * <span class="keyword">and</span></div><div class="line">        *   The next <span class="keyword">node</span> <span class="title">is</span> waiting <span class="keyword">in</span> shared mode,</div><div class="line">        *     <span class="keyword">or</span> we don't know, because it appears null</div><div class="line">        *</div><div class="line">        * The conservatism <span class="keyword">in</span> both of these checks may cause</div><div class="line">        * unnecessary wake-ups, but only when there are multiple</div><div class="line">        * racing acquires/releases, so most need signals now <span class="keyword">or</span> soon</div><div class="line">        * anyway.</div><div class="line">        */</div><div class="line">        // 如果当前节点是愿意共享，并且下一个节点也是愿意共享的，那么就进入doReleaseShared，唤醒下一个节点，下面会详解</div><div class="line">       if (propagate &gt; <span class="number">0</span> || h == null || h.waitStatus <span class="tag">&lt; 0 ||</span></div><div class="line">           (h = head) == null || h.waitStatus &lt; 0) &#123;</div><div class="line">           Node s = node.next;</div><div class="line">           if (s == null || s.isShared())</div><div class="line">               doReleaseShared();</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>前面完成了等待CountDownLatch的count变成0的过程，下面看看countDown<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</div><div class="line">       sync.releaseShared(<span class="number">1</span>);<span class="comment">//调用AQS的</span></div><div class="line">   &#125;</div><div class="line"></div><div class="line"><span class="comment">// AQS中</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;<span class="comment">//尝试释放，需要在子类中实现</span></div><div class="line">           doReleaseShared();<span class="comment">//真正释放</span></div><div class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">	<span class="comment">// Sync子类中实现</span></div><div class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</div><div class="line">           <span class="comment">// Decrement count; signal when transition to zero</span></div><div class="line">           <span class="keyword">for</span> (;;) &#123;</div><div class="line">               <span class="keyword">int</span> c = getState();</div><div class="line">               <span class="keyword">if</span> (c == <span class="number">0</span>)</div><div class="line">                   <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">               <span class="keyword">int</span> nextc = c<span class="number">-1</span>;</div><div class="line">               <span class="keyword">if</span> (compareAndSetState(c, nextc))<span class="comment">// 在死循环中CAS将count-1</span></div><div class="line">                   <span class="keyword">return</span> nextc == <span class="number">0</span>;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       </div><div class="line">   <span class="comment">// AQS中</span></div><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="comment">/*</span></div><div class="line">        * Ensure that a release propagates, even if there are other</div><div class="line">        * in-progress acquires/releases.  This proceeds in the usual</div><div class="line">        * way of trying to unparkSuccessor of head if it needs</div><div class="line">        * signal. But if it does not, status is set to PROPAGATE to</div><div class="line">        * ensure that upon release, propagation continues.</div><div class="line">        * Additionally, we must loop in case a new node is added</div><div class="line">        * while we are doing this. Also, unlike other uses of</div><div class="line">        * unparkSuccessor, we need to know if CAS to reset status</div><div class="line">        * fails, if so rechecking.</div><div class="line">        */</div><div class="line">       <span class="keyword">for</span> (;;) &#123;</div><div class="line">           Node h = head;</div><div class="line">           <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</div><div class="line">               <span class="keyword">int</span> ws = h.waitStatus;</div><div class="line">               <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</div><div class="line">                   <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</div><div class="line">                       <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></div><div class="line">                   unparkSuccessor(h);<span class="comment">//遍历queue，通知所有SHARED的节点，因为是共享模式，这些Node都应该被唤醒，直到遇到某个EXCLUSIVE的Node</span></div><div class="line">               &#125;</div><div class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</div><div class="line">                        !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</div><div class="line">                   <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></div><div class="line">           &#125;</div><div class="line">           <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></div><div class="line">               <span class="keyword">break</span>;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>unparkSuccessor跟之前独占模式里面的是同一个函数，即调用unpark唤醒Thread。</p>
<p>我们知道为了避免获取不到锁长时间等待，一般阻塞的方法都会支持带超时时间的方法，比如CountDownLatch里就有<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></div><div class="line">       <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">       <span class="keyword">return</span> sync.tryAcquireSharedNanos(<span class="number">1</span>, unit.toNanos(timeout));</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>调用AQS里面的tryAcquireSharedNanos方法<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryAcquireSharedNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></div><div class="line">           <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">       <span class="keyword">if</span> (Thread.interrupted())</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">       <span class="keyword">return</span> tryAcquireShared(arg) &gt;= <span class="number">0</span> ||</div><div class="line">           doAcquireSharedNanos(arg, nanosTimeout);</div><div class="line">   &#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">boolean</span> <span class="title">doAcquireSharedNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></div><div class="line">           <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">       <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0</span>L)</div><div class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">       <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</div><div class="line">       <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</div><div class="line">       <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           <span class="keyword">for</span> (;;) &#123;</div><div class="line">               <span class="keyword">final</span> Node p = node.predecessor();</div><div class="line">               <span class="keyword">if</span> (p == head) &#123;</div><div class="line">                   <span class="keyword">int</span> r = tryAcquireShared(arg);</div><div class="line">                   <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</div><div class="line">                       setHeadAndPropagate(node, r);</div><div class="line">                       p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">                       failed = <span class="keyword">false</span>;</div><div class="line">                       <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">               nanosTimeout = deadline - System.nanoTime();</div><div class="line">               <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0</span>L)</div><div class="line">                   <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//如果已经没时间了，直接return false</span></div><div class="line">               <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                   nanosTimeout &gt; spinForTimeoutThreshold)<span class="comment">//大于某个阈值，才park，否则进入自旋</span></div><div class="line">                   LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);<span class="comment">//调用带超时的park方法</span></div><div class="line">               <span class="keyword">if</span> (Thread.interrupted())</div><div class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">           &#125;</div><div class="line">       &#125; <span class="keyword">finally</span> &#123;</div><div class="line">           <span class="keyword">if</span> (failed)</div><div class="line">               cancelAcquire(node);</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>可以看到，跟不带超时的doAcquireSharedInterruptibly方法相比，区别主要在于每次for循环期间，检查时间是否过期和调用带超时的park。nanosTimeout &gt; spinForTimeoutThreshold这个判断主要是因为park/unpark本身也需要花时间，为了更准确地完成超时的机制，在超时时间马上就要到了的时候，就进入自旋，不再park了，这应该是Doug Lea测试了park/unpark时间比1000纳秒要长吧。<br><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">    * The number <span class="keyword">of</span> nanoseconds <span class="keyword">for</span> which it <span class="keyword">is</span> faster <span class="keyword">to</span> spin</div><div class="line">    * rather than <span class="keyword">to</span> use timed park. A rough estimate suffices</div><div class="line">    * <span class="keyword">to</span> improve responsiveness <span class="keyword">with</span> very <span class="built_in">short</span> timeouts.</div><div class="line">    */</div><div class="line">   <span class="keyword">static</span> final <span class="built_in">long</span> spinForTimeoutThreshold = <span class="number">1000</span>L;</div></pre></td></tr></table></figure></p>
<p>#总结</p>
<p>J.U.C里AQS是一个相当核心的类，可以说没有它就没有J.U.C包。推荐大家看看<a href="http://gee.cs.oswego.edu/dl/papers/aqs.pdf" target="_blank" rel="external">AQS</a>这篇论文（网上有一些翻译，推荐大家还是看原文吧）。主要是用一个state表示状态，子类可以根据需要来定义state的含义，以及获取释放资源时具体如何操作state，当然需要通过CAS实现原子更改。当获取不到state的时候，线程加入队列，挂起。释放之后，唤醒队列中的线程。AQS支持两种模式，独占EXCLUSIVE和共享SHARED。J.U.C里本身也有很多直接继承AQS实现的类，包括Lock，CountDownLatch，Semaphore，FutureTask等，如果这些还不能满足你的使用，那么可以直接继承AQS来实现需要。</p>
<p>#Refers</p>
<ol>
<li><a href="http://gee.cs.oswego.edu/dl/papers/aqs.pdf" target="_blank" rel="external">http://gee.cs.oswego.edu/dl/papers/aqs.pdf</a></li>
<li><a href="http://ifeve.com/introduce-abstractqueuedsynchronizer/" target="_blank" rel="external">http://ifeve.com/introduce-abstractqueuedsynchronizer/</a></li>
<li><a href="http://ifeve.com/jdk1-8-abstractqueuedsynchronizer/" target="_blank" rel="external">http://ifeve.com/jdk1-8-abstractqueuedsynchronizer/</a></li>
<li><a href="http://ifeve.com/jdk1-8-abstractqueuedsynchronizer-part2/" target="_blank" rel="external">http://ifeve.com/jdk1-8-abstractqueuedsynchronizer-part2/</a></li>
<li><a href="http://book.douban.com/subject/6522893/" target="_blank" rel="external">http://book.douban.com/subject/6522893/</a></li>
<li><a href="http://my.oschina.net/magicly007/blog/364102" target="_blank" rel="external">http://my.oschina.net/magicly007/blog/364102</a></li>
</ol>
<blockquote>
<p>Written with <a href="https://stackedit.io/" target="_blank" rel="external">StackEdit</a>.</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;java5之后的java.util.concurrent包是世界级并发大师Doug Lea的作品，里面主要实现了&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;atomic包里Integer/Long对应的原子类，主要基于CAS；&lt;/li&gt;
&lt;li&gt;一些同步子，包括Lock，CountDownLatch，Semaphore，FutureTask等，这些都是基于AbstractQueuedSynchronizer类；&lt;/li&gt;
&lt;li&gt;关于线程执行的Executors类等；&lt;/li&gt;
&lt;li&gt;一些并发的集合类，比如ConcurrentHashMap，ConcurrentLinkedQueue，CopyOnWriteArrayList等。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;今天我们主要介绍AbstractQueuedSynchronizer这个可以说是最核心的类，没有之一。整个concurrent包里，基本都直接或间接地用到了这个类。Doug Lea的这篇&lt;a href=&quot;http://gee.cs.oswego.edu/dl/papers/aqs.pdf&quot;&gt;论文&lt;/a&gt;里面讲AQS的实现。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://magicly.me/categories/Java/"/>
    
    
      <category term="Java" scheme="http://magicly.me/tags/Java/"/>
    
      <category term="concurrency" scheme="http://magicly.me/tags/concurrency/"/>
    
      <category term="jdk" scheme="http://magicly.me/tags/jdk/"/>
    
      <category term="源码阅读" scheme="http://magicly.me/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
</feed>
