<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JustForFun</title>
  <subtitle>工程师，程序猿，Magic，德州扑克</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://magicly.me/"/>
  <updated>2017-03-02T15:58:59.000Z</updated>
  <id>http://magicly.me/</id>
  
  <author>
    <name>magicly</name>
    <email>magicly007@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>在markdown里如何写数学公式</title>
    <link href="http://magicly.me/2017/03/02/markdown-math/"/>
    <id>http://magicly.me/2017/03/02/markdown-math/</id>
    <published>2017-03-02T03:16:16.000Z</published>
    <updated>2017-03-02T15:58:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近准备写一下机器学习的一些学习笔记， 由于涉及到大量数学公式， 发现不把如何在markdown里写数学公式这个问题解决了会严重影响工作效率。大概而言， 主要有两种方式：</p>
<a id="more"></a>
<ol>
<li>用图片！<br>也就是编辑好公式，上传，然后在markdown里面引用图片链接的方式。这种方式方便直接，但是显得比较low一点。 有兴趣的可以参考这几篇文章。</li>
</ol>
<ul>
<li><a href="http://www.ruanyifeng.com/blog/2011/07/formula_online_generator.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2011/07/formula_online_generator.html</a><br>当然， 在某些情况下， 必须使用这种思路。 比如， 微信公众号里。 可以参考<a href="http://www.52nlp.cn/%E5%9C%A8%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E9%87%8C%E4%BD%BF%E7%94%A8latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F" target="_blank" rel="external">这里</a></li>
</ul>
<ol>
<li>用Mathjax插件来写LaTex公式。<br>哪怕你是用图片， 那也得写出LaTex公式啊。所以我们今天主要讲第二种方式。推荐<a href="https://webdemo.myscript.com/views/math.html" target="_blank" rel="external">这个工具</a>，可以直接在浏览器里手写公式，它会帮你转为LaTex！很好很强大。</li>
</ol>
<h1 id="MathJax插件"><a href="#MathJax插件" class="headerlink" title="MathJax插件"></a>MathJax插件</h1><p>著名的Stackoverflow网站上的漂亮公式，就是使用了MathJax插件的效果。添加MathJax插件也非常简单，只需要在markdown文件中，添加MathJax CDN，如下：<br><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span></span></div><div class="line">   <span class="attr">src</span>=<span class="string">"http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"</span>&gt;<span class="undefined"></span></div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>就可以在md文件中插入Tex格式的公式了。</p>
<p>行间公式的形式为<br><figure class="highlight gams"><table><tr><td class="code"><pre><div class="line"><span class="symbol">$</span><span class="symbol">$</span> 此处插入公式 <span class="symbol">$</span><span class="symbol">$</span></div></pre></td></tr></table></figure></p>
<p>而行内公式的形式为<br><figure class="highlight livescript"><table><tr><td class="code"><pre><div class="line"><span class="string">\\(</span> 此处插入公式 <span class="string">\\)</span></div></pre></td></tr></table></figure></p>
<h1 id="Hexo中显示数学公式"><a href="#Hexo中显示数学公式" class="headerlink" title="Hexo中显示数学公式"></a>Hexo中显示数学公式</h1><p>Hexo原生不支持数学公式， 因此需要我们做一些修改。安装<a href="https://github.com/akfish/hexo-math" target="_blank" rel="external">hexo-math</a>插件：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><div class="line">npm install hexo-<span class="built_in">math</span> <span class="comment">--save</span></div></pre></td></tr></table></figure>
<p>在_config.yml中增加<br><figure class="highlight avrasm"><table><tr><td class="code"><pre><div class="line"><span class="symbol">plugins:</span></div><div class="line">  hexo-math</div></pre></td></tr></table></figure></p>
<p>完事大吉， 你现在可以写LaTex公式了， 我们来写几个看看。</p>
<p>这是行内公式根号2这样写: \(\sqrt{2}\)<br><figure class="highlight taggerscript"><table><tr><td class="code"><pre><div class="line"><span class="symbol">\\</span>(<span class="symbol">\\</span>sqrt&#123;2&#125;<span class="symbol">\\</span>)</div></pre></td></tr></table></figure></p>
<p>这是单独一行的公式:<br><figure class="highlight gams"><table><tr><td class="code"><pre><div class="line"><span class="symbol">$</span><span class="symbol">$</span> a ^ <span class="number">2</span> + b ^ <span class="number">2</span> = c ^ <span class="number">2</span> <span class="symbol">$</span><span class="symbol">$</span></div><div class="line"><span class="symbol">$</span><span class="symbol">$</span> \<span class="built-in">sqrt</span>&#123;<span class="number">2</span>&#125; <span class="symbol">$</span><span class="symbol">$</span></div><div class="line"><span class="symbol">$</span><span class="symbol">$</span> evidence\_&#123;i&#125;=\<span class="keyword">sum</span> \_&#123;j&#125;W\_&#123;ij&#125;x\_&#123;j&#125;+b\_&#123;i&#125; <span class="symbol">$</span><span class="symbol">$</span></div></pre></td></tr></table></figure></p>
<p>$$ a ^ 2 + b ^ 2 = c ^ 2 $$<br>$$ \sqrt{2} $$<br>$$ evidence_{i}=\sum _{j}W_{ij}x_{j}+b_{i} $$<br>细心的同学会发现， 里面有很多<strong>\\</strong>, <strong>\_</strong>之类， 原因是<strong>\</strong>本身在markdown和LaTex里都有含义， 因此需要转义。但是LaTex里面， <strong>\</strong>太常用了， 所以每次遇到都转义的话就很痛苦， 而且在hexo里面写的公式，复制到其他地方去就不支持了。</p>
<p>网上有改hexo渲染的源码的， 有换用pandoc的， 其实最简单的方式是用hexo-math里的tag。网上搜索到的很多资料都是用的{&#37; math_block %}，我试了发现总是不对， 后来看<a href="https://github.com/akfish/hexo-math" target="_blank" rel="external">官网</a>，发现这个方法已经deprecated了， 最新的用{&#37; math %}，如下：</p>
<figure class="highlight django"><table><tr><td class="code"><pre><div class="line"><span class="xml">这是行内公式：</span><span class="template-tag">&#123;% <span class="name">math</span> %&#125;</span><span class="xml">\sqrt&#123;2 + 3&#125;</span><span class="template-tag">&#123;% <span class="name">endmath</span> %&#125;</span><span class="xml"></span></div></pre></td></tr></table></figure>
<p>显示为：这是行内公式：<span>$\sqrt{2 + 3}$</span><!-- Has MathJax --><br>一行公式：<br><figure class="highlight tex"><table><tr><td class="code"><pre><div class="line"><span class="formula">$$ evidence<span class="tag">\<span class="name">_</span><span class="string">&#123;i&#125;</span>=</span><span class="tag">\<span class="name">sum</span></span> <span class="tag">\<span class="name">_</span><span class="string">&#123;j&#125;</span></span>W<span class="tag">\<span class="name">_</span><span class="string">&#123;ij&#125;</span></span>x<span class="tag">\<span class="name">_</span><span class="string">&#123;j&#125;</span></span>+b<span class="tag">\<span class="name">_</span><span class="string">&#123;i&#125;</span></span> $$</span></div><div class="line"></div><div class="line">&#123;<span class="comment">% math %&#125;</span></div><div class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;aligned&#125;</span></span></div><div class="line">evidence_&#123;i&#125;=<span class="tag">\<span class="name">sum</span></span> _&#123;j&#125;W_&#123;ij&#125;x_&#123;j&#125;+b_&#123;i&#125;</div><div class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;aligned&#125;</span></span></div><div class="line">&#123;<span class="comment">% endmath %&#125;</span></div></pre></td></tr></table></figure></p>
<p>$$ evidence_{i}=\sum _{j}W_{ij}x_{j}+b_{i} $$<br><span>$$\begin{aligned}
evidence_{i}=\sum _{j}W_{ij}x_{j}+b_{i}
\end{aligned}$$</span><!-- Has MathJax --><br>可以看出， 如果有需要转义的字符， 用{&#37; math %}tag这种方式要好很多。</p>
<p>再来一个复杂点的公式， 这是<a href="https://www.tensorflow.org/tutorials/word2vec" target="_blank" rel="external">word2vec</a>的损失函数公式（选中公式， 右键可以查看LaTex源码）：<br><figure class="highlight taggerscript"><table><tr><td class="code"><pre><div class="line">&#123;<span class="variable">% math %</span>&#125;</div><div class="line">J_<span class="symbol">\t</span>ext&#123;NEG&#125; = <span class="symbol">\l</span>og Q_<span class="symbol">\t</span>heta(D=1 |w_t, h) +</div><div class="line">  k <span class="symbol">\m</span>athop&#123;<span class="symbol">\m</span>athbb&#123;E&#125;&#125;_&#123;<span class="symbol">\t</span>ilde w <span class="symbol">\s</span>im P_<span class="symbol">\t</span>ext&#123;noise&#125;&#125;</div><div class="line">     <span class="symbol">\l</span>eft[ <span class="symbol">\l</span>og Q_<span class="symbol">\t</span>heta(D = 0 |<span class="symbol">\t</span>ilde w, h) <span class="symbol">\r</span>ight]</div><div class="line">&#123;<span class="variable">% endmath %</span>&#125;</div></pre></td></tr></table></figure></p>
<span>$$J_\text{NEG} = \log Q_\theta(D=1 |w_t, h) +
  k \mathop{\mathbb{E}}_{\tilde w \sim P_\text{noise}}
     \left[ \log Q_\theta(D = 0 |\tilde w, h) \right]$$</span><!-- Has MathJax -->
<p>经过简单的配置， 我们的web页面已经可以支持很方便的书写数学公式了，而且由于不用特殊转义， 这里写的LaTex可以在其他markdown环境下使用， 比如<a href="http://mp.weixin.qq.com/s?__biz=MjM5NjAyNjkwMA==&amp;mid=2723942529&amp;idx=1&amp;sn=3b417dd77b4d5b92231ed59649844eb9&amp;chksm=81473ffab630b6ec843d77432c487e3e3a272ec26a5b9e0ae4007f5fce3dd826825a7b64a249&amp;mpshare=1&amp;scene=1&amp;srcid=0301zj3JKl85H692JGwUHZzM#rd" target="_blank" rel="external">有道云笔记</a>。</p>
<p>============update===========</p>
<p>刚发现由于引用了MathJax.js， 本身又会引用其他一些js、css以及font， 会多增加差不多100k资源， 并且由于都是国外的cdn， 速度受限制（貌似还要翻墙），所以比较影响阅读体验。后续再想办法优化吧。</p>
<p>============update===========<br>发现next主题好看一些， 换成了next。 看到next直接<a href="http://theme-next.iissnan.com/third-party-services.html#others" target="_blank" rel="external">支持MathJax</a>的，换成了qiniu的cdn。但是next自带的math，不能支持{&#37; math %}，发现还是需要hexo-math， 而且很奇怪的是， 发现不用在_config.yml里面写<br><figure class="highlight avrasm"><table><tr><td class="code"><pre><div class="line"><span class="symbol">plugins:</span></div><div class="line">  hexo-math</div></pre></td></tr></table></figure></p>
<p>居然也可以， 只要package.json里面有hexo-math就可以了。于是参考<a href="https://github.com/akfish/hexo-math" target="_blank" rel="external">hexo-math官网</a>，换成了qiniu的cdn。<br><figure class="highlight less"><table><tr><td class="code"><pre><div class="line"><span class="attribute">math</span>:</div><div class="line">  <span class="attribute">engine</span>: <span class="string">'mathjax'</span> # or <span class="string">'katex'</span></div><div class="line">  <span class="attribute">mathjax</span>:</div><div class="line">  <span class="attribute">src</span>: <span class="comment">//cdn.staticfile.org/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML</span></div></pre></td></tr></table></figure></p>
<p>奇怪的是，还是有一个网络请求，不知道从哪里来的。<br><figure class="highlight awk"><table><tr><td class="code"><pre><div class="line">https:<span class="regexp">//</span>cdn.mathjax.org<span class="regexp">/mathjax/</span>contrib<span class="regexp">/a11y/</span>accessibility-menu.js?V=<span class="number">2.7</span>.<span class="number">0</span></div></pre></td></tr></table></figure></p>
<p>而且说的<br><figure class="highlight arduino"><table><tr><td class="code"><pre><div class="line">Your <span class="built_in">config</span> will be merged into <span class="built_in">default</span> <span class="built_in">config</span>:</div></pre></td></tr></table></figure></p>
<p>似乎也没有。生成的代码为<br><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/x-mathjax-config"</span>&gt;</span><span class="actionscript"></span></div><div class="line">  MathJax.Hub.Config(<span class="string">""</span>);</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>配置目没有了？！！好在似乎没有影响使用，那就先暂时这样用着吧~~</p>
<p>[Refs]</p>
<ul>
<li><a href="http://jzqt.github.io/2015/06/30/Markdown%E4%B8%AD%E5%86%99%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/" target="_blank" rel="external">http://jzqt.github.io/2015/06/30/Markdown%E4%B8%AD%E5%86%99%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/</a></li>
<li><a href="https://www.zybuluo.com/codeep/note/163962" target="_blank" rel="external">https://www.zybuluo.com/codeep/note/163962</a></li>
<li><a href="http://oiltang.com/2014/05/04/markdown-and-mathjax/" target="_blank" rel="external">http://oiltang.com/2014/05/04/markdown-and-mathjax/</a></li>
<li><a href="http://www.jeyzhang.com/how-to-insert-equations-in-markdown.html" target="_blank" rel="external">http://www.jeyzhang.com/how-to-insert-equations-in-markdown.html</a></li>
<li><a href="http://www.52nlp.cn/%E5%9C%A8%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E9%87%8C%E4%BD%BF%E7%94%A8latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F" target="_blank" rel="external">http://www.52nlp.cn/%E5%9C%A8%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E9%87%8C%E4%BD%BF%E7%94%A8latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F</a></li>
<li><a href="https://github.com/mathjax/MathJax-node" target="_blank" rel="external">https://github.com/mathjax/MathJax-node</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近准备写一下机器学习的一些学习笔记， 由于涉及到大量数学公式， 发现不把如何在markdown里写数学公式这个问题解决了会严重影响工作效率。大概而言， 主要有两种方式：&lt;/p&gt;
    
    </summary>
    
      <category term="ML" scheme="http://magicly.me/categories/ML/"/>
    
    
      <category term="math" scheme="http://magicly.me/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>机器学习计划</title>
    <link href="http://magicly.me/2017/02/12/ml-content/"/>
    <id>http://magicly.me/2017/02/12/ml-content/</id>
    <published>2017-02-12T14:04:10.000Z</published>
    <updated>2017-02-23T02:46:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>机器学习已经影响了我们生活中的每一个地方， 了解一些机器学习知识， 便于提高竞争力， 避免被机器替代。<br>下面是我参考咨询了很多大牛之后搜集整理的一些学习资料， 基本都是该领域世界最顶尖的高手亲自授课，以及一些最流行的工具库， 值得学习。</p>
<a id="more"></a>
<p><em>. Andrew NG <a href="https://www.coursera.org/learn/machine-learning（已完成）" target="_blank" rel="external">https://www.coursera.org/learn/machine-learning（已完成）</a>
</em>. Andrew NG Unsupervised Feature Learning and Deep Learning <a href="http://deeplearning.stanford.edu/tutorial/（学习ing）" target="_blank" rel="external">http://deeplearning.stanford.edu/tutorial/（学习ing）</a><br><em>. <a href="http://neuralnetworksanddeeplearning.com/" target="_blank" rel="external">http://neuralnetworksanddeeplearning.com/</a> （已完成）
</em>. Andrew NG, standford的机器学习课程之一， <a href="http://cs229.stanford.edu/" target="_blank" rel="external">http://cs229.stanford.edu/</a><br><em>. Neural Networks for Machine Learning <a href="https://www.coursera.org/learn/neural-networks" target="_blank" rel="external">https://www.coursera.org/learn/neural-networks</a> by Geoffrey Hinton, Professor(深度学习创始人) （学习中）
</em>. 李飞飞课程<a href="http://cs231n.github.io/" target="_blank" rel="external">http://cs231n.github.io/</a><br><em>. 斯坦福自然语言处理 <a href="http://web.stanford.edu/class/cs224n/" target="_blank" rel="external">http://web.stanford.edu/class/cs224n/</a>
</em>. Tensorflow for Deep Learning Research <a href="http://web.stanford.edu/class/cs20si/" target="_blank" rel="external">http://web.stanford.edu/class/cs20si/</a><br><em>. 伯克利人工智能课程 <a href="http://www-inst.eecs.berkeley.edu/~cs188/archives.html" target="_blank" rel="external">http://www-inst.eecs.berkeley.edu/~cs188/archives.html</a>
</em>. <a href="http://www.deeplearningbook.org/" target="_blank" rel="external">http://www.deeplearningbook.org/</a>, by Ian Goodfellow and Yoshua Bengio（深度学习四大金刚之一） and Aaron Courville<br><em>. udacity深度学习课程tensorflow <a href="https://classroom.udacity.com/courses/ud730/（学习中）" target="_blank" rel="external">https://classroom.udacity.com/courses/ud730/（学习中）</a>
</em>. <a href="https://keras.io" target="_blank" rel="external">https://keras.io</a><br><em>. <a href="https://scikit-learn.org" target="_blank" rel="external">https://scikit-learn.org</a>
</em>. <a href="https://www.tensorflow.org" target="_blank" rel="external">https://www.tensorflow.org</a><br><em>. <a href="http://deeplearning.net/" target="_blank" rel="external">http://deeplearning.net/</a>
</em>. <a href="https://www.kaggle.com" target="_blank" rel="external">https://www.kaggle.com</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;机器学习已经影响了我们生活中的每一个地方， 了解一些机器学习知识， 便于提高竞争力， 避免被机器替代。&lt;br&gt;下面是我参考咨询了很多大牛之后搜集整理的一些学习资料， 基本都是该领域世界最顶尖的高手亲自授课，以及一些最流行的工具库， 值得学习。&lt;/p&gt;
    
    </summary>
    
      <category term="ML" scheme="http://magicly.me/categories/ML/"/>
    
    
      <category term="AI" scheme="http://magicly.me/tags/AI/"/>
    
      <category term="ML" scheme="http://magicly.me/tags/ML/"/>
    
      <category term="machine learning" scheme="http://magicly.me/tags/machine-learning/"/>
    
      <category term="deep learning" scheme="http://magicly.me/tags/deep-learning/"/>
    
      <category term="深度学习" scheme="http://magicly.me/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>bezier-curve</title>
    <link href="http://magicly.me/2016/11/29/bezier-curve/"/>
    <id>http://magicly.me/2016/11/29/bezier-curve/</id>
    <published>2016-11-29T03:09:52.000Z</published>
    <updated>2016-11-29T09:49:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是贝塞尔曲线"><a href="#什么是贝塞尔曲线" class="headerlink" title="什么是贝塞尔曲线"></a>什么是贝塞尔曲线</h1><p>最近做一个动画效果时需要将物体做曲线移动， 本来记得css3里的动画是可以指定beizer curve的， 结果用的时候发现css3的beizer curve只用来做easing timing function。简单来说就是拿来控制动画“非线性”移动，比如越来越快（ease-in）， 越来越慢（ease-out），先慢后快再慢（ease-in-out）等， 让动画效果更“灵动”， 避免线性（linear）的死板。</p>
<p>可以看看这两个页面， 有一个直观的感受。</p>
<a id="more"></a>
<ul>
<li><a href="http://cubic-bezier.com/" target="_blank" rel="external">http://cubic-bezier.com/</a></li>
<li><a href="http://easings.net/zh-cn" target="_blank" rel="external">http://easings.net/zh-cn</a></li>
</ul>
<p>beizer curve在css3中的使用， 可以自己google一下， 或者看下：</p>
<ul>
<li><a href="http://www.w3school.com.cn/css3/css3_transition.asp" target="_blank" rel="external">http://www.w3school.com.cn/css3/css3_transition.asp</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/02/css_transition_and_animation.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2014/02/css_transition_and_animation.html</a></li>
</ul>
<p>引用wiki上的介绍：<br><figure class="highlight armasm"><table><tr><td class="code"><pre><div class="line">在数学的数值分析领域中，贝塞尔曲线（英语：<span class="keyword">Bézier </span>curve）是计算机图形学中相当重要的参数曲线。更高维度的广泛化贝塞尔曲线就称作贝塞尔曲面，其中贝塞尔三角是一种特殊的实例。</div><div class="line">贝塞尔曲线于<span class="number">1962</span>年，由法国工程师皮埃尔·贝塞尔（Pierre <span class="keyword">Bézier）所广泛发表，他运用贝塞尔曲线来为汽车的主体进行设计。贝塞尔曲线最初由Paul </span>de Casteljau于<span class="number">1959</span>年运用de Casteljau算法开发，以稳定数值的方法求出贝塞尔曲线。</div></pre></td></tr></table></figure></p>
<p>有数学功底或者有兴趣的可以参考下面几篇文章， 我就不赘述了（最讨厌那种什么都要copy过来，弄得好像跟是自己写的样， 别人已经写得很清楚了， 干嘛再重复劳动一遍呢， 又没有自己的新的见解，赠人链接， 手留余香。 😁哈）。</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/B%C3%A9zier_curve" target="_blank" rel="external">https://en.wikipedia.org/wiki/B%C3%A9zier_curve</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E8%B2%9D%E8%8C%B2%E6%9B%B2%E7%B7%9A" target="_blank" rel="external">https://zh.wikipedia.org/wiki/%E8%B2%9D%E8%8C%B2%E6%9B%B2%E7%B7%9A</a></li>
<li><a href="http://www.html-js.com/article/1628" target="_blank" rel="external">http://www.html-js.com/article/1628</a></li>
<li><a href="http://www.cnblogs.com/hnfxs/p/3148483.html" target="_blank" rel="external">http://www.cnblogs.com/hnfxs/p/3148483.html</a></li>
<li></li>
</ul>
<h1 id="在线工具"><a href="#在线工具" class="headerlink" title="在线工具"></a>在线工具</h1><p>下面是几个比较有用的工具， 方便大家。</p>
<ul>
<li><a href="http://blogs.sitepointstatic.com/examples/tech/canvas-curves/quadratic-curve.html" target="_blank" rel="external">http://blogs.sitepointstatic.com/examples/tech/canvas-curves/quadratic-curve.html</a></li>
<li><a href="http://myst729.github.io/bezier-curve/" target="_blank" rel="external">http://myst729.github.io/bezier-curve/</a></li>
<li><a href="http://xuanfengge.com/easeing/ceaser/" target="_blank" rel="external">http://xuanfengge.com/easeing/ceaser/</a></li>
<li><a href="http://yisibl.github.io/cubic-bezier/#.17,.67,.83,.67" target="_blank" rel="external">http://yisibl.github.io/cubic-bezier/#.17,.67,.83,.67</a></li>
<li><a href="http://cubic-bezier.com/#.17,.67,.83,.67" target="_blank" rel="external">http://cubic-bezier.com/#.17,.67,.83,.67</a></li>
</ul>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>前面资料都是把bezier curve拿来当timing function的， 而我的需求是要让物体（某个dom节点）沿着某条beizer curve移动，于是继续google， 找到了几个。</p>
<ul>
<li>Android实现: <a href="https://github.com/Yasic/QQBubbleView" target="_blank" rel="external">https://github.com/Yasic/QQBubbleView</a></li>
</ul>
<p>Android的我用不到， 放这里主要是里面的gif图很直观，哈哈。</p>
<ul>
<li>CSS实现：<a href="http://jinlong.github.io/2016/01/14/moving-along-a-curved-path-in-css-with-layered-animation/，" target="_blank" rel="external">http://jinlong.github.io/2016/01/14/moving-along-a-curved-path-in-css-with-layered-animation/，</a> 原文：<a href="http://tobiasahlin.com/blog/curved-path-animations-in-css/" target="_blank" rel="external">http://tobiasahlin.com/blog/curved-path-animations-in-css/</a></li>
</ul>
<p>CSS的实现真是相当tricky， 我解释一下。CSS里面的animation translate是直接按照直线移动到目的地的， 这是因为沿X轴和Y轴都是匀速运动（linear），所以合成之后的速度必然是斜角45°移动过去的。我们可以把X轴看成时间轴， 这时如果Y轴的移动函数是某个beizer curve，那合成之后的移动曲线就是beizer curve了。具体实现的时候还用到了:after伪元素了。</p>
<p>复杂一点的我觉得还是需要用js去控制， 于是自然想到了用js代码去按照beizer curve公式实现。</p>
<ul>
<li>JS实现： <a href="http://blog.csdn.net/cuixiping/article/details/6872095" target="_blank" rel="external">http://blog.csdn.net/cuixiping/article/details/6872095</a></li>
</ul>
<p>这个用的公式不直观，应该是进行了变换之后的， 我直接照着公式写了一个。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="function">function <span class="title">PointOnCubicBezier2</span><span class="params">(cp, t)</span>  </span>&#123;</div><div class="line">   <span class="comment">// B(t) = P0 * (1-t)^3 + 3 * P1 * t * (1-t)^2 + 3 * P2 * t^2 * (1-t) + P3 * t^3</span></div><div class="line">        <span class="keyword">const</span> <span class="keyword">one_t</span> = <span class="number">1.0</span> - t;</div><div class="line">        <span class="keyword">const</span> P0 = cp[<span class="number">0</span>];</div><div class="line">        <span class="keyword">const</span> P1 = cp[<span class="number">1</span>];</div><div class="line">        <span class="keyword">const</span> P2 = cp[<span class="number">2</span>];</div><div class="line">        <span class="keyword">const</span> P3 = cp[<span class="number">3</span>];</div><div class="line">        <span class="keyword">const</span> x =  (P0.x * Math.<span class="built_in">pow</span>(<span class="keyword">one_t</span>, <span class="number">3</span>) + <span class="number">3</span> * P1.x * t * Math.<span class="built_in">pow</span>(<span class="keyword">one_t</span>, <span class="number">2</span>) + <span class="number">3</span> * P2.x * Math.<span class="built_in">pow</span>(t, <span class="number">2</span>) * <span class="keyword">one_t</span> + P3.x * Math.<span class="built_in">pow</span>(t, <span class="number">3</span>));</div><div class="line">        <span class="keyword">const</span> y =  (P0.y * Math.<span class="built_in">pow</span>(<span class="keyword">one_t</span>, <span class="number">3</span>) + <span class="number">3</span> * P1.y * t * Math.<span class="built_in">pow</span>(<span class="keyword">one_t</span>, <span class="number">2</span>) + <span class="number">3</span> * P2.y * Math.<span class="built_in">pow</span>(t, <span class="number">2</span>) * <span class="keyword">one_t</span> + P3.y * Math.<span class="built_in">pow</span>(t, <span class="number">3</span>));</div><div class="line">        <span class="keyword">const</span> pointF = <span class="keyword">new</span> Point2D(x, y);</div><div class="line">        <span class="keyword">return</span> pointF;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对比了一下两个函数的输出值， 完全是一样的， 应该就是数学变换而已， 我懒得去做推倒了。</p>
<p>后来找到一个三阶beizer curve的实现，看这里<br><a href="https://github.com/gre/bezier-easing，" target="_blank" rel="external">https://github.com/gre/bezier-easing，</a> 这个实现可能有点NB，以至于<a href="https://facebook.github.io/react-native/" target="_blank" rel="external">React Native</a>、<a href="http://velocityjs.org/" target="_blank" rel="external">Velocity</a>等项目都使用了，屌屌的。</p>
<p>用<a href="https://github.com/bestiejs/benchmark.js" target="_blank" rel="external">benchmark</a>跑一下分：<a href="https://jsperf.com/beizer-curve5" target="_blank" rel="external">看这里</a>， chrome下我写的方法居然慢了94%！看样子代码可读性是要付出代价的哈。我还是老老实实用<a href="https://github.com/gre/bezier-easing吧。" target="_blank" rel="external">https://github.com/gre/bezier-easing吧。</a></p>
<p>刚刚又搜到一篇文章， 讲解地更细致深入， 害得我不想继续写了。 直接看这里吧。<a href="http://www.jianshu.com/p/55c721887568" target="_blank" rel="external">http://www.jianshu.com/p/55c721887568</a></p>
<h1 id="如何将多个点用贝塞尔曲线连起来"><a href="#如何将多个点用贝塞尔曲线连起来" class="headerlink" title="如何将多个点用贝塞尔曲线连起来"></a>如何将多个点用贝塞尔曲线连起来</h1><ul>
<li><a href="http://www.zheng-hang.com/?id=43" target="_blank" rel="external">http://www.zheng-hang.com/?id=43</a></li>
<li><a href="http://www.cnblogs.com/hnfxs/p/3148743.html" target="_blank" rel="external">http://www.cnblogs.com/hnfxs/p/3148743.html</a></li>
<li></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是贝塞尔曲线&quot;&gt;&lt;a href=&quot;#什么是贝塞尔曲线&quot; class=&quot;headerlink&quot; title=&quot;什么是贝塞尔曲线&quot;&gt;&lt;/a&gt;什么是贝塞尔曲线&lt;/h1&gt;&lt;p&gt;最近做一个动画效果时需要将物体做曲线移动， 本来记得css3里的动画是可以指定beizer curve的， 结果用的时候发现css3的beizer curve只用来做easing timing function。简单来说就是拿来控制动画“非线性”移动，比如越来越快（ease-in）， 越来越慢（ease-out），先慢后快再慢（ease-in-out）等， 让动画效果更“灵动”， 避免线性（linear）的死板。&lt;/p&gt;
&lt;p&gt;可以看看这两个页面， 有一个直观的感受。&lt;/p&gt;
    
    </summary>
    
      <category term="FE" scheme="http://magicly.me/categories/FE/"/>
    
    
      <category term="js" scheme="http://magicly.me/tags/js/"/>
    
      <category term="css" scheme="http://magicly.me/tags/css/"/>
    
      <category term="animation" scheme="http://magicly.me/tags/animation/"/>
    
      <category term="beizer curve" scheme="http://magicly.me/tags/beizer-curve/"/>
    
  </entry>
  
  <entry>
    <title>利用webhook实现github pages的自动部署</title>
    <link href="http://magicly.me/2015/09/16/auto-deploy-githubPages-by-webhook-md/"/>
    <id>http://magicly.me/2015/09/16/auto-deploy-githubPages-by-webhook-md/</id>
    <published>2015-09-16T10:12:39.000Z</published>
    <updated>2016-11-29T02:57:46.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://blog.coderzh.com/2015/09/13/use-webhook-automated-deploy-hugo/?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io" target="_blank" rel="external">http://blog.coderzh.com/2015/09/13/use-webhook-automated-deploy-hugo/?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io</a></p>
<p>…</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://blog.coderzh.com/2015/09/13/use-webhook-automated-deploy-hugo/?hmsr=toutiao.io&amp;amp;utm_medium=toutiao.io&amp;amp;utm_source=t
    
    </summary>
    
      <category term="default" scheme="http://magicly.me/categories/default/"/>
    
    
      <category term="github" scheme="http://magicly.me/tags/github/"/>
    
      <category term="webhook" scheme="http://magicly.me/tags/webhook/"/>
    
      <category term="ssh" scheme="http://magicly.me/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>javascript箭头函数</title>
    <link href="http://magicly.me/2015/09/07/js-arrow-functions-md/"/>
    <id>http://magicly.me/2015/09/07/js-arrow-functions-md/</id>
    <published>2015-09-07T12:48:42.000Z</published>
    <updated>2016-11-29T02:57:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>javascript es6 arrow function.</p>
<a id="more"></a>
<p>开始学习ES6.<br><a href="https://hacks.mozilla.org/category/es6-in-depth/" target="_blank" rel="external">https://hacks.mozilla.org/category/es6-in-depth/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;javascript es6 arrow function.&lt;/p&gt;
    
    </summary>
    
      <category term="JS" scheme="http://magicly.me/categories/JS/"/>
    
    
      <category term="js" scheme="http://magicly.me/tags/js/"/>
    
      <category term="javascript" scheme="http://magicly.me/tags/javascript/"/>
    
      <category term="es6" scheme="http://magicly.me/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>利用SSH反向通道在本地调试微信公共号</title>
    <link href="http://magicly.me/2015/07/26/ssh-reverse-tunnel-wx-local/"/>
    <id>http://magicly.me/2015/07/26/ssh-reverse-tunnel-wx-local/</id>
    <published>2015-07-26T03:40:25.000Z</published>
    <updated>2016-11-29T02:57:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>微信公共号现在很火，一些简单的应用，做一个公共号比开发一款app成本要小很多，而且利用朋友圈的转发，相比app去app store里上架等着用户下载，要容易很多。</p>
<p>但是微信公共号的调试有点不方便，必须在微信<a href="https://mp.weixin.qq.com/" target="_blank" rel="external">管理后台</a>配置一个微信能访问到（公网）的url，然后在公共号里输入内容，微信以xml格式转发给这个url，url回复之后微信再将response回复给使用公共号的微信用户。当然微信也提供了<a href="http://mp.weixin.qq.com/debug" target="_blank" rel="external">调试工具</a>， 可以直接构造数据，方便调试各个接口。 但是依然需要一个公网的url作为接口。于是最原始的开发方式就是，修改代码，上传到server，（如果是有些静态语言还需要重启服务器），然后看是否正常work，如果不行的话，在可能错误的地方打出log，然后又是修改代码，上传server，重启。。。。。就这样，每次改一点点，你都可以泡杯咖啡了，老板就会觉得你很闲。参看<a href="http://www.oschina.net/news/15579/reasons-why-people-who-work-with-computers-seem-to" target="_blank" rel="external">为什么搞计算机工作的人总是看上去很清闲</a>。</p>
<a id="more"></a>
<p>有没有办法可以直接在本地调试呢，简单说，就是微信把数据传到我本地的电脑上，我每次改完代码，不用重新上传server，直接在本地加log等。经过研究，找到几个方法，记录下来，与大家分享，绝对能节约很多很多很多时间，然后就可以去陪妹纸了， 如果你有的话，没有的话<a href="http://www.zhihu.com/question/20385321" target="_blank" rel="external">here</a>。</p>
<p>第一种方法，你本地电脑有公网ip。比如家里宽带，没用路由，直接把网线插上，应该就是公网IP，吧。 如果家里有多人使用，你可以再路由器里配置NAT地址转换。自行<a href="https://www.google.com.hk/webhp?sourceid=chrome-instant&amp;ion=1&amp;espv=2&amp;ie=UTF-8#q=NAT%20%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2" target="_blank" rel="external">Google</a>吧。</p>
<p>第二种，也是我搜到的最多的，用ngrok这个神器！网上一堆资料，比如<a href="http://www.mbnow.tk/2014/12/05/ngrok/" target="_blank" rel="external">这个</a>，我Google到的最多的也是这个，而且看上去也应该很简单。 <a href="http://www.oray.com/" target="_blank" rel="external">花生壳</a>我10年前用过（x，不小心暴露年龄了），应该是一样的。网上说，缺点是</p>
<blockquote>
<p>不过 ngrok 速度较慢，微信服务器对实时性要求较高，每次通信超过 5 秒便超时，所以此法也不建议使用。</p>
</blockquote>
<p>我觉得用花生壳的话可能好点，因为是国内的（有兴趣的可以自己去试试哈）。没有用ngrok试一下，因为“无法显示此网页”！网上就是“骗子”多，明明没有的网站，大家都描绘的绘声绘色。</p>
<p>第三种，用ssh建立反向通道。对了，使用此种方法，你还是需要一个公网IP的。 作为一名专业工程师，拥有公网 ip 地址的 VPS 服务器基本成了标配，<a href="http://www.qcloud.com/redirect.php?redirect=1002&amp;cps_key=0a3641075e434bf76a016a44d2918e4a" target="_blank" rel="external">腾讯云VPS</a> 最便宜的一款每年也就几百块钱，平时挂挂自己喜欢的服务，做个站长，跑跑自己的开源项目甚爽。</p>
<ol>
<li>申请<a href="http://www.qcloud.com/redirect.php?redirect=1001&amp;cps_key=0a3641075e434bf76a016a44d2918e4a" target="_blank" rel="external">腾讯云</a></li>
<li>本地安装ssh，如果是linux或mac，都是自带的。如果是windows的话，可以安装<a href="https://www.cygwin.com/" target="_blank" rel="external">Cygwin</a>，如果你嫌弃它太重了，安装了<a href="https://git-scm.com/download/gui/win" target="_blank" rel="external">Git</a>也是可以的。如果你也不想装或者不会装Git，额，(⊙o⊙)…，好吧，那你还是不要写程序了。</li>
<li>建立ssh反向通道。<br>这一步里有很多坑，我花了差不多一天才完全搞定。你们可以先参考这几篇文章，了解下原理啥的。<ul>
<li><a href="http://blog.zjutoe.net/?p=95" target="_blank" rel="external">http://blog.zjutoe.net/?p=95</a></li>
<li><a href="http://my.oschina.net/abcfy2/blog/177094" target="_blank" rel="external">http://my.oschina.net/abcfy2/blog/177094</a></li>
<li><a href="http://www.zzbaike.com/wiki/PuTTY/Putty%E5%BB%BA%E7%AB%8B%E9%9A%A7%E9%81%93%E7%9A%84%E6%96%B9%E6%B3%95" target="_blank" rel="external">http://www.zzbaike.com/wiki/PuTTY/Putty%E5%BB%BA%E7%AB%8B%E9%9A%A7%E9%81%93%E7%9A%84%E6%96%B9%E6%B3%95</a></li>
<li><a href="http://www.freeoa.net/osuport/netmanage/linux-ssh-tunneling-proxy_1892.html" target="_blank" rel="external">http://www.freeoa.net/osuport/netmanage/linux-ssh-tunneling-proxy_1892.html</a></li>
<li><a href="https://qdan.me/list/VOSXmsI4tv7fIciF" target="_blank" rel="external">https://qdan.me/list/VOSXmsI4tv7fIciF</a></li>
</ul>
</li>
</ol>
<p>好吧，来看我的具体一步一步做法。</p>
<ol>
<li><p>ssh -R 9999:localhost:9000 ubuntu@myserver_ip_address，输入密码</p>
</li>
<li><p>server上查看一下是否监听了9999端口，netstat -anltp | grep 9999</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">ubuntu@VM-39-45-ubuntu:~$ netstat -anltp | grep 9999</div><div class="line">(Not all processes could be identified, non-owned process info</div><div class="line">will not be shown, you would have to be root to see it all.)</div><div class="line">tcp        0      0 127.0.0.1:9999          0.0.0.0:*               LISTEN      -</div><div class="line">tcp6       0      0 ::1:9999                :::*                    LISTEN      -</div></pre></td></tr></table></figure>
</li>
<li><p>在本地9000（我用的<a href="https://www.playframework.com/documentation/1.3.x/home" target="_blank" rel="external">play 1</a>，可以了解下它到底为啥这么好用<a href="http://segmentfault.com/a/1190000000374033" target="_blank" rel="external">Play Framework —— Java开发者的梦想框架</a>）上开启web服务</p>
</li>
<li><p>在浏览器里输入<a href="http://myserver_ip_address:9999，" target="_blank" rel="external">http://myserver_ip_address:9999，</a> 居然是没有响应！奇怪！直接在server上用curl <a href="http://localhost:9999" target="_blank" rel="external">http://localhost:9999</a> 是可以的！仔细看netstat输出，发现监听的9999端口是本地的！！！也就是说只能在本地访问，那有xx用啊！！！</p>
</li>
<li><p>看看ssh –help， 原来是可以指定bind_address的， man ssh看看</p>
<blockquote>
<p>By default, the listening socket on the server will be bound to the loopback interface only.  This may be overridden by specifying a bind_address. An empty bind_address, or the address ‘*’, indicates that the remote socket should listen on all interfaces.  Specifying a remote bind_address will only succeed if the server’s GatewayPorts option is enabled (see sshd_config(5)).</p>
</blockquote>
<p>继续看看 man sshd_config</p>
<blockquote>
<p>GatewayPorts<br>Specifies whether remote hosts are allowed to connect to ports forwarded for the client.  By default, sshd(8) binds remote port forwardings to the<br>loopback address.  This prevents other remote hosts from connecting to forwarded ports.  GatewayPorts can be used to specify that sshd should allow<br> remote port forwardings to bind to non-loopback addresses, thus allowing other hosts to connect.  The argument may be “no” to force remote port<br> forwardings to be available to the local host only, “yes” to force remote port forwardings to bind to the wildcard address, or “clientspecified” to<br> allow the client to select the address to which the forwarding is bound.  The default is “no”.</p>
</blockquote>
<p>sudo vim /etc/ssh/sshd_config，添加GatewayPorts clientspecified，GatewayPorts yes也可以，退出，sudo service sshd restart，重启ssh服务。重新ssh -R :9999:localhost:9000 ubuntu@myserver_ip_address（仔细看，就9999前多了一个冒号:），输入密码，netstat -anltp | grep 9999，果然</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><div class="line"><span class="selector-tag">tcp</span>        0      0 0<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-pseudo">:9999</span>            0<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.0</span>:*               <span class="selector-tag">LISTEN</span>      <span class="selector-tag">-</span></div><div class="line"><span class="selector-tag">tcp6</span>       0      0 :<span class="selector-pseudo">::9999</span>                 :::*                    <span class="selector-tag">LISTEN</span>      <span class="selector-tag">-</span></div></pre></td></tr></table></figure>
<p> 浏览器里输入<a href="http://myserver_ip_address:9999，" target="_blank" rel="external">http://myserver_ip_address:9999，</a> 这回可以看到本地打出日志了。</p>
</li>
<li><p>然后发现微信里面配置的url只能是80端口。简单，直接改成ssh -R :80:localhost:9000 ubuntu@myserver_ip_address就可以了，吧！奇怪，直接访问<a href="http://myserver_ip_address，" target="_blank" rel="external">http://myserver_ip_address，</a> 打不开网页！用netstat -anltp | grep 80，居然什么都没有！说明server没有在80端口监听呀！哦，对了ubuntu低于1024的端口是需要用root权限的。</p>
</li>
<li><p>ubuntu里root默认是关闭的。sudo passwd root，设置root密码后，可以打开。还需要在sudo vim /etc/ssh/sshd_config    添加</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><div class="line"><span class="comment">#PermitRootLogin without-password</span></div><div class="line"><span class="attribute">PermitRootLogin</span> <span class="literal">yes</span></div></pre></td></tr></table></figure>
</li>
<li><p>重启ssh，再重新用root账号连接，ssh -R :80:localhost:9000 root@myserver_ip_address， 一切ok，<a href="http://myserver_ip_address，" target="_blank" rel="external">http://myserver_ip_address，</a> 本地代码打出日志，说明流量已经导入到本地了。</p>
</li>
<li>最后，就可以在<a href="http://mp.weixin.qq.com/debug" target="_blank" rel="external">微信公众平台接口调试工具</a>里调试了，配合<a href="http://playframework.com/" target="_blank" rel="external">Play!</a>的hot reload，随时修改代码，加log，然后马上就可以看到效果，不用重新编译，不用上传server，不用重启。。。。生活真是幸福美满啊。。。。</li>
<li>几个问题说明：<ol>
<li>直接用ssh连接的话，断开之后端口映射就没有了，可以用autossh， 只是我就是临时需要调试用的时候才ssh建立反向隧道，所以我不用autossh。</li>
<li>直接用root登陆ssh，开通80端口。应该是有安全隐患的， 吧！对安全不是很了解，但感觉直接用root肯定不是最佳实践。网上有各种方法解决这个问题，比如用iptables端口映射，或者nginx反向代理的，<a href="http://stackoverflow.com/questions/23281895/node-js-eacces-error-when-listening-on-http-80-port-permission-denied" target="_blank" rel="external">看这里</a>，参看1的原因，我没有采用。还是一次focus一个点吧，不然光环境就配置几天，有点太慢了。</li>
</ol>
</li>
</ol>
<p>通过本文的配置，可以在本地方便的开发调试微信公共号了。但是对于微信提供的<a href="http://mp.weixin.qq.com/wiki/7/aaa137b55fb2e0456bf8dd9148dd613f.html" target="_blank" rel="external">JS-SDK</a>，又存在另外的问题，这个我会<a href="http://my.oschina.net/magicly007/blog/480704" target="_blank" rel="external">另外写一篇blog来解决</a>。毕竟，我们程序员应该坚持<a href="https://en.wikipedia.org/wiki/Single_responsibility_principle" target="_blank" rel="external">Single responsibility principle</a>嘛。</p>
<p>Refs</p>
<ol>
<li><a href="http://www.mbnow.tk/2014/12/05/ngrok/" target="_blank" rel="external">http://www.mbnow.tk/2014/12/05/ngrok/</a></li>
<li><a href="http://my.oschina.net/jfinal/blog/336861" target="_blank" rel="external">http://my.oschina.net/jfinal/blog/336861</a></li>
<li><a href="http://www.mbnow.tk/2014/12/05/ngrok/" target="_blank" rel="external">http://www.mbnow.tk/2014/12/05/ngrok/</a></li>
<li><a href="http://liyaodong.com/2015/07/06/%E5%BE%AE%E4%BF%A1%E8%B0%83%E8%AF%95%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/" target="_blank" rel="external">http://liyaodong.com/2015/07/06/%E5%BE%AE%E4%BF%A1%E8%B0%83%E8%AF%95%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/</a></li>
<li><a href="http://my.oschina.net/abcfy2/blog/177094" target="_blank" rel="external">http://my.oschina.net/abcfy2/blog/177094</a></li>
<li><a href="http://www.zhihu.com/question/25456655" target="_blank" rel="external">http://www.zhihu.com/question/25456655</a></li>
<li>. <a href="http://my.oschina.net/atanl/blog/391611" target="_blank" rel="external">http://my.oschina.net/atanl/blog/391611</a></li>
</ol>
<blockquote>
<p>Written with <a href="https://stackedit.io/" target="_blank" rel="external">StackEdit</a>.</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;微信公共号现在很火，一些简单的应用，做一个公共号比开发一款app成本要小很多，而且利用朋友圈的转发，相比app去app store里上架等着用户下载，要容易很多。&lt;/p&gt;
&lt;p&gt;但是微信公共号的调试有点不方便，必须在微信&lt;a href=&quot;https://mp.weixin.qq.com/&quot;&gt;管理后台&lt;/a&gt;配置一个微信能访问到（公网）的url，然后在公共号里输入内容，微信以xml格式转发给这个url，url回复之后微信再将response回复给使用公共号的微信用户。当然微信也提供了&lt;a href=&quot;http://mp.weixin.qq.com/debug&quot;&gt;调试工具&lt;/a&gt;， 可以直接构造数据，方便调试各个接口。 但是依然需要一个公网的url作为接口。于是最原始的开发方式就是，修改代码，上传到server，（如果是有些静态语言还需要重启服务器），然后看是否正常work，如果不行的话，在可能错误的地方打出log，然后又是修改代码，上传server，重启。。。。。就这样，每次改一点点，你都可以泡杯咖啡了，老板就会觉得你很闲。参看&lt;a href=&quot;http://www.oschina.net/news/15579/reasons-why-people-who-work-with-computers-seem-to&quot;&gt;为什么搞计算机工作的人总是看上去很清闲&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="weixin" scheme="http://magicly.me/categories/weixin/"/>
    
    
      <category term="ssh" scheme="http://magicly.me/tags/ssh/"/>
    
      <category term="weixin" scheme="http://magicly.me/tags/weixin/"/>
    
      <category term="微信" scheme="http://magicly.me/tags/%E5%BE%AE%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>我的第一个hexo Blog</title>
    <link href="http://magicly.me/2015/07/26/my-first-hexo-blog/"/>
    <id>http://magicly.me/2015/07/26/my-first-hexo-blog/</id>
    <published>2015-07-26T03:09:45.000Z</published>
    <updated>2016-11-29T02:57:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>引用<a href="http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html" target="_blank" rel="external">阮老师</a>的话，</p>
<blockquote>
<p>喜欢写Blog的人，会经历三个阶段。</p>
<pre><code>第一阶段，刚接触Blog，觉得很新鲜，试着选择一个免费空间来写。
第二阶段，发现免费空间限制太多，就自己购买域名和空间，搭建独立博客。
第三阶段，觉得独立博客的管理太麻烦，最好在保留控制权的前提下，让别人来管，自己只负责写文章。
</code></pre></blockquote>
<p>自己比较懒惰，也就偶尔在<a href="http://my.oschina.net/magicly007/blog" target="_blank" rel="external">OC</a>上写点闲散的笔记，最近觉得还是应该要把自己的知识系统地梳理一下，便决定开一个独立的域名，自己记录Blog。</p>
<p>之前就了解Github Pages，也断断续续用MarkDown写过几篇放着，但是没有用<a href="http://jekyllrb.com/" target="_blank" rel="external">jekyll</a>，或者<a href="http://octopress.org/" target="_blank" rel="external">octpress</a>等串起来，上个月再次想配置好jekyll，结果在mac下始终配置不好（怪我咯）。今天决定一定要配置好，搜集了大量资料（google “jekyll 像黑客一样”），结果意外在<a href="http://www.douban.com/group/topic/39939196/" target="_blank" rel="external">http://www.douban.com/group/topic/39939196/</a>的回复中看到“用pelican吧 python的 还有hexo是nodejs的 ”。因为最近刚好在看nodejs，觉得很有兴趣，于是改为尝试<a href="https://hexo.io/zh-cn/" target="_blank" rel="external">hexo</a>。</p>
<a id="more"></a>
<p>#简介</p>
<p><a href="http://ibruce.info/2013/11/22/hexo-your-blog/" target="_blank" rel="external">http://ibruce.info/2013/11/22/hexo-your-blog/</a></p>
<blockquote>
<p>hexo出自台湾大学生<a href="https://twitter.com/tommy351" target="_blank" rel="external">tommy351</a>之手，是一个基于<a href="https://nodejs.org/" target="_blank" rel="external">Node.js</a>的静态博客程序，其编译上百篇文字只需要几秒。hexo生成的静态网页可以直接放到GitHub Pages，BAE，SAE等平台上。先看看tommy是如何吐槽Octopress的 →＿→ <a href="http://zespia.tw/blog/2012/10/11/hexo-debut/" target="_blank" rel="external">Hexo颯爽登場</a>。</p>
</blockquote>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>首先安装Node.js，然后运行<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">npm install -g hexo-cli</div><div class="line">npm install hexo --save</div></pre></td></tr></table></figure></p>
<h1 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h1><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">hexo init</div><div class="line">npm install</div></pre></td></tr></table></figure>
<h1 id="写blog"><a href="#写blog" class="headerlink" title="写blog"></a>写blog</h1><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">hexo n</div></pre></td></tr></table></figure>
<h1 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h1><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">hexo g</div></pre></td></tr></table></figure>
<h1 id="本地预览"><a href="#本地预览" class="headerlink" title="本地预览"></a>本地预览</h1><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">hexo s</div></pre></td></tr></table></figure>
<h1 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h1><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">hexo d</div></pre></td></tr></table></figure>
<p>实在觉得没必<a href="https://en.wikipedia.org/wiki/Reinventing_the_wheel" target="_blank" rel="external">重复造轮子</a>，重写已经有很详细资料的东西。强烈推荐<a href="http://ibruce.info/2013/11/22/hexo-your-blog/" target="_blank" rel="external">这篇</a>。 我觉得基本涵盖了方方面面，如果以后有新东西这里面没有的，我再写吧~</p>
<p>Refs</p>
<ol>
<li><a href="http://ibruce.info/2013/11/22/hexo-your-blog/" target="_blank" rel="external">http://ibruce.info/2013/11/22/hexo-your-blog/</a></li>
<li><a href="http://wsgzao.github.io/post/hexo-guide/" target="_blank" rel="external">http://wsgzao.github.io/post/hexo-guide/</a></li>
<li><a href="http://www.jianshu.com/p/05289a4bc8b2" target="_blank" rel="external">http://www.jianshu.com/p/05289a4bc8b2</a></li>
<li><a href="http://yangjian.me/workspace/building-blog-with-hexo/" target="_blank" rel="external">http://yangjian.me/workspace/building-blog-with-hexo/</a></li>
<li><a href="http://yangjian.me/workspace/building-blog-with-hexo/" target="_blank" rel="external">http://yangjian.me/workspace/building-blog-with-hexo/</a></li>
<li><a href="http://blog.csdn.net/jackystudio/article/details/16117585" target="_blank" rel="external">http://blog.csdn.net/jackystudio/article/details/16117585</a></li>
</ol>
<blockquote>
<p>Written with <a href="https://stackedit.io/" target="_blank" rel="external">StackEdit</a>.</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引用&lt;a href=&quot;http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html&quot;&gt;阮老师&lt;/a&gt;的话，&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;喜欢写Blog的人，会经历三个阶段。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;第一阶段，刚接触Blog，觉得很新鲜，试着选择一个免费空间来写。
第二阶段，发现免费空间限制太多，就自己购买域名和空间，搭建独立博客。
第三阶段，觉得独立博客的管理太麻烦，最好在保留控制权的前提下，让别人来管，自己只负责写文章。
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;自己比较懒惰，也就偶尔在&lt;a href=&quot;http://my.oschina.net/magicly007/blog&quot;&gt;OC&lt;/a&gt;上写点闲散的笔记，最近觉得还是应该要把自己的知识系统地梳理一下，便决定开一个独立的域名，自己记录Blog。&lt;/p&gt;
&lt;p&gt;之前就了解Github Pages，也断断续续用MarkDown写过几篇放着，但是没有用&lt;a href=&quot;http://jekyllrb.com/&quot;&gt;jekyll&lt;/a&gt;，或者&lt;a href=&quot;http://octopress.org/&quot;&gt;octpress&lt;/a&gt;等串起来，上个月再次想配置好jekyll，结果在mac下始终配置不好（怪我咯）。今天决定一定要配置好，搜集了大量资料（google “jekyll 像黑客一样”），结果意外在&lt;a href=&quot;http://www.douban.com/group/topic/39939196/&quot;&gt;http://www.douban.com/group/topic/39939196/&lt;/a&gt;的回复中看到“用pelican吧 python的 还有hexo是nodejs的 ”。因为最近刚好在看nodejs，觉得很有兴趣，于是改为尝试&lt;a href=&quot;https://hexo.io/zh-cn/&quot;&gt;hexo&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="default" scheme="http://magicly.me/categories/default/"/>
    
    
      <category term="github" scheme="http://magicly.me/tags/github/"/>
    
      <category term="hexo" scheme="http://magicly.me/tags/hexo/"/>
    
      <category term="githubPages" scheme="http://magicly.me/tags/githubPages/"/>
    
  </entry>
  
  <entry>
    <title>Java发送邮件</title>
    <link href="http://magicly.me/2015/07/13/java-email/"/>
    <id>http://magicly.me/2015/07/13/java-email/</id>
    <published>2015-07-13T13:34:10.000Z</published>
    <updated>2016-11-29T02:57:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>需要在代码里面发邮件是很经常的事情，包括找回密码，通知用户领奖，监控报警等。</p>
<p>在Java里面实现比较简单，Oracle自己提供了<a href="http://www.oracle.com/technetwork/java/javasebusiness/downloads/java-archive-downloads-eeplat-419426.html#javamail-1.4.7-oth-JPR" target="_blank" rel="external">JavaMail</a>， 不过API比较底层，用起来不方便，可以自己封装下，也可以直接使用Apache的开源项目<a href="https://commons.apache.org/proper/commons-email/" target="_blank" rel="external">Commons Email</a>。 下面的代码，可以以小马哥的名义给自己发邮件，该功能仅用于测试，请谨慎使用，产生的问题，本人概不负责。 /微笑</p>
<a id="more"></a>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><div class="line"><span class="meta"><span class="meta-keyword">import</span> org.apache.commons.mail.EmailAttachment;</span></div><div class="line"><span class="meta"><span class="meta-keyword">import</span> org.apache.commons.mail.EmailException;</span></div><div class="line"><span class="meta"><span class="meta-keyword">import</span> org.apache.commons.mail.MultiPartEmail;</span></div><div class="line"></div><div class="line"><span class="meta"><span class="meta-keyword">import</span> java.net.MalformedURLException;</span></div><div class="line"><span class="meta"><span class="meta-keyword">import</span> java.net.URL;</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by magicalli on 2015/7/6.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiPartEmailTest</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) throws EmailException, MalformedURLException &#123;</div><div class="line">        MultiPartEmail email = <span class="keyword">new</span> MultiPartEmail();</div><div class="line"></div><div class="line">        email.setHostName(<span class="string">"smtp.tencent.com"</span>);</div><div class="line"><span class="comment">//        email.setAuthentication("youremail@tencent.com", "***");//邮件服务器验证：用户名/密码</span></div><div class="line">        email.setCharset(<span class="string">"UTF-8"</span>);</div><div class="line"></div><div class="line">        email.setFrom(<span class="string">"pony@qq.com"</span>, <span class="string">"马化腾"</span>);</div><div class="line">        email.addTo(<span class="string">"magicalli@tencent.com"</span>);</div><div class="line"></div><div class="line">        email.setSubject(<span class="string">"加油奋斗！"</span>);</div><div class="line">        email.setMsg(<span class="string">"come on! 加油奋斗吧，早晚有一天你会出任CEO，迎娶白富美，走上人生巅峰！ http://www.qq.com\n\n\n pony"</span>);</div><div class="line"></div><div class="line">        EmailAttachment attachment = <span class="keyword">new</span> EmailAttachment();</div><div class="line">        attachment.setPath(<span class="string">"d:/lzl.jpg"</span>);<span class="comment">// 本地文件</span></div><div class="line">        attachment.setDisposition(EmailAttachment.ATTACHMENT);</div><div class="line">        attachment.setDescription(<span class="string">"林志玲1"</span>);</div><div class="line">        attachment.setName(<span class="string">"lzl_1"</span>);</div><div class="line">        email.attach(attachment);</div><div class="line"></div><div class="line">        EmailAttachment attachment2 = <span class="keyword">new</span> EmailAttachment();</div><div class="line">        attachment2.setURL(<span class="keyword">new</span> URL(<span class="string">"http://mat1.qq.com/datalib_img/star/pic/lib/2007-01-15/2007011511104716122311.jpg"</span>));<span class="comment">//远程文件, 如果不是qq.com域名下，内网是访问不了的哈</span></div><div class="line">        attachment2.setDisposition(EmailAttachment.ATTACHMENT);</div><div class="line">        attachment2.setDescription(<span class="string">"林志玲2"</span>);</div><div class="line">        attachment2.setName(<span class="string">"lzl_2"</span>);</div><div class="line">        email.attach(attachment2);</div><div class="line"></div><div class="line">        email.send();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://commons.apache.org/proper/commons-email/" target="_blank" rel="external">Commons Email</a>支持好几种格式，包括简单文本，html，带附件等。需要的可以自己查看文档。</p>
<p>基于smtp的协议邮件协议很简单，大家甚至可以直接用telnet来发送，可以参考这边文章<a href="http://blog.csdn.net/ghsau/article/details/8602076" target="_blank" rel="external">Java Mail(一)：telnet实现发送收取邮件</a>. </p>
<p>一般公司内网没有验证发送方，你可以冒充公司任何一个员工发送邮件（包括你们老板），一般外面的邮件服务器，比如qq, 126, 163等，是需要验证密码的。</p>
<p>重申一遍，别用这个代码干坏事，后果自负， 与本人无关！</p>
<p>Refs</p>
<ol>
<li><a href="http://blog.csdn.net/ghsau/article/details/8602076" target="_blank" rel="external">http://blog.csdn.net/ghsau/article/details/8602076</a></li>
<li><a href="http://blog.csdn.net/ghsau/article/details/17839983" target="_blank" rel="external">http://blog.csdn.net/ghsau/article/details/17839983</a></li>
<li><a href="http://haolloyin.blog.51cto.com/1177454/354320" target="_blank" rel="external">http://haolloyin.blog.51cto.com/1177454/354320</a></li>
<li><a href="http://www.runoob.com/java/java-sending-email.html" target="_blank" rel="external">http://www.runoob.com/java/java-sending-email.html</a></li>
<li><a href="https://commons.apache.org/proper/commons-email/" target="_blank" rel="external">https://commons.apache.org/proper/commons-email/</a></li>
<li><a href="http://blog.csdn.net/qiaqia609/article/details/11580589" target="_blank" rel="external">http://blog.csdn.net/qiaqia609/article/details/11580589</a></li>
</ol>
<blockquote>
<p>Written with <a href="https://stackedit.io/" target="_blank" rel="external">StackEdit</a>.</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      this is desc.
    
    </summary>
    
      <category term="Java" scheme="http://magicly.me/categories/Java/"/>
    
    
      <category term="Java" scheme="http://magicly.me/tags/Java/"/>
    
      <category term="Email" scheme="http://magicly.me/tags/Email/"/>
    
      <category term="JavaMail" scheme="http://magicly.me/tags/JavaMail/"/>
    
      <category term="Apache Commons" scheme="http://magicly.me/tags/Apache-Commons/"/>
    
  </entry>
  
  <entry>
    <title>一个Java对象到底有多大</title>
    <link href="http://magicly.me/2015/06/13/how-big-is-a-java-object/"/>
    <id>http://magicly.me/2015/06/13/how-big-is-a-java-object/</id>
    <published>2015-06-13T13:34:10.000Z</published>
    <updated>2016-11-29T02:57:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>经常遇到一个问题，需要在内存里缓存一批数据来提高效率（避免每次都读取DB）。那问题来了，这些对象到底会占用多大内存呢，这直接决定了可以缓存多少条记录，以及上线之后是否会内存不够等问题。</p>
<p>来看几种解决方法。</p>
<a id="more"></a>
<p>#测试</p>
<p>实践是检验真理的唯一标准！比如你要想cache10w条记录，那你就把10w条记录加载到内存，然后看看到底用了多少内存。至于怎么看内存花了多少，你可以</p>
<ol>
<li>任务管理器</li>
<li>top</li>
<li>Java Runtime类</li>
<li>blabla。。。。</li>
</ol>
<p>我们来看看直接从Java程序里能获取到的Runtime。</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.*;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by magicalli on 2015/2/3.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> class TestMemory &#123;</div><div class="line">    <span class="keyword">static</span> class A &#123;</div><div class="line">        <span class="built_in">int</span> a;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">        System.out.<span class="built_in">println</span>(<span class="string">"--- Memory Usage ---:"</span>);</div><div class="line">        Runtime rt = Runtime.getRuntime();</div><div class="line">        <span class="comment">//打印总内存大小 //打印空闲内存大小 //打印已用内存大小 单位(字节)</span></div><div class="line">        <span class="keyword">long</span> usedMemory = rt.totalMemory() - rt.freeMemory();</div><div class="line">        System.out.<span class="built_in">println</span>(<span class="string">"Total Memory= "</span> + rt.totalMemory() + <span class="string">" Free Memory = "</span> + rt.freeMemory() + <span class="string">" Used　Memory="</span> + usedMemory);</div><div class="line"></div><div class="line">        <span class="comment">// 把你要测试的占用内存的代码放在这里------start--------------</span></div><div class="line">        <span class="keyword">final</span> <span class="built_in">int</span> N = <span class="number">100000</span>;</div><div class="line">        <span class="built_in">int</span>[] arr = <span class="keyword">new</span> <span class="built_in">int</span>[N];</div><div class="line">        Integer[] arr2 = <span class="keyword">new</span> Integer[N];</div><div class="line">        A[] arrA = <span class="keyword">new</span> A[N];</div><div class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</div><div class="line">            arr[i] = i;</div><div class="line"><span class="comment">//            arr2[i] = i;</span></div><div class="line"><span class="comment">//            arrA[i] = new A();</span></div><div class="line">        &#125;</div><div class="line"><span class="comment">//        List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span></div><div class="line">        Map&lt;Integer, <span class="keyword">String</span>&gt; <span class="built_in">map</span> = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;Integer, <span class="keyword">String</span>&gt;();</div><div class="line"><span class="comment">//        for (int i = 0; i &lt; N; i++) &#123;</span></div><div class="line"><span class="comment">//            list.add(i);</span></div><div class="line"><span class="comment">//            map.put(i, UUID.randomUUID().toString());</span></div><div class="line"><span class="comment">//        &#125;</span></div><div class="line"><span class="comment">//        System.out.println(map.size());</span></div><div class="line">        <span class="comment">// 把你要测试的占用内存的代码放在这里------end--------------</span></div><div class="line"></div><div class="line">        <span class="keyword">long</span> usedMemory2 = rt.totalMemory() - rt.freeMemory();</div><div class="line">        System.out.<span class="built_in">println</span>(<span class="string">"Total Memory= "</span> + rt.totalMemory() + <span class="string">" Free Memory = "</span> + rt.freeMemory() + <span class="string">" Used　Memory="</span> + usedMemory2);</div><div class="line">        <span class="keyword">long</span> objMemory = usedMemory2 - usedMemory;</div><div class="line">        System.out.<span class="built_in">println</span>(<span class="string">"object use memory: "</span> + objMemory / <span class="number">1024</span> + <span class="string">"k"</span> + <span class="string">" each is: "</span> + objMemory / N);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面方法的最大好处就是可以直接获得实际占用内存大小，是比较简单有效的方法。不好的地方就是如果数据量比较小，可能偏差比较大，而且你也不能解释为什么Integer[]比int[]占用内存大很多，关键是专家说：这种内存占用应该是心里算出来的，你还要去run一下程序，明显就low了，还想晋级？再练练吧！所以我们来看看怎么掐指一算！</p>
<p>#计算</p>
<p>这个需要了解JVM里的内存分布，知道每个对象都有object header，blabal。这里推荐一篇好文<a href="http://www.cnblogs.com/magialmoon/p/3757767.html" target="_blank" rel="external">一个Java对象到底占用多大内存？</a>，我就不重复了。</p>
<p>还看到另一种计算方式，用的Unsafe，不过感觉没有前面用Instrumentation的好。参考这里<a href="http://blog.csdn.net/bobpauline/article/details/20699233" target="_blank" rel="external">Java计算一个对象占用内存的大小</a></p>
<p>#线上查看</p>
<p>如果是要查看线上程序哪个对象占用了大量内存（比如分析内存泄露），那么可以使用jmap。</p>
<p>#相关知识<br>你可能需要了解jps，jinfo，打包jar，manifest，查看jvm运行参数等。</p>
<p>#refers</p>
<ol>
<li><a href="http://www.importnew.com/14948.html" target="_blank" rel="external">http://www.importnew.com/14948.html</a></li>
<li><a href="http://www.cnblogs.com/magialmoon/p/3757767.html" target="_blank" rel="external">http://www.cnblogs.com/magialmoon/p/3757767.html</a></li>
<li><a href="http://www.oschina.net/question/1_4486" target="_blank" rel="external">http://www.oschina.net/question/1_4486</a></li>
<li><a href="http://blog.csdn.net/bobpauline/article/details/20699233" target="_blank" rel="external">http://blog.csdn.net/bobpauline/article/details/20699233</a></li>
<li><a href="http://happyqing.iteye.com/blog/2013639" target="_blank" rel="external">http://happyqing.iteye.com/blog/2013639</a></li>
<li><a href="http://sunqi.iteye.com/blog/1917802" target="_blank" rel="external">http://sunqi.iteye.com/blog/1917802</a></li>
<li><a href="http://www.blogjava.net/stone2083/archive/2013/06/08/400410.html" target="_blank" rel="external">http://www.blogjava.net/stone2083/archive/2013/06/08/400410.html</a></li>
<li><a href="http://yueyemaitian.iteye.com/blog/2033046" target="_blank" rel="external">http://yueyemaitian.iteye.com/blog/2033046</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/java/j-lo-jse61/index.html" target="_blank" rel="external">http://www.ibm.com/developerworks/cn/java/j-lo-jse61/index.html</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/java/j-lo-instrumentation/" target="_blank" rel="external">http://www.ibm.com/developerworks/cn/java/j-lo-instrumentation/</a></li>
</ol>
<blockquote>
<p>Written with <a href="https://stackedit.io/" target="_blank" rel="external">StackEdit</a>.</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;经常遇到一个问题，需要在内存里缓存一批数据来提高效率（避免每次都读取DB）。那问题来了，这些对象到底会占用多大内存呢，这直接决定了可以缓存多少条记录，以及上线之后是否会内存不够等问题。&lt;/p&gt;
&lt;p&gt;来看几种解决方法。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://magicly.me/categories/Java/"/>
    
    
      <category term="Java" scheme="http://magicly.me/tags/Java/"/>
    
      <category term="JVM" scheme="http://magicly.me/tags/JVM/"/>
    
      <category term="Java反射" scheme="http://magicly.me/tags/Java%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>J.U.C源码解读之atomic</title>
    <link href="http://magicly.me/2015/01/13/juc-source-code-read-atomic/"/>
    <id>http://magicly.me/2015/01/13/juc-source-code-read-atomic/</id>
    <published>2015-01-13T13:34:10.000Z</published>
    <updated>2016-11-29T02:57:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>java5之后的java.util.concurrent包是世界级并发大师Doug Lea的作品，里面主要实现了</p>
<ol>
<li>atomic包里Integer/Long对应的原子类，主要基于CAS；</li>
<li>一些同步子，包括Lock，CountDownLatch，Semaphore，FutureTask等，这些都是基于AbstractQueuedSynchronizer类；</li>
<li>关于线程执行的Executors类等；</li>
<li>一些并发的集合类，比如ConcurrentHashMap，ConcurrentLinkedQueue，CopyOnWriteArrayList等。</li>
</ol>
<p>今天我们主要介绍atomic包下相关内容。</p>
<a id="more"></a>
<p>#CAS</p>
<p>atomic包下的类主要基于现代主流 CPU 都支持的一种指令，Compare and Swap（CAS），这个指令能为多线程编程带来更好的性能。引用《Java Concurrency in Practice》里的一段描述：</p>
<blockquote>
<p>在这里，CAS 指的是现代 CPU 广泛支持的一种对内存中的共享数据进行操作的一种特殊指令。这个指令会对内存中的共享数据做原子的读写操作。简单介绍一下这个指令的操作过程：首先，CPU 会将内存中将要被更改的数据与期望的值做比较。然后，当这两个值相等时，CPU 才会将内存中的数值替换为新的值。否则便不做操作。最后，CPU 会将旧的数值返回。这一系列的操作是原子的。它们虽然看似复杂，但却是 Java 5 并发机制优于原有锁机制的根本。简单来说，CAS 的含义是“我认为原有的值应该是什么，如果是，则将原有的值更新为新值，否则不做修改，并告诉我原来的值是多少”。</p>
</blockquote>
<p>#AtomicInteger<br><figure class="highlight cs"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> <span class="keyword">value</span>;</div></pre></td></tr></table></figure></p>
<p>AtomicInteger里面只包含一个字段，用来记录当前值，定义为volatile是为了满足<strong>可见性</strong>。<br><figure class="highlight d"><table><tr><td class="code"><pre><div class="line"><span class="comment">// setup to use Unsafe.compareAndSwapInt for updates</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">long</span> valueOffset;</div><div class="line"></div><div class="line">  <span class="keyword">static</span> &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      valueOffset = unsafe.objectFieldOffset</div><div class="line">          (AtomicInteger.<span class="keyword">class</span>.getDeclaredField(<span class="string">"value"</span>));</div><div class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>一开始定义了static变量Unsafe，AtomicInteger里面的方法都是对unsafe里面<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</div></pre></td></tr></table></figure></p>
<p>方法的封装。<br>我们来看原子性的i++，<br><figure class="highlight gradle"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> getAndIncrement() &#123;</div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        <span class="keyword">int</span> current = get();</div><div class="line">        <span class="keyword">int</span> <span class="keyword">next</span> = current + <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (compareAndSet(current, <span class="keyword">next</span>))</div><div class="line">            <span class="keyword">return</span> current;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在一个无限循环里面，首先获取当前值，用当前值+1，然后调用<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><div class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">return</span> unsafe.<span class="title">compareAndSwapInt</span><span class="params">(<span class="keyword">this</span>, valueOffset, expect, update)</span></span>;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>unsafe.compareAndSwapInt(this, valueOffset, expect, update)的含义是把this对象里面valueOffset（在一开始static代码里面获取）这个位置（即value值）跟expect比较，如果相等，则修改为update，返回true；如果不相等，说明在获取到current之后有其他线程修改过value的值，则重新来一遍，一直到修改成功为止。这里就可以看出，理论上来说，这个方法是有可能永远不能返回的，实际而言，当并发冲突很严重，反复compareAndSet(current, next)失败，有可能也需要花费很多时间。</p>
<p>AtomicInteger里面的其他方法，基本类似；其他类包括AtomicLong，AtomicReference等也是基本对Unsafe里面compareAndSet的一个封装。</p>
<p>#Unsafe</p>
<p>前面可以看到Unsafe类在实现atomic的重要性。为什么有Unsafe这个class呢，基本原因是Java不允许代码直接操作内存，好处是更安全，一般不会出现内存泄露，因为有JVM的GC；坏处是有些底层调用执行不了。我的理解是，Unsafe就是这个java安全围城通向比如c++这个不安全外围的一道门，所以叫Unsafe嘛。Unsafe里面基本都是native，即通过JNI调用c/c++等代码。大部分是直接内存操作，以及后面会讲到的挂起唤醒线程等，包括park和unpark。</p>
<p>前面到<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</div></pre></td></tr></table></figure></p>
<p>这个方法就不是java代码了，如果想看实现的话，需要下载OpenJDK源码，里面是c++代码调用汇编代码，blabla。我不建议大家再往下继续了，原因有几个，一是我们用java等高级语言的目的就是为了避免纠结复杂的底层细节，站在更高层的角度思考问题，而且java里面还有更多的问题等待你去解决，更多的知识可以学习呢！如果你说你已经把java完全掌握了，包括把jdk源码，tomcat、spring，xxxxx源码都看过了，实在没得看了，那我会说，多陪陪家人吧~除非你是JVM开发工程师，哦，那不好意思，大神，当我啥都没说。。。。为了完整性，我贴几个参考链接<a href="http://www.blogjava.net/mstar/archive/2013/04/24/398351.html" target="_blank" rel="external">http://www.blogjava.net/mstar/archive/2013/04/24/398351.html</a>, <a href="http://zl198751.iteye.com/blog/1848575" target="_blank" rel="external">http://zl198751.iteye.com/blog/1848575</a>.</p>
<p>那么如果获取Unsafe呢？Unsafe有一个static方法可以获取Unsafe实例，如下<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function">Unsafe <span class="title">getUnsafe</span><span class="params">()</span> </span>&#123;</div><div class="line">       Class var0 = Reflection.getCallerClass(<span class="number">2</span>);</div><div class="line">       <span class="keyword">if</span>(var0.getClassLoader() != <span class="keyword">null</span>) &#123;</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"Unsafe"</span>);</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           <span class="keyword">return</span> theUnsafe;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>可是你如果在自己代码里使用，可以编译通过，但是运行时候报错。因为里面限制了调用getUnsafe()这个方法的类必须是启动类加载器Bootstrap Loader。所以如果想在自己代码里面调用Unsafe的话（强烈建议不要这样子做），可以用Java的反射来实现：</p>
<pre><code>    static class UnsafeSupport {
        private static Unsafe unsafe;

        static {
            Field field;
            try {
                // 由反编译Unsafe类获得的信息
                field = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);
                field.setAccessible(true);
                // 获取静态属性,Unsafe在启动JVM时随rt.jar装载
                unsafe = (Unsafe) field.get(null);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        public static Unsafe getInstance() {
//            return Unsafe.getUnsafe();//没有用，只能native获取，否则会抛异常
            return unsafe;
        }
    }
</code></pre><p>获取到了Unsafe的实例之后，你照样可以自己实现Atomic类，再说一遍，强烈建议不要这样做！！！</p>
<p>#CAS优点</p>
<p>Compare and Set 是一个非阻塞的算法，这是它的优势。因为使用的是CPU支持的指令，提供了比原有的并发机制更好的性能和伸缩性。可以认为一般情况下性能更好，并且也更容易使用（这才是关键啊）。</p>
<p>#CAS缺点</p>
<p>##ABA问题</p>
<p>CAS操作容易导致ABA问题,也就是在做a++之间，a可能被多个线程修改过了，只不过回到了最初的值，这时CAS会认为a的值没有变。a在外面逛了一圈回来，你能保证它没有做任何坏事，不能！！也许它讨闲，把b的值减了一下，把c的值加了一下等等。解决ABA问题的方法有很多，可以考虑增加一个修改计数（版本号），只有修改计数不变的且a值不变的情况下才做a++，atomic包下有AtomicStampedReference类做这个事情，这和事务原子性处理有点类似！</p>
<p>##循环时间长开销大</p>
<ol>
<li>即使没有任何争用也会做一些无用功</li>
<li>如果冲突比较严重的话，可能导致多次修改失败，for循环时间很长，可能比同步还慢</li>
</ol>
<p>我在自己的电脑上用100个线程去修改一个共享变量，发现用AtomicInteger就比synchronized慢，但是都很快！所以还是那个建议，不要过早优化，不要纠结到底是1ms还是2ms，除非测试之后发现确实是性能瓶颈，然后再仔细看一下，是不是代码的使用有问题，要相信，能写到JDK里的代码，一般都不会有问题。一般不到一天几千万上亿的PV，应该是没啥问题的。而且JVM对synchronized做了很多优化，包括锁去除（Lock Elimination），轻量级锁，偏向锁等，所以写代码的时候首先还是主要考虑代码正确、清晰、可维护。</p>
<p>##只能保证一个共享变量的原子操作</p>
<p>如果并发约束条件涉及到两个变量，就不能用两个原子变量来达到整体的原子性，还是得用同步。当然你也可以用一个变通的方法，定义一个class，里面包含约束条件涉及到的变量，然后用AtomicReference来实现原子性。</p>
<p>#总结</p>
<p>atomic包下的类比如AtomicInteger实现原子性的方法主要是依靠现代主流 CPU 都支持的CAS指令，它是通过Unsafe类的native方法调用的。一般而言性能比用锁同步要好，但是都已经很好了，一般而言不会遇到性能问题，关键还是看它的语义是否满足使用要求，以及是否可以让代码更清新。</p>
<p>Refers</p>
<ol>
<li><a href="http://my.oschina.net/lifany/blog/133513" target="_blank" rel="external">http://my.oschina.net/lifany/blog/133513</a></li>
<li><a href="http://zl198751.iteye.com/blog/1848575" target="_blank" rel="external">http://zl198751.iteye.com/blog/1848575</a></li>
<li><a href="http://blog.csdn.net/aesop_wubo/article/details/7537960" target="_blank" rel="external">http://blog.csdn.net/aesop_wubo/article/details/7537960</a></li>
<li><a href="http://my.oschina.net/u/177808/blog/166819" target="_blank" rel="external">http://my.oschina.net/u/177808/blog/166819</a></li>
<li><a href="http://www.blogjava.net/mstar/archive/2013/04/24/398351.html" target="_blank" rel="external">http://www.blogjava.net/mstar/archive/2013/04/24/398351.html</a></li>
<li><a href="http://mishadoff.com/blog/java-magic-part-4-sun-dot-misc-dot-unsafe/" target="_blank" rel="external">http://mishadoff.com/blog/java-magic-part-4-sun-dot-misc-dot-unsafe/</a></li>
<li><a href="http://zeroturnaround.com/rebellabs/dangerous-code-how-to-be-unsafe-with-java-classes-objects-in-memory/" target="_blank" rel="external">http://zeroturnaround.com/rebellabs/dangerous-code-how-to-be-unsafe-with-java-classes-objects-in-memory/</a></li>
<li><a href="http://www.pwendell.com/2012/08/13/java-lock-free-deepdive.html" target="_blank" rel="external">http://www.pwendell.com/2012/08/13/java-lock-free-deepdive.html</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;java5之后的java.util.concurrent包是世界级并发大师Doug Lea的作品，里面主要实现了&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;atomic包里Integer/Long对应的原子类，主要基于CAS；&lt;/li&gt;
&lt;li&gt;一些同步子，包括Lock，CountDownLatch，Semaphore，FutureTask等，这些都是基于AbstractQueuedSynchronizer类；&lt;/li&gt;
&lt;li&gt;关于线程执行的Executors类等；&lt;/li&gt;
&lt;li&gt;一些并发的集合类，比如ConcurrentHashMap，ConcurrentLinkedQueue，CopyOnWriteArrayList等。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;今天我们主要介绍atomic包下相关内容。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://magicly.me/categories/Java/"/>
    
    
      <category term="Java" scheme="http://magicly.me/tags/Java/"/>
    
      <category term="concurrency" scheme="http://magicly.me/tags/concurrency/"/>
    
      <category term="jdk" scheme="http://magicly.me/tags/jdk/"/>
    
      <category term="源码阅读" scheme="http://magicly.me/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>Java Concurrency（三）——J.U.C AQS源码解读</title>
    <link href="http://magicly.me/2015/01/13/java-concurrrency-3-juc-source-code-read/"/>
    <id>http://magicly.me/2015/01/13/java-concurrrency-3-juc-source-code-read/</id>
    <published>2015-01-13T13:34:10.000Z</published>
    <updated>2016-11-29T02:57:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>java5之后的java.util.concurrent包是世界级并发大师Doug Lea的作品，里面主要实现了</p>
<ol>
<li>atomic包里Integer/Long对应的原子类，主要基于CAS；</li>
<li>一些同步子，包括Lock，CountDownLatch，Semaphore，FutureTask等，这些都是基于AbstractQueuedSynchronizer类；</li>
<li>关于线程执行的Executors类等；</li>
<li>一些并发的集合类，比如ConcurrentHashMap，ConcurrentLinkedQueue，CopyOnWriteArrayList等。</li>
</ol>
<p>今天我们主要介绍AbstractQueuedSynchronizer这个可以说是最核心的类，没有之一。整个concurrent包里，基本都直接或间接地用到了这个类。Doug Lea的这篇<a href="http://gee.cs.oswego.edu/dl/papers/aqs.pdf" target="_blank" rel="external">论文</a>里面讲AQS的实现。</p>
<a id="more"></a>
<p>#AQS</p>
<p>首先，我们来想象一下，一间屋里有一个大家都想要得到的会让你很爽的东西（something which makes you so happy, e.g. W.C）。当有人进去把门关起来在独占享用的时候，其他人就只能在外面排队等待，既然在等待，你就不能老是去敲门说哎，好了没有啊。老是这样的话里面的人就很不爽了，而且你可以利用这点等待时间干点别的，比如看看小说视频背背单词或者就干脆椅子上睡觉，当前面独占的人爽完之后，就会出来说，啊，好爽，到你们了。然后大家可能按照排队顺序获取或者大家疯抢这个状态，有可能一个人自己进去独占，有可能几个人说，哎没关系，我们可以一起来。然后他们进去爽，爽完之后再出来通知下一个。</p>
<p>我们来把上面这段话翻译成AQS里面的术语。有一个状态state，会有多个Thread尝试获取，当一个Thread独占（EXCLUSIVE，比如Lock）之后，其他后面到来的Thread就会被放到一个Queue的队尾（tail），然后睡眠（park），一直等到前面的Thread唤醒（unpark）它，当然这里有可能被假唤醒（就好比你定了闹钟8点起床，结果7点就自然醒或者被外面车吵醒），所以这个Thread会判断一下是不是到自己了，没有的话就继续park（在一个死循环里）；当拥有state的Thread释放（release）之后，它会唤醒Queue中的下一个Thread（unparkSuccessor）。然后下一个Thread获取（acquire）到state，完成自己的任务，然后继续unparkSuccessor。前面主要说的是EXCLUSIVE模式，AQS还支持共享（SHARED）模式，区别在于尝试获取（tryAcquireShared）的时候即使之前已经有Thread获取了state，但是可能仍然能获取（比如ReadLock）。同样释放（doReleaseShared）的时候除了通知Queue里面第一个（head），还会继续通知后续的节点（Node），只要它们是SHARED。</p>
<p>AQS就是实现了：</p>
<ol>
<li>自动管理这个同步状态state（int类型），更新的时候需要用CAS保证原子性</li>
<li>阻塞和唤醒线程park/unpark</li>
<li>队列管理，一个双向链表实现queue</li>
</ol>
<p>AQS是一个abstract class，可以通过继承AQS，定义state的含义，以及tryAcquire，tryRelease，以及对应的share模式下tryAcquireShared，tryReleaseShared这几个方法，定义出自己想要的同步子（Synchronizers）。一般而言，是定义一个内部类Sync extends AQS，实现前面说的几个方法，然后再包一层，暴露出相应的方法。这样做的好处是你可以在包装器类里面取更直观的名字，如ReentrantLock里的lock，unlock和CountDownLatch里的countDown，await，而不是太通用的acquire和release等。而且AQS里面一些方法是为了监控和调试使用，直接暴露出来也不好。</p>
<p>下面我们来看J.U.C里面两个常用的Synchronizers。</p>
<p>#ReentrantLock</p>
<p>##使用</p>
<p>ReentrantLock的语义跟synchronized关键字基本一样，而且我之前看<a href="http://book.douban.com/subject/6522893/" target="_blank" rel="external">《深入理解Java虚拟机》</a>里面的评测说JDK6之后，两者的效率基本一致了（JDK5之前ReentrantLock要比synchronized快很多）。Javadoc里面说基本用法如下：<br><figure class="highlight cs"><table><tr><td class="code"><pre><div class="line"><span class="keyword">class</span> <span class="title">X</span> &#123;</div><div class="line">  <span class="keyword">private</span> final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">new</span> ReentrantLock();</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">lock</span>.<span class="keyword">lock</span>();  <span class="comment">// block until condition holds</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="comment">// ... method body</span></div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">      <span class="keyword">lock</span>.unlock()</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>##源码</p>
<p>ReentrantLock用state表示是否被锁，0表示没有线程获取到锁，&gt;=1表示某个线程获取了N次锁（因为是重入的，只要保证lock和unlock成对出现就没有问题）。<br><figure class="highlight scala"><table><tr><td class="code"><pre><div class="line"><span class="comment">/** Synchronizer providing all implementation mechanics */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Sync</span> sync;</div><div class="line"></div><div class="line"><span class="keyword">abstract</span> static <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</div></pre></td></tr></table></figure></p>
<p>定义了一个内部类，基本任务都代理给sync完成。而Sync又是一个abstract class，这里主要是因为实现了两种抢占锁的机制，公平锁和非公平锁。<br><figure class="highlight scala"><table><tr><td class="code"><pre><div class="line">static <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span></span></div><div class="line"></div><div class="line">static <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span></span></div></pre></td></tr></table></figure></p>
<p>所谓公平不公平简单来说就是本文开头说的，当资源释放的时候，大家是按照排队顺序先到先得，还是有人插队大家疯抢。</p>
<p>提供了两个构造函数：<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</div><div class="line">       sync = <span class="keyword">new</span> NonfairSync();<span class="comment">//默认非公平锁，AQS论文说非公平锁效率高些，理由其实很简单，公平锁通知队列第一个节点，要把它唤醒，而唤醒是需要时间的，在锁释放到第一个节点被唤醒这段时间其实锁是可以用但是没有被用的（available but not used）；而非公平锁，释放了之后立马就可以被别人用，所以提高了效率，但是有可能导致饥饿锁，这个就要具体看业务需求了。</span></div><div class="line">   &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</div><div class="line">       sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();<span class="comment">//指定公平与否</span></div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>加锁的实现<br><figure class="highlight cs"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span>(<span class="params"></span>) </span>&#123;</div><div class="line">       sync.<span class="keyword">lock</span>();</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>简单代理给了sync，在FairSync里为<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</div><div class="line">	acquire(<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>acquire的实现在AQS里面：<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</div><div class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</div><div class="line">        selfInterrupt();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>tryAcquire是要在子类里自己实现的，在FairSync如下;<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">         <span class="keyword">final</span> Thread current = Thread.currentThread();</div><div class="line">         <span class="keyword">int</span> c = getState();</div><div class="line">         <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;<span class="comment">//0表示锁没有被线程用，1表示已经有线程占用</span></div><div class="line">             <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; <span class="comment">//判断自己是否是第一个节点，实现公平</span></div><div class="line">                 compareAndSetState(<span class="number">0</span>, acquires)) &#123;<span class="comment">//CAS更新状态</span></div><div class="line">                 setExclusiveOwnerThread(current);<span class="comment">//设置当前线程拥有状态</span></div><div class="line">                 <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">             &#125;</div><div class="line">         &#125;</div><div class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<span class="comment">//1表示已经有线程占用，再判断一下是否被当前线程占用，来实现重入（Reentrant）特性</span></div><div class="line">             <span class="keyword">int</span> nextc = c + acquires;</div><div class="line">             <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</div><div class="line">                 <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line">             setState(nextc);<span class="comment">//更新状态</span></div><div class="line">             <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">         &#125;</div><div class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">     &#125;</div></pre></td></tr></table></figure></p>
<p>如果获取失败，addWaiter(Node.EXCLUSIVE)将当前线程加入队尾<br><figure class="highlight crmsh"><table><tr><td class="code"><pre><div class="line">private <span class="keyword">Node</span> <span class="title">addWaiter</span>(<span class="keyword">Node</span> <span class="title">mode</span>) &#123;</div><div class="line">       <span class="keyword">Node</span> <span class="title">node</span> = new <span class="keyword">Node</span><span class="title">(Thread</span>.currentThread(), mode);//用当前线程构造<span class="keyword">Node</span><span class="title">，独占模式</span></div><div class="line">       // Try the fast path of enq; backup to full enq on failure</div><div class="line">       <span class="keyword">Node</span> <span class="title">pred</span> = tail;</div><div class="line">       if (pred != null) &#123;</div><div class="line">           <span class="keyword">node</span>.<span class="title">prev</span> = pred;</div><div class="line">           if (compareAndSetTail(pred, <span class="keyword">node</span><span class="title">)) &#123;//快速判断，CAS</span>更新tail节点</div><div class="line">               pred.next = <span class="keyword">node</span><span class="title">;</span></div><div class="line">               return <span class="keyword">node</span><span class="title">;</span></div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       enq(<span class="keyword">node</span><span class="title">);//如果失败，进入enq</span>方法</div><div class="line">       return <span class="keyword">node</span><span class="title">;</span></div><div class="line">   &#125;</div><div class="line">   </div><div class="line"> private <span class="keyword">Node</span> <span class="title">enq</span>(final <span class="keyword">Node</span> <span class="title">node</span>) &#123;</div><div class="line">       for (;;) &#123;</div><div class="line">           <span class="keyword">Node</span> <span class="title">t</span> = tail;</div><div class="line">           if (t == null) &#123; // Must initialize</div><div class="line">               if (compareAndSetHead(new <span class="keyword">Node</span><span class="title">()))//如果还没有head</span>，CAS初始化一个head</div><div class="line">                   tail = head;</div><div class="line">           &#125; else &#123;//这段代码跟addWaiter里一样，CAS更新tail节点</div><div class="line">               <span class="keyword">node</span>.<span class="title">prev</span> = t;</div><div class="line">               if (compareAndSetTail(t, <span class="keyword">node</span><span class="title">)) &#123;</span></div><div class="line">                   t.next = <span class="keyword">node</span><span class="title">;</span></div><div class="line">                   return t;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>现在我们已经将获取不到锁的线程加入队尾了，现在要将它挂起acquireQueued(addWaiter(Node.EXCLUSIVE), arg))：<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">       <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</div><div class="line">           <span class="keyword">for</span> (;;) &#123;<span class="comment">//在一个死循环中，避免假唤醒</span></div><div class="line">               <span class="keyword">final</span> Node p = node.predecessor();<span class="comment">//获取当前节点的前一个节点，如果是head说明自己是第一个可以获取资源的线程，实现公平</span></div><div class="line">               <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<span class="comment">//是第一个可以获取资源的线程并且尝试获取成功</span></div><div class="line">                   setHead(node);</div><div class="line">                   p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">                   failed = <span class="keyword">false</span>;</div><div class="line">                   <span class="keyword">return</span> interrupted;</div><div class="line">               &#125;</div><div class="line">               <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                   parkAndCheckInterrupt())<span class="comment">//没有获取到资源，睡眠park去</span></div><div class="line">                   interrupted = <span class="keyword">true</span>;</div><div class="line">           &#125;</div><div class="line">       &#125; <span class="keyword">finally</span> &#123;</div><div class="line">           <span class="keyword">if</span> (failed)</div><div class="line">               cancelAcquire(node);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</div><div class="line">       LockSupport.park(<span class="keyword">this</span>);</div><div class="line">       <span class="function"><span class="keyword">return</span> Thread.<span class="title">interrupted</span><span class="params">()</span></span>;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>上面完成了获取锁的过程，简单来说就是尝试获取，失败就加入队尾，挂起，等待被唤醒。</p>
<p>下面来看看释放锁<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><div class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</div><div class="line">        sync.release(<span class="number">1</span>);<span class="comment">//代理给sync，调用AQS的release</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="comment">//下面代码在AQS中</span></div><div class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;<span class="comment">//尝试释放资源，需要在子类里实现</span></div><div class="line">            Node h = head;</div><div class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</div><div class="line">                unparkSuccessor(h);<span class="comment">//通知下一个节点</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * If status is negative (i.e., possibly needing signal) try</div><div class="line">         * to clear in anticipation of signalling.  It is OK if this</div><div class="line">         * fails or if status is changed by waiting thread.</div><div class="line">         */</div><div class="line">        <span class="keyword">int</span> ws = node.waitStatus;</div><div class="line">        <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</div><div class="line">            compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line">         * Thread to unpark is held in successor, which is normally</div><div class="line">         * just the next node.  But if cancelled or apparently null,</div><div class="line">         * traverse backwards from tail to find the actual</div><div class="line">         * non-cancelled successor.</div><div class="line">         */</div><div class="line">         <span class="comment">// 主要在这里找到下一个需要通知的节点，如果node.next就是需要通知的节点，则直接通知；否则，可能node.next == null（原因是双向链表设置b.pre = a和a.next = b的时候不能保证原子性，只能保证b.pre = a成功，这时候另一条线程可能看到a.next == null）或者s.waitStatus &gt; 0（原因是线程等不及被取消了static final int CANCELLED = 1;），这个时候就要从队尾tail开始找，找到离队头head最近的一个需要通知的节点Node。</span></div><div class="line">        Node s = node.next;</div><div class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</div><div class="line">            s = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</div><div class="line">                <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</div><div class="line">                    s = t;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (s != <span class="keyword">null</span>)</div><div class="line">            LockSupport.unpark(s.thread);<span class="comment">//唤醒线程</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>看看需要在子类里实现的tryRelease：<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</div><div class="line">          <span class="keyword">int</span> c = getState() - releases;<span class="comment">//释放锁，state减去相应的值</span></div><div class="line">          <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</div><div class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();<span class="comment">//避免A线程锁了之后，B线程故意捣乱释放锁</span></div><div class="line">          <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</div><div class="line">          <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;<span class="comment">//当前线程已经完全释放了锁</span></div><div class="line">              free = <span class="keyword">true</span>;</div><div class="line">              setExclusiveOwnerThread(<span class="keyword">null</span>);<span class="comment">//释放锁的拥有者</span></div><div class="line">          &#125;</div><div class="line">          setState(c);<span class="comment">//设置状态，这个方面没有同步，没有CAS，有同学问过岂不是有线程并发问题？其实到这里，只有一个线程会调用这个方法，所以不会有并发错误，仔细想想，是吧？是吧？</span></div><div class="line">          <span class="keyword">return</span> free;</div><div class="line">      &#125;</div></pre></td></tr></table></figure></p>
<p>到这里，基本都已经完成，对了，还没有说非公平锁NonfairSync是怎么抢占锁的。<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</div><div class="line">          <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))<span class="comment">//先抢一把（插队），万一成功了就不排队，不公平性就体现在这里！</span></div><div class="line">              setExclusiveOwnerThread(Thread.currentThread());</div><div class="line">          <span class="keyword">else</span></div><div class="line">              acquire(<span class="number">1</span>);</div><div class="line">      &#125;</div></pre></td></tr></table></figure></p>
<p>跟FairSync.lock()对比，可以看出，只是在acquire(1)之前，先抢一把，抢不到才乖乖的去排队。</p>
<p>我们再看看NonfairSync.tryAcquire()怎么实现的<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">          <span class="function"><span class="keyword">return</span> <span class="title">nonfairTryAcquire</span><span class="params">(acquires)</span></span>;<span class="comment">//调用父类方法nonfairTryAcquire</span></div><div class="line">      &#125;</div><div class="line"></div><div class="line"><span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">          <span class="keyword">final</span> Thread current = Thread.currentThread();</div><div class="line">          <span class="keyword">int</span> c = getState();</div><div class="line">          <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</div><div class="line">              <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;<span class="comment">//跟FairSync.tryAcquire只有这里一行有差异，即少了!hasQueuedPredecessors()，也就是说不判断前面有没有人，任何时候只要它醒来，都会去抢，所以不公平！============刚又看了一遍，发现其实final boolean acquireQueued(final Node node, int arg)方法里已经有node.predecessor() == head的判断，感觉这个不公平的tryAcquire貌似没有意义，各位看官怎么看呢，请留言哈，谢谢~</span></div><div class="line">                  setExclusiveOwnerThread(current);</div><div class="line">                  <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</div><div class="line">              <span class="keyword">int</span> nextc = c + acquires;</div><div class="line">              <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></div><div class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line">              setState(nextc);</div><div class="line">              <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">      &#125;</div></pre></td></tr></table></figure></p>
<p>#CountDownLatch</p>
<p>我们之前说了，AQS支持独占EXCLUSIVE和共享SHARED两种模式，而刚刚的ReentrantLock的就是独占模式，我们来看看一个使用共享模式的类。</p>
<p>##使用</p>
<p>CountDownLatch就好比一道门，它可以用来等所有资源都到齐了，才开门，让这些线程同时通过。比如如下是CountDownLatch一个通用用法：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">package</span> concurrentStudy;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by magicalli on 2014/12/13.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexPlusPlusTest01</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NThreads = <span class="number">10</span>;<span class="comment">// 线程数</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> M = <span class="number">100000</span>;<span class="comment">//循环次数，太小的话（比如10）可能看不出来效果</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> n = <span class="number">0</span>;<span class="comment">//加volatile的目的是为了证明volatile没有“原子性”！</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="keyword">final</span> CountDownLatch startGate = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</div><div class="line">        <span class="keyword">final</span> CountDownLatch endGate = <span class="keyword">new</span> CountDownLatch(NThreads);</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NThreads; i++) &#123;</div><div class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        startGate.await();<span class="comment">//所有线程start之后等待“门“打开，保证同时真正开始运行</span></div><div class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; j++) &#123;</div><div class="line">                        n += <span class="number">1</span>;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    endGate.countDown();</div><div class="line">                &#125;</div><div class="line">            &#125;).start();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        startGate.countDown();<span class="comment">//打开“门”，让所有线程同时run起来</span></div><div class="line">        <span class="keyword">long</span> t1 = System.currentTimeMillis();</div><div class="line">        endGate.await();<span class="comment">//等所有线程都结束之后才打印n，否则总是会打出错误的n；我见过这里用Thread.sleep()，但是问题在于，你怎么知道该等多久才能保证所有线程结束以及刚好结束呢？！</span></div><div class="line">        <span class="keyword">long</span> t2 = System.currentTimeMillis();</div><div class="line">        System.out.println(<span class="string">"cost time: "</span> + (t2 - t1));</div><div class="line">        System.out.println(<span class="string">"n: "</span> + n);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对了，上面代码是拿来验证volatile不具备原子性的，是错误的代码哦。如果想并发安全，大家可以想想可以用哪些方式实现。</p>
<p>##源码</p>
<p>CountDownLatch同样也是定义了一个继承自AQS的内部类Sync：<br><figure class="highlight scala"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> static <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></div></pre></td></tr></table></figure></p>
<p>构造函数如下：<br><figure class="highlight axapta"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> CountDownLatch(<span class="keyword">int</span> <span class="keyword">count</span>) &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">count</span> &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count &lt; 0"</span>);</div><div class="line">    <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(<span class="keyword">count</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>count表示有多少个任务还在运行，每个Thread完成了任务或者准备好开始之前，就会调用countDown方法将count-1，当count==0时候，await就不再阻塞，所有在上面阻塞的Thread都可以顺利通过。<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>直接调用AQS的acquireSharedInterruptibly方法，从方法名可以看出，支持中断响应<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></div><div class="line">        <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">    <span class="keyword">if</span> (Thread.interrupted())</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();<span class="comment">//响应中断</span></div><div class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</div><div class="line">        doAcquireSharedInterruptibly(arg);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>tryAcquireShared在子类中实现：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">-1</span>;<span class="comment">//如果state为0，说明所有Thread完成任务，可以不阻塞了</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果没有获取到，将Thread加入队尾，挂起。下面这个方法跟独占模式下acquireQueued(addWaiter(Node.EXCLUSIVE), arg))这个方法代码是基本一致的。<br><figure class="highlight crmsh"><table><tr><td class="code"><pre><div class="line">private void doAcquireSharedInterruptibly(int arg)</div><div class="line">       throws InterruptedException &#123;</div><div class="line">       final <span class="keyword">Node</span> <span class="title">node</span> = addWaiter(<span class="keyword">Node</span>.<span class="title">SHARED</span>);//共享模式</div><div class="line">       boolean failed = <span class="literal">true</span>;</div><div class="line">       try &#123;</div><div class="line">           for (;;) &#123;</div><div class="line">               final <span class="keyword">Node</span> <span class="title">p</span> = <span class="keyword">node</span>.<span class="title">predecessor</span>();</div><div class="line">               if (p == head) &#123;</div><div class="line">                   int r = tryAcquireShared(arg);</div><div class="line">                   if (r &gt;= <span class="number">0</span>) &#123;</div><div class="line">                       setHeadAndPropagate(<span class="keyword">node</span><span class="title">, r</span>);//跟EXCLUSIVE的一大区别</div><div class="line">                       p.next = null; // help GC</div><div class="line">                       failed = <span class="literal">false</span>;</div><div class="line">                       return;</div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">               if (shouldParkAfterFailedAcquire(p, <span class="keyword">node</span><span class="title">) &amp;&amp;</span></div><div class="line">                   parkAndCheckInterrupt())</div><div class="line">                   throw new InterruptedException();//响应中断，这里直接抛异常</div><div class="line">           &#125;</div><div class="line">       &#125; finally &#123;</div><div class="line">           if (failed)</div><div class="line">               cancelAcquire(<span class="keyword">node</span><span class="title">);</span></div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">private void setHeadAndPropagate(<span class="keyword">Node</span> <span class="title">node</span>, int propagate) &#123;</div><div class="line">       <span class="keyword">Node</span> <span class="title">h</span> = head; // Record old head for check below</div><div class="line">       setHead(<span class="keyword">node</span><span class="title">);</span></div><div class="line">       /*</div><div class="line">        * Try to signal next queued <span class="keyword">node</span> if:<span class="title"></span></div><div class="line">        *   Propagation was indicated by caller,</div><div class="line">        *     <span class="keyword">or</span> was recorded (as h.waitStatus either before</div><div class="line">        *     <span class="keyword">or</span> after setHead) by a previous operation</div><div class="line">        *     (note: this uses sign-check of waitStatus because</div><div class="line">        *      PROPAGATE status may transition to SIGNAL.)</div><div class="line">        * <span class="keyword">and</span></div><div class="line">        *   The next <span class="keyword">node</span> <span class="title">is</span> waiting <span class="keyword">in</span> shared mode,</div><div class="line">        *     <span class="keyword">or</span> we don't know, because it appears null</div><div class="line">        *</div><div class="line">        * The conservatism <span class="keyword">in</span> both of these checks may cause</div><div class="line">        * unnecessary wake-ups, but only when there are multiple</div><div class="line">        * racing acquires/releases, so most need signals now <span class="keyword">or</span> soon</div><div class="line">        * anyway.</div><div class="line">        */</div><div class="line">        // 如果当前节点是愿意共享，并且下一个节点也是愿意共享的，那么就进入doReleaseShared，唤醒下一个节点，下面会详解</div><div class="line">       if (propagate &gt; <span class="number">0</span> || h == null || h.waitStatus <span class="tag">&lt; 0 ||</span></div><div class="line">           (h = head) == null || h.waitStatus &lt; 0) &#123;</div><div class="line">           Node s = node.next;</div><div class="line">           if (s == null || s.isShared())</div><div class="line">               doReleaseShared();</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>前面完成了等待CountDownLatch的count变成0的过程，下面看看countDown<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</div><div class="line">       sync.releaseShared(<span class="number">1</span>);<span class="comment">//调用AQS的</span></div><div class="line">   &#125;</div><div class="line"></div><div class="line"><span class="comment">// AQS中</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;<span class="comment">//尝试释放，需要在子类中实现</span></div><div class="line">           doReleaseShared();<span class="comment">//真正释放</span></div><div class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">	<span class="comment">// Sync子类中实现</span></div><div class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</div><div class="line">           <span class="comment">// Decrement count; signal when transition to zero</span></div><div class="line">           <span class="keyword">for</span> (;;) &#123;</div><div class="line">               <span class="keyword">int</span> c = getState();</div><div class="line">               <span class="keyword">if</span> (c == <span class="number">0</span>)</div><div class="line">                   <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">               <span class="keyword">int</span> nextc = c<span class="number">-1</span>;</div><div class="line">               <span class="keyword">if</span> (compareAndSetState(c, nextc))<span class="comment">// 在死循环中CAS将count-1</span></div><div class="line">                   <span class="keyword">return</span> nextc == <span class="number">0</span>;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       </div><div class="line">   <span class="comment">// AQS中</span></div><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="comment">/*</span></div><div class="line">        * Ensure that a release propagates, even if there are other</div><div class="line">        * in-progress acquires/releases.  This proceeds in the usual</div><div class="line">        * way of trying to unparkSuccessor of head if it needs</div><div class="line">        * signal. But if it does not, status is set to PROPAGATE to</div><div class="line">        * ensure that upon release, propagation continues.</div><div class="line">        * Additionally, we must loop in case a new node is added</div><div class="line">        * while we are doing this. Also, unlike other uses of</div><div class="line">        * unparkSuccessor, we need to know if CAS to reset status</div><div class="line">        * fails, if so rechecking.</div><div class="line">        */</div><div class="line">       <span class="keyword">for</span> (;;) &#123;</div><div class="line">           Node h = head;</div><div class="line">           <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</div><div class="line">               <span class="keyword">int</span> ws = h.waitStatus;</div><div class="line">               <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</div><div class="line">                   <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</div><div class="line">                       <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></div><div class="line">                   unparkSuccessor(h);<span class="comment">//遍历queue，通知所有SHARED的节点，因为是共享模式，这些Node都应该被唤醒，直到遇到某个EXCLUSIVE的Node</span></div><div class="line">               &#125;</div><div class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</div><div class="line">                        !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</div><div class="line">                   <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></div><div class="line">           &#125;</div><div class="line">           <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></div><div class="line">               <span class="keyword">break</span>;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>unparkSuccessor跟之前独占模式里面的是同一个函数，即调用unpark唤醒Thread。</p>
<p>我们知道为了避免获取不到锁长时间等待，一般阻塞的方法都会支持带超时时间的方法，比如CountDownLatch里就有<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></div><div class="line">       <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">       <span class="keyword">return</span> sync.tryAcquireSharedNanos(<span class="number">1</span>, unit.toNanos(timeout));</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>调用AQS里面的tryAcquireSharedNanos方法<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><div class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryAcquireSharedNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></div><div class="line">           <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">       <span class="keyword">if</span> (Thread.interrupted())</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">       <span class="keyword">return</span> tryAcquireShared(arg) &gt;= <span class="number">0</span> ||</div><div class="line">           doAcquireSharedNanos(arg, nanosTimeout);</div><div class="line">   &#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">boolean</span> <span class="title">doAcquireSharedNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></div><div class="line">           <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">       <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0</span>L)</div><div class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">       <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</div><div class="line">       <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</div><div class="line">       <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           <span class="keyword">for</span> (;;) &#123;</div><div class="line">               <span class="keyword">final</span> Node p = node.predecessor();</div><div class="line">               <span class="keyword">if</span> (p == head) &#123;</div><div class="line">                   <span class="keyword">int</span> r = tryAcquireShared(arg);</div><div class="line">                   <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</div><div class="line">                       setHeadAndPropagate(node, r);</div><div class="line">                       p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">                       failed = <span class="keyword">false</span>;</div><div class="line">                       <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">               nanosTimeout = deadline - System.nanoTime();</div><div class="line">               <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0</span>L)</div><div class="line">                   <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//如果已经没时间了，直接return false</span></div><div class="line">               <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                   nanosTimeout &gt; spinForTimeoutThreshold)<span class="comment">//大于某个阈值，才park，否则进入自旋</span></div><div class="line">                   LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);<span class="comment">//调用带超时的park方法</span></div><div class="line">               <span class="keyword">if</span> (Thread.interrupted())</div><div class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">           &#125;</div><div class="line">       &#125; <span class="keyword">finally</span> &#123;</div><div class="line">           <span class="keyword">if</span> (failed)</div><div class="line">               cancelAcquire(node);</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>可以看到，跟不带超时的doAcquireSharedInterruptibly方法相比，区别主要在于每次for循环期间，检查时间是否过期和调用带超时的park。nanosTimeout &gt; spinForTimeoutThreshold这个判断主要是因为park/unpark本身也需要花时间，为了更准确地完成超时的机制，在超时时间马上就要到了的时候，就进入自旋，不再park了，这应该是Doug Lea测试了park/unpark时间比1000纳秒要长吧。<br><figure class="highlight vbnet"><table><tr><td class="code"><pre><div class="line">/**</div><div class="line">    * The number <span class="keyword">of</span> nanoseconds <span class="keyword">for</span> which it <span class="keyword">is</span> faster <span class="keyword">to</span> spin</div><div class="line">    * rather than <span class="keyword">to</span> use timed park. A rough estimate suffices</div><div class="line">    * <span class="keyword">to</span> improve responsiveness <span class="keyword">with</span> very <span class="built_in">short</span> timeouts.</div><div class="line">    */</div><div class="line">   <span class="keyword">static</span> final <span class="built_in">long</span> spinForTimeoutThreshold = <span class="number">1000</span>L;</div></pre></td></tr></table></figure></p>
<p>#总结</p>
<p>J.U.C里AQS是一个相当核心的类，可以说没有它就没有J.U.C包。推荐大家看看<a href="http://gee.cs.oswego.edu/dl/papers/aqs.pdf" target="_blank" rel="external">AQS</a>这篇论文（网上有一些翻译，推荐大家还是看原文吧）。主要是用一个state表示状态，子类可以根据需要来定义state的含义，以及获取释放资源时具体如何操作state，当然需要通过CAS实现原子更改。当获取不到state的时候，线程加入队列，挂起。释放之后，唤醒队列中的线程。AQS支持两种模式，独占EXCLUSIVE和共享SHARED。J.U.C里本身也有很多直接继承AQS实现的类，包括Lock，CountDownLatch，Semaphore，FutureTask等，如果这些还不能满足你的使用，那么可以直接继承AQS来实现需要。</p>
<p>#Refers</p>
<ol>
<li><a href="http://gee.cs.oswego.edu/dl/papers/aqs.pdf" target="_blank" rel="external">http://gee.cs.oswego.edu/dl/papers/aqs.pdf</a></li>
<li><a href="http://ifeve.com/introduce-abstractqueuedsynchronizer/" target="_blank" rel="external">http://ifeve.com/introduce-abstractqueuedsynchronizer/</a></li>
<li><a href="http://ifeve.com/jdk1-8-abstractqueuedsynchronizer/" target="_blank" rel="external">http://ifeve.com/jdk1-8-abstractqueuedsynchronizer/</a></li>
<li><a href="http://ifeve.com/jdk1-8-abstractqueuedsynchronizer-part2/" target="_blank" rel="external">http://ifeve.com/jdk1-8-abstractqueuedsynchronizer-part2/</a></li>
<li><a href="http://book.douban.com/subject/6522893/" target="_blank" rel="external">http://book.douban.com/subject/6522893/</a></li>
<li><a href="http://my.oschina.net/magicly007/blog/364102" target="_blank" rel="external">http://my.oschina.net/magicly007/blog/364102</a></li>
</ol>
<blockquote>
<p>Written with <a href="https://stackedit.io/" target="_blank" rel="external">StackEdit</a>.</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;java5之后的java.util.concurrent包是世界级并发大师Doug Lea的作品，里面主要实现了&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;atomic包里Integer/Long对应的原子类，主要基于CAS；&lt;/li&gt;
&lt;li&gt;一些同步子，包括Lock，CountDownLatch，Semaphore，FutureTask等，这些都是基于AbstractQueuedSynchronizer类；&lt;/li&gt;
&lt;li&gt;关于线程执行的Executors类等；&lt;/li&gt;
&lt;li&gt;一些并发的集合类，比如ConcurrentHashMap，ConcurrentLinkedQueue，CopyOnWriteArrayList等。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;今天我们主要介绍AbstractQueuedSynchronizer这个可以说是最核心的类，没有之一。整个concurrent包里，基本都直接或间接地用到了这个类。Doug Lea的这篇&lt;a href=&quot;http://gee.cs.oswego.edu/dl/papers/aqs.pdf&quot;&gt;论文&lt;/a&gt;里面讲AQS的实现。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://magicly.me/categories/Java/"/>
    
    
      <category term="Java" scheme="http://magicly.me/tags/Java/"/>
    
      <category term="concurrency" scheme="http://magicly.me/tags/concurrency/"/>
    
      <category term="jdk" scheme="http://magicly.me/tags/jdk/"/>
    
      <category term="源码阅读" scheme="http://magicly.me/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
</feed>
